<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-12-13 五 22:04 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>来看看几种 Monad</title>
<meta name="generator" content="Org mode">
<meta name="author" content="刘向">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://liuxiang.coding.me/liuxiang/style/org/spacemacs-wide/htmlize.css"/>
 <script src="https://liuxiang.coding.me/liuxiang/js/org/spacemacs-wide/jquery.min.js"></script>
 <script src="https://liuxiang.coding.me/liuxiang/js/org/spacemacs-wide/bootstrap.min.js"></script>
 <script src="https://liuxiang.coding.me/liuxiang/js/org/spacemacs-wide/readtheorg.js"></script>
 <link rel="stylesheet" type="text/css" href="https://liuxiang.coding.me/liuxiang/style/org/spacemacs-wide/readtheorg.css"/>
 <link rel="stylesheet" type="text/css" href="https://liuxiang.coding.me/liuxiang/style/org/spacemacs-wide/font-awesome.min.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">来看看几种 Monad</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga2fd67d">1. 来看看几种 Monad</a>
<ul>
<li><a href="#orga3e6f5c">1.1. 动手做做看: Maybe Monad</a></li>
<li><a href="#org1b182d3">1.2. Monad type class</a></li>
<li><a href="#org583d10c">1.3. 走钢索</a></li>
<li><a href="#org46b932e">1.4. do 表示法</a></li>
<li><a href="#org9c6201e">1.5. List Monad</a>
<ul>
<li><a href="#org11d50cb">1.5.1. A knight's quest</a></li>
</ul>
</li>
<li><a href="#org081905f">1.6. Monad laws (单子律)</a>
<ul>
<li><a href="#orgd58c04c">1.6.1. Left identity</a></li>
<li><a href="#orgdab7a24">1.6.2. Right identity</a></li>
<li><a href="#org2005965">1.6.3. Associativity</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga2fd67d" class="outline-2">
<h2 id="orga2fd67d"><span class="section-number-2">1</span> 来看看几种 Monad</h2>
<div class="outline-text-2" id="text-1">
<p>
当我们第一次谈到 Functor的时候，我们了解到他是一个抽象概念，代表是一种可以被
map over的值。然后我们再将其概念提升到 Applicative Functor，他代表一种带有
context 的型态，我们可以用函数操作他而且同时还保有他的 context。
</p>

<p>
在这一章，我们会学到 Monad，基本上他是一种加强版的 Applicative Functor，正如
Applicative Functor 是 Functor 的加强版一样。
</p>


<div class="figure">
<p><img src="smugpig.png" alt="smugpig.png">
</p>
</div>

<p>
我们介绍到 Functor 是因为我们观察到有许多型态都可以被 function 给 map over，了解到这个目的，便抽象化了 <code>Functor</code> 这个 typeclass出来。但这让我们想问：如果给定一个 <code>a -&gt; b</code> 的函数以及 <code>f a</code> 的型态，我们要如何将函数 map over 这个型态而得到 <code>f b</code> ？我们知道要如何map over <code>Maybe a</code> ， <code>[a]</code> 以及 <code>IO a</code> 。我们甚至还知道如何用 <code>a -&gt; b</code> map over <code>r -&gt; a</code> ，并且会得到 <code>r -&gt; b</code> 。要回答这个问题，我们只需要看 <code>fmap</code> 的型态就好了：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">fmap</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Functor</span> f<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> f a <span style="color: #8787d7;">-&gt;</span> f b
</pre>
</div>

<p>
然后只要针对 <code>Functor</code> instance 撰写对应的实作。
</p>

<p>
之后我们又看到一些可以针对 Functor 改进的地方，例如 <code>a -&gt; b</code> 也被包在一个
Functor value 里面呢？像是 <code>Just (*3)</code> ，我们要如何 apply <code>Just 5</code> 给他？如果我们不要 apply <code>Just 5</code> 而是 <code>Nothing</code> 呢？甚至给定 <code>[(*2),(+4)]</code> ，我们要如何
apply 他们到 <code>[1,2,3]</code> 呢？对于此，我们抽象出=Applicative= typeclass，这就是我们想要问的问题：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">&lt;*&gt;</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Applicative</span> f<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> f <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> f a <span style="color: #8787d7;">-&gt;</span> f b
</pre>
</div>

<p>
我们也看到我们可以将一个正常的值包在一个数据型态中。例如说我们可以拿一个 <code>1</code>
然后把他包成 <code>Just 1</code> 。或是把他包成 <code>[1]</code> 。也可以是一个 I/O action会产生一个
<code>1</code> 。这样包装的 function 我们叫他做 <code>pure</code> 。
</p>

<p>
如我们说得，一个 applicative value 可以被看作一个有附加 context的值。例如说，
=​'a'​= 只是一个普通的字符，但 <code>Just 'a'​</code> 是一个附加了context 的字符。他不是
<code>Char</code> 而是 <code>Maybe Char</code> ，这型态告诉我们这个值可能是一个字符，也可能什么都没有。
</p>

<p>
来看看 <code>Applicative</code> typeclass 怎样让我们用普通的 function 操作他们，同时还保有 context：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">8</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">16</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">++</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"klingon"</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
所以我们可以视他们为 applicative values， <code>Maybe a</code> 代表可能会失败的
computation， <code>[a]</code> 代表同时有好多结果的 computation (non-deterministic
computation)，而 <code>IO a</code> 代表会有 side-effects 的 computation。
</p>

<p>
Monad 是一个从 Applicative functors很自然的一个演进结果。对于他们我们主要考量的点是：如果你有一个具有context 的值 <code>m a</code> ，你能如何把他丢进一个只接受普通值
<code>a</code> 的函数中，并回传一个具有 context 的值？也就是说，你如何套用一个型态为 <code>a
  -&gt; m b</code> 的函数至 <code>m a</code> ？基本上，我们要求的函数是：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">&gt;&gt;=</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> m a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> m b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m b
</pre>
</div>

<p>
如果我们有一个漂亮的值跟一个函数接受普通的值但回传漂亮的值，那我们要如何要把漂亮的值丢进函数中？这就是我们使用Monad 时所要考量的事情。我们不写成 <code>f a</code> 而写成 <code>m a</code> 是因为 <code>m</code> 代表的是 <code>Monad</code> ，但 monad 不过就是支持 <code>&gt;&gt;=</code> 操作的
applicative functors。 <code>&gt;&gt;=</code> 我们称呼他为 bind。
</p>

<p>
当我们有一个普通值 <code>a</code> 跟一个普通函数 <code>a -&gt; b</code> ，要套用函数是一件很简单的事。但当你在处理具有 context的值时，就需要多考虑些东西，要如何把漂亮的值喂进函数中，并如何考虑他们的行为，但你将会了解到他们其实不难。
</p>
</div>

<div id="outline-container-orga3e6f5c" class="outline-3">
<h3 id="orga3e6f5c"><span class="section-number-3">1.1</span> 动手做做看: Maybe Monad</h3>
<div class="outline-text-3" id="text-1-1">

<div class="figure">
<p><img src="buddha.png" alt="buddha.png">
</p>
</div>

<p>
现在对于什么是 Monad 已经有了些模糊的概念，我们来看看要如何让这概念更具体一些。
</p>

<p>
不意外地， <code>Maybe</code> 是一个 Monad，所以让我们对于他多探讨些，看看是否能跟我们所知的 Monad 概念结合起来。
</p>

<pre class="example">
到这边要确定你了解什么是 Applicatives。如果你知道好几种 ``Applicative`` 的 instance 
还有他们代表的意含就更好了，因为 monad 不过就是对 applicative 的概念进行一次升级。
</pre>

<p>
一个 <code>Maybe a</code> 型态的值代表型态为 <code>a</code> 的值而且具备一个可能造成错误的context。而 <code>Just "dharma"​</code> 的值代表他不是一个 =​"dharma"​= 的字串就是字串不见时的
<code>Nothing</code> 。如果你把字串当作计算的结果， <code>Nothing</code> 就代表计算失败了。
</p>

<p>
当我们把 <code>Maybe</code> 视作 functor，我们其实要的是一个 <code>fmap</code> 来把一个函数针对其中的元素做套用。他会对 <code>Just</code> 中的元素进行套用，要不然就是保留 <code>Nothing</code> 的状态，其代表里面根本没有元素。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> fmap <span style="color: #268bd2;">(</span><span style="color: #8787d7;">++</span><span style="color: #2aa198;">"!"</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"wisdom"</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"wisdom!"</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> fmap <span style="color: #268bd2;">(</span><span style="color: #8787d7;">++</span><span style="color: #2aa198;">"!"</span><span style="color: #268bd2;">)</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
或者视为一个 applicative functor，他也有类似的作用。只是 applicative也把函数包了起来。 <code>Maybe</code> 作为一个 applicative functor，我们能用 <code>&lt;*&gt;</code> 来套用一个存在 <code>Maybe</code> 中的函数至包在另外一个 <code>Maybe</code> 中的值。他们都必须是包在 <code>Just</code> 来代表值存在，要不然其实就是 <code>Nothing</code> 。当你在想套用函数到值上面的时候，缺少了函数或是值都会造成错误，所以这样做是很合理的。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">6</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"greed"</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> ord <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
当我们用 applicative 的方式套用函数至 <code>Maybe</code> 型态的值时，就跟上面描述的差不多。过程中所有值都必须是 <code>Just</code> ，要不然结果一定会是 <code>Nothing</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> max <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">6</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">6</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> max <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
我们来思考一下要怎么为 <code>Maybe</code> 实作 <code>&gt;&gt;=</code> 。正如我们之前提到的， <code>&gt;&gt;=</code> 接受一个 monadic value，以及一个接受普通值的函数，这函数会回传一个monadic value。
<code>&gt;&gt;=</code> 会帮我们套用这个函数到这个 monadic value。在函数只接受普通值的情况侠，函数是如何作到这件事的呢？要作到这件事，他必须要考虑到monadic value 的
context。
</p>

<p>
在这个案例中， <code>=&gt;&gt;=</code> 会接受一个 <code>Maybe a</code> 以及一个型态为 <code>a -&gt; Maybe b</code> 的函数。他会套用函数到 <code>Maybe a</code> 。要厘清他怎么作到的，首先我们注意到 <code>Maybe</code> 的
applicative functor 特性。假设我们有一个函数 <code>\x -&gt; Just (x+1)</code> 。他接受一个数字，把他加 <code>1</code> 后再包回 <code>Just</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #d75fd7;">1</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">2</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #d75fd7;">100</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">101</span>
</pre>
</div>

<p>
如果我们喂给函数 <code>1</code> ，他会计算成 <code>Just 2</code> 。如果我们喂给函数 <code>100</code> ，那结果便是 <code>Just 101</code> 。但假如我们喂一个 <code>Maybe</code> 的值给函数呢？如果我们把 <code>Maybe</code>
想成一个 applicative functor，那答案便很清楚。如果我们拿到一个 <code>Just</code> ，就把包在 <code>Just</code> 里面的值喂给函数。如果我们拿到一个 <code>Nothing</code> ，我们就说结果是
<code>Nothing</code> 。
</p>

<p>
我们调用 <code>applyMaybe</code> 而不调用 <code>&gt;&gt;=</code> 。他接受 <code>Maybe a</code> 跟一个回传 <code>Maybe b</code>
的函数，并套用函数至 <code>Maybe a</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">applyMaybe</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> b
<span style="color: #d75fd7; font-weight: bold;">applyMaybe</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> f  <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #d75fd7; font-weight: bold;">applyMaybe</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> x<span style="color: #268bd2;">)</span> f <span style="color: #8787d7;">=</span> f x
</pre>
</div>

<p>
我们套用一个 infix 函数，这样 <code>Maybe</code> 的值可以写在左边且函数是在右边：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">`applyMaybe`</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">4</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"smile"</span> <span style="color: #8787d7;">`applyMaybe`</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" :"</span><span style="color: #268bd2;">)</span><span style="color: #2aa198;">""</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"smile :"</span><span style="color: #dc752f; background-color: #303030;">"</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">`applyMaybe`</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">`applyMaybe`</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" :"</span><span style="color: #268bd2;">)</span><span style="color: #dc752f; background-color: #303030;">"</span><span style="color: #2aa198;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
在上述的范例中，我们看到在套用 <code>applyMaybe</code> 的时候，函数是套用在 <code>Just</code> 里面的值。当我们试图套用到 <code>Nothing</code> ，那整个结果便是 <code>Nothing</code> 。假如函数回传
<code>Nothing</code> 呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">`applyMaybe`</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">if</span> x <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span> <span style="color: #268bd2; font-weight: bold;">then</span> <span style="color: #df005f; font-weight: bold;">Just</span> x <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">`applyMaybe`</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">if</span> x <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span> <span style="color: #268bd2; font-weight: bold;">then</span> <span style="color: #df005f; font-weight: bold;">Just</span> x <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
这正是我们期待的结果。如果左边的 monadic value 是 <code>Nothing</code> ，那整个结果就是
<code>Nothing</code> 。如果右边的函数是 <code>Nothing</code> ，那结果也会是 <code>Nothing</code> 。这跟我们之前把 <code>Maybe</code> 当作applicative 时，过程中有任何一个 <code>Nothing</code> 整个结果就会是
<code>Nothing</code> 一样。
</p>

<p>
对于 <code>Maybe</code> 而言，我们已经找到一个方法处理漂亮值的方式。我们作到这件事的同时，也保留了 <code>Maybe</code> 代表可能造成错误的计算的意义。
</p>

<p>
你可能会问，这样的结果有用吗？由于 applicative functors让我们可以拿一个接受普通值的函数，并让他可以操作具有 context的值，这样看起来 applicative functors
好像比 monad 强。但我们会看到monad 也能作到，因为他只是 applicative functors
的升级版。他们同时也能作到 applicative functors 不能作到的事情。
</p>

<p>
稍候我们会再继续探讨 <code>Maybe</code> ，但我们先来看看 monad 的 type class。
</p>
</div>
</div>

<div id="outline-container-org1b182d3" class="outline-3">
<h3 id="org1b182d3"><span class="section-number-3">1.2</span> Monad type class</h3>
<div class="outline-text-3" id="text-1-2">
<p>
正如 functors 有 <code>Functor</code> 这个 type class，而 applicative functors有一个
<code>Applicative</code> 这个 type class，monad 也有他自己的 type class： <code>Monad</code> 他看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">class</span> <span style="color: #df005f; font-weight: bold;">Monad</span> m <span style="color: #268bd2; font-weight: bold;">where</span>
    return <span style="color: #8787d7;">::</span> a <span style="color: #8787d7;">-&gt;</span> m a

    <span style="color: #268bd2;">(</span><span style="color: #8787d7;">&gt;&gt;=</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> m a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> m b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m b

    <span style="color: #268bd2;">(</span><span style="color: #8787d7;">&gt;&gt;</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> m a <span style="color: #8787d7;">-&gt;</span> m b <span style="color: #8787d7;">-&gt;</span> m b
    x <span style="color: #8787d7;">&gt;&gt;</span> y <span style="color: #8787d7;">=</span> x <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span><span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">-&gt;</span> y

    fail <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> m a
    fail msg <span style="color: #8787d7;">=</span> error msg
</pre>
</div>


<div class="figure">
<p><img src="kid.png" alt="kid.png">
</p>
</div>

<p>
我们从第一行开始看。他说 <code>class Monad m where</code> 。但我们之前不是提到 monad是
applicative functors的加强版吗？不是应该有一个限制说一个型态必须先是一个
applicative functor才可能是一个 monad 吗？像是 <code>class (Applicative m) = &gt;
   Monad m where</code> 。他的确应该要有，但当 Haskell被创造的早期，人们没有想到
applicative functor适合被放进语言中，所以最后没有这个限制。但的确每个 monad
都是applicative functor，即使 <code>Monad</code> 并没有这么宣告。
</p>

<p>
在 <code>Monad</code> typeclass 中定义的第一个函数是 <code>return</code> 。他其实等价于 <code>pure</code> ，只是名字不同罢了。他的型态是=(Monad m) <code>&gt; a -&gt; m a</code> 。他接受一个普通值并把他放进一个最小的 context中。也就是说他把普通值包进一个 monad 里面。他跟
<code>Applicative</code> 里面 <code>pure</code> 函数做的事情一样，所以说其实我们已经认识了 <code>return</code>
。我们已经用过 <code>return</code> 来处理一些 I/O。我们用他来做一些假的 I/O，印出一些值。对于 <code>Maybe</code> 来说他就是接受一个普通值然后包进 <code>Just</code> 。
</p>

<pre class="example">
提醒一下：``return`` 跟其他语言中的 ``return`` 是完全不一样的。
他并不是结束一个函数的执行，他只不过是把一个普通值包进一个 context 里面。
</pre>


<div class="figure">
<p><img src="tur2.png" alt="tur2.png">
</p>
</div>

<p>
接下来定义的函数是 bind: <code>&gt;&gt;=</code> 。他就像是函数套用一样，只差在他不接受普通值，他是接受一个 monadic value（也就是具有 context的值）并且把他喂给一个接受普通值的函数，并回传一个 monadic value。
</p>

<p>
接下来，我们定义了 <code>&gt;&gt;</code> 。我们不会介绍他，因为他有一个事先定义好的实作，基本上我们在实作 <code>Monad</code> typeclass 的时候都不会去理他。
</p>

<p>
最后一个函数是 <code>fail</code> 。我们通常在我们程序中不会具体写出来。他是被Haskell 用在处理语法错误的情况。我们目前不需要太在意 <code>fail</code> 。
</p>

<p>
我们知道了 <code>Monad</code> typeclass 长什么样子，我们来看一下 <code>Maybe</code> 的 <code>Monad</code>
instance。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">Monad</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    return x <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Just</span> x
    <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
    <span style="color: #df005f; font-weight: bold;">Just</span> x <span style="color: #8787d7;">&gt;&gt;=</span> f  <span style="color: #8787d7;">=</span> f x
    fail <span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
 <code>return</code> 跟 <code>pure</code> 是等价的。这没什么困难的。我们跟我们在定义 <code>Applicative</code>
的时候做一样的事，只是把他用 <code>Just</code> 包起来。
</p>

<p>
<code>&gt;&gt;=</code> 跟我们的 <code>applyMaybe</code> 是一样的。当我们将 <code>Maybe a</code> 塞给我们的函数，我们保留住context，并且在输入是 <code>Nothing</code> 的时候回传 <code>Nothing</code> 。毕竟当没有值的时候套用我们的函数是没有意义的。当输入是 <code>Just</code> 的时候则套用 <code>f</code> 并将他包在 <code>Just</code> 里面。
</p>

<p>
我们可以试着感觉一下 <code>Maybe</code> 是怎样表现成Monad的。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #2aa198;">"WHAT"</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"WHAT"</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">9</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #268bd2;">(</span>x<span style="color: #8787d7;">*</span><span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">90</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #268bd2;">(</span>x<span style="color: #8787d7;">*</span><span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
第一行没什么了不起，我们已经知道 <code>return</code> 就是 <code>pure</code> 而我们又对  <code>Maybe</code> 操作过 <code>pure</code> 了。至于下两行就比较有趣点。
</p>

<p>
留意我们是如何把 <code>Just 9</code> 喂给 <code>\x -&gt; return (x*10)</code> 。在函数中 <code>x=绑定到 =9</code>
。他看起好像我们能不用 pattern matching 的方式就从 <code>Maybe=中抽取出值。但我们并没有丧失掉 =Maybe</code> 的 context，当他是 <code>Nothing</code> 的时候， <code>&gt;&gt;=</code> 的结果也会是
<code>Nothing</code> 。
</p>
</div>
</div>

<div id="outline-container-org583d10c" class="outline-3">
<h3 id="org583d10c"><span class="section-number-3">1.3</span> 走钢索</h3>
<div class="outline-text-3" id="text-1-3">

<div class="figure">
<p><img src="pierre.png" alt="pierre.png">
</p>
</div>

<p>
我们已经知道要如何把 <code>Maybe a</code> 喂进 <code>a -&gt; Maybe b</code> 这样的函数。我们可以看看我们如何重复使用 <code>&gt;&gt;=</code> 来处理多个 <code>Maybe a</code> 的值。
</p>

<p>
首先来说个小故事。皮尔斯决定要辞掉他的工作改行试着走钢索。他对走钢索蛮在行的，不过仍有个小问题。就是鸟会停在他拿的平衡竿上。他们会飞过来停一小会儿，然后再飞走。这样的情况在两边的鸟的数量一样时并不是个太大的问题。但有时候，所有的鸟都会想要停在同一边，皮尔斯就失去了平衡，就会让他从钢索上掉下去。
</p>

<p>
我们这边假设两边的鸟差异在三个之内的时候，皮尔斯仍能保持平衡。所以如果是右边有一只，左边有四只的话，那还撑得住。但如果左边有五只，那就会失去平衡。
</p>

<p>
我们要写个程序来仿真整个情况。我们想看看皮尔斯究竟在好几只鸟来来去去后是否还能撑住。例如说，我们想看看先来了一只鸟停在左边，然后来了四只停在右边，然后左边那只飞走了。之后会是什么情形。
</p>

<p>
我们用一对整数来代表我们的平衡竿状态。头一个位置代表左边的鸟的数量，第二个位置代表右边的鸟的数量。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Birds</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Pole</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Birds</span>,<span style="color: #df005f; font-weight: bold;">Birds</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
由于我们用整数来代表有多少只鸟，我们便先来定义 <code>Int</code> 的同义型态，叫做 <code>Birds</code>
。然后我们把 <code>(Birds, Birds)</code> 定义成 <code>Pole</code> 。
</p>

<p>
接下来，我们定义一个函数他接受一个数字，然后把他放在竿子的左边，还有另外一个函数放在右边。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">landLeft</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Birds</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Pole</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">landLeft</span> n <span style="color: #268bd2;">(</span>left,right<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span>left <span style="color: #8787d7;">+</span> n,right<span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">landRight</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Birds</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Pole</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">landRight</span> n <span style="color: #268bd2;">(</span>left,right<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span>left,right <span style="color: #8787d7;">+</span> n<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们来试着执行看看：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> landLeft <span style="color: #d75fd7;">2</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> landRight <span style="color: #d75fd7;">1</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> landRight <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
要仿真鸟飞走的话我们只要给定一个负数就好了。 由于这些操作是接受 <code>Pole</code> 并回传
 <code>Pole</code> ， 所以我们可以把函数串在一起。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> landLeft <span style="color: #d75fd7;">2</span> <span style="color: #268bd2;">(</span>landRight <span style="color: #d75fd7;">1</span> <span style="color: #d75fd7;">(</span>landLeft <span style="color: #d75fd7;">1</span> <span style="color: #2aa198;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
当我们喂 <code>(0,0)</code> 给 <code>landLeft 1</code> 时，我们会得到 <code>(1,0)</code> 。接着我们仿真右边又停了一只鸟，状态就变成 <code>(1,1)</code> 。最后又有两只鸟停在左边，状态变成 <code>(3,1)</code> 。我们这边的写法是先写函数名称，然后再套用参数。但如果先写 pole再写函数名称会比较清楚，所以我们会想定义一个函数
</p>

<div class="org-src-container">
<pre class="src src-haskell">x <span style="color: #d75fd7; font-weight: bold;">-:</span> f <span style="color: #8787d7;">=</span> f x
</pre>
</div>

<p>
我们能先套用参数然后再写函数名称：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #d75fd7;">100</span> <span style="color: #8787d7;">-:</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7;">300</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">True</span> <span style="color: #8787d7;">-:</span> not
<span style="color: #df005f; font-weight: bold;">False</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-:</span> landLeft <span style="color: #d75fd7;">2</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
有了这个函数，我们便能写得比较好读一些：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-:</span> landLeft <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-:</span> landRight <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-:</span> landLeft <span style="color: #d75fd7;">2</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
这个范例跟先前的范例是等价的，只不过好读许多。很清楚的看出我们是从 <code>(0,0)</code> 开始，然后停了一只在左边，接着右边又有一只，最后左边多了两只。
</p>

<p>
到目前为止没什么问题，但如果我们要停 10 只在左边呢？
</p>

<pre class="example">
ghci&gt; landLeft 10 (0,3)
(10,3)
</pre>

<p>
你说左边有 10 只右边却只有 3只？那不是早就应该掉下去了？这个例子太明显了，如果换个比较不明显的例子。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-:</span> landLeft <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-:</span> landRight <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">-:</span> landLeft <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-:</span> landRight <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
表面看起来没什么问题，但如果你仔细看的话，有一瞬间是右边有四只，但左边没有鸟。要修正这个错误，我们要重新查看 <code>landLeft</code> 跟 <code>landRight</code> 。我们其实是希望这些函数产生失败的情况。那就是在维持平衡的时候回传新的pole，但失败的时候告诉我们失败了。这时候 <code>Maybe</code> 就刚刚好是我们要的context 了。我们用 <code>Maybe</code> 重新写一次：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">landLeft</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Birds</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Pole</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">landLeft</span> n <span style="color: #268bd2;">(</span>left,right<span style="color: #268bd2;">)</span>
    <span style="color: #8787d7;">|</span> abs <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span>left <span style="color: #8787d7;">+</span> n<span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">-</span> right<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;</span> <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>left <span style="color: #8787d7;">+</span> n, right<span style="color: #268bd2;">)</span>
    <span style="color: #8787d7;">|</span> otherwise                    <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>

<span style="color: #d75fd7; font-weight: bold;">landRight</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Birds</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Pole</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">landRight</span> n <span style="color: #268bd2;">(</span>left,right<span style="color: #268bd2;">)</span>
    <span style="color: #8787d7;">|</span> abs <span style="color: #268bd2;">(</span>left <span style="color: #8787d7;">-</span> <span style="color: #d75fd7;">(</span>right <span style="color: #8787d7;">+</span> n<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;</span> <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>left, right <span style="color: #8787d7;">+</span> n<span style="color: #268bd2;">)</span>
    <span style="color: #8787d7;">|</span> otherwise                    <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
现在这些函数不回传 <code>Pole</code> 而回传 <code>Maybe Pole</code> 了。他们仍接受鸟的数量跟旧的的
pole，但他们现在会检查是否有太多鸟会造成皮尔斯失去平衡。我们用 guards来检查是否有差异超过三的情况。如果没有，那就包一个在 <code>Just</code> 中的新的pole，如果是，那就回传 <code>Nothing</code> 。
</p>

<p>
再来执行看看：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> landLeft <span style="color: #d75fd7;">2</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> landLeft <span style="color: #d75fd7;">10</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
一如预期，当皮尔斯不会掉下去的时候，我们就得到一个包在 <code>Just</code> 中的新pole。当太多鸟停在同一边的时候，我们就会拿到 <code>Nothing</code> 。这样很棒，但我们却不知道怎么把东西串在一起了。我们不能做 <code>landLeft 1 (landRight 1 (0,0))</code> ，因为当我们对
<code>(0,0)</code> 使用 <code>landRight 1</code> 时，我们不是拿到 <code>Pole</code> 而是拿到 <code>Maybe Pole</code> 。
<code>landLeft 1</code> 会拿到 <code>Pole</code> 而不是拿到 <code>Maybe Pole</code> 。
</p>

<p>
我们需要一种方法可以把拿到的 <code>Maybe Pole</code> 塞到拿 <code>Pole</code> 的函数中，然后回传
 <code>Maybe Pole</code> 。而我们有 <code>&gt;&gt;=</code> ，他对 <code>Maybe</code> 做的事就是我们要的
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> landRight <span style="color: #d75fd7;">1</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #d75fd7;">2</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
<code>landLeft 2</code> 的型态是 <code>Pole -&gt; Maybe Pole</code> 。我们不能喂给他 <code>Maybe Pole</code> 的东西。而 <code>landRight 1 (0,0)</code> 的结果就是 <code>Maybe Pole</code> ，所以我们用 <code>&gt;&gt;=</code> 来接受一个有 context 的值然后拿给 <code>landLeft 2</code> 。 <code>&gt;&gt;=</code> 的确让我们把 <code>Maybe</code> 当作有
context 的值，因为当我们丢 <code>Nothing</code> 给 <code>landLeft 2</code> 的时候，结果会是
<code>Nothing</code> 。
</p>

<pre class="example">
ghci&gt; Nothing &gt;&gt;= landLeft 2
Nothing
</pre>

<p>
这样我们可以把这些新写的用 <code>&gt;&gt;=</code> 串在一起。让 monadic value可以喂进只吃普通值的函数。
</p>

<p>
来看看些例子：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">2</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们最开始用 <code>return</code> 回传一个 pole 并把他包在 <code>Just</code> 里面。我们可以像往常套用 <code>landRight 2</code> ，不过我们不那么做，我们改用 <code>&gt;&gt;=</code> 。 <code>Just (0,0)</code> 被喂到
<code>landRight 2</code> ，得到 <code>Just (0,2)</code> 。接着被喂到 <code>landLeft 2</code> ，得到 <code>Just
   (2,2)</code> 。
</p>

<p>
还记得我们之前引入失败情况的例子吗？
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-:</span> landLeft <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-:</span> landRight <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">-:</span> landLeft <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-:</span> landRight <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
之前的例子并不会反应失败的情况。但如果我们用 <code>&gt;&gt;=</code> 的话就可以得到失败的结果。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>


<div class="figure">
<p><img src="banana.png" alt="banana.png">
</p>
</div>

<p>
正如预期的，最后的情形代表了失败的情况。我们再进一步看看这是怎么产生的。首先
<code>return</code> 把 <code>(0,0)</code> 放到一个最小的 context 中，得到 <code>Just (0,0)</code> 。然后是
<code>Just (0.0) &gt;&gt;= landLeft 1</code> 。由于 <code>Just (0,0)</code> 是一个 <code>Just</code> 的值。
<code>landLeft 1</code> 被套用至 <code>(0,0)</code> 而得到 <code>Just (1,0)</code> 。这反应了我们仍保持在平衡的状态。接着是 <code>Just (1,0) &gt;&gt;</code> landright 4= 而得到了 <code>Just (1,4)</code> 。距离不平衡只有一步之遥了。他又被喂给 <code>landLeft (-1)</code> ，这组合成了 <code>landLeft (-1)
   (1,4)</code> 。由于失去了平衡，我们变得到了 <code>Nothing</code> 。而我们把 <code>Nothing</code> 喂给
<code>landRight (-2)</code> ，由于他是 <code>Nothing</code> ，也就自动得到了 <code>Nothing</code> 。
</p>

<p>
如果只把 <code>Maybe</code> 当作 applicative用的话是没有办法达到我们要的效果的。你试着做一遍就会卡住。因为applicative functor 并不允许 applicative value之间有弹性的交互。他们最多就是让我们可以用 applicative style来传递参数给函数。applicative
operators 能拿到他们的结果并把他用applicative 的方式喂给另一个函数，并把最终的 applicative值放在一起。但在每一步之间并没有太多允许我们作手脚的机会。而我们的范例需要每一步都倚赖前一步的结果。当每一只鸟降落的时候，我们都会把前一步的结果拿出来看看。好知道结果到底应该成功或失败。
</p>

<p>
我们也能写出一个函数，完全不管现在究竟有几只鸟停在竿子上，只是要害皮尔斯滑倒。我们可以称呼这个函数叫做 <code>banana</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">banana</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Pole</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">banana</span> <span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
现在我们能把香蕉皮串到我们的过程中。他绝对会让遇到的人滑倒。他完全不管前面的状态是什么都会产生失败。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">&gt;&gt;=</span> banana <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">1</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
<code>Just (1,0)</code> 被喂给 <code>banana</code> ，而产生了 <code>Nothing</code> ，之后所有的结果便都是
<code>Nothing</code> 了。
</p>

<p>
要同样表示这种忽略前面的结果，只注重眼前的 monadic value的情况，其实我们可以用 <code>&gt;&gt;</code> 来表达。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">&gt;&gt;</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> m a <span style="color: #8787d7;">-&gt;</span> m b <span style="color: #8787d7;">-&gt;</span> m b
m <span style="color: #d75fd7; font-weight: bold;">&gt;&gt;</span> n <span style="color: #8787d7;">=</span> m <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span><span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">-&gt;</span> n
</pre>
</div>

<p>
一般来讲，碰到一个完全忽略前面状态的函数，他就应该只会回传他想回传的值而已。但碰到Monad，他们的 context 还是必须要被考虑到。来看一下 <code>&gt;&gt;</code> 串接 <code>Maybe</code> 的情况。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">&gt;&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">4</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">4</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
如果你把 <code>&gt;&gt;</code> 换成 <code>&gt;&gt;= \_ -&gt;</code> ，那就很容易看出他的意思。
</p>

<p>
我们也可以把 <code>banana</code> 改用 <code>&gt;&gt;</code> 跟 <code>Nothing</code> 来表达：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">&gt;&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">1</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
我们得到了保证的失败。
</p>

<p>
我们也可以看看假如我们故意不用把 <code>Maybe</code> 视为有 context的值的写法。他会长得像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">routine</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">routine</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">case</span> landLeft <span style="color: #d75fd7;">1</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">of</span>
    <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
    <span style="color: #df005f; font-weight: bold;">Just</span> pole1 <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">case</span> landRight <span style="color: #d75fd7;">4</span> pole1 <span style="color: #268bd2; font-weight: bold;">of</span>
            <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
            <span style="color: #df005f; font-weight: bold;">Just</span> pole2 <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">case</span> landLeft <span style="color: #d75fd7;">2</span> pole2 <span style="color: #268bd2; font-weight: bold;">of</span>
                    <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
                    <span style="color: #df005f; font-weight: bold;">Just</span> pole3 <span style="color: #8787d7;">-&gt;</span> landLeft <span style="color: #d75fd7;">1</span> pole3
</pre>
</div>


<div class="figure">
<p><img src="centaur.png" alt="centaur.png">
</p>
</div>

<p>
左边先停了一只鸟，然后我们停下来检查有没有失败。当失败的时候我们回传
<code>Nothing</code> 。当成功的时候，我们在右边停一只鸟，然后再重复前面做的事情。把这些琐事转换成 <code>&gt;&gt;=</code> 证明了 <code>Maybe</code> Monad 的力量，可以省去我们不少的时间。
</p>

<p>
注意到 <code>Maybe</code> 对 <code>&gt;&gt;=</code> 的实作，他其实就是在做碰到 <code>Nothing</code> 就会传 <code>Nothing</code>
，碰到正确值就继续用 <code>Just</code> 传递值。
</p>

<p>
在这个章节中，我们看过了好几个函数，也见识了用 <code>Maybe</code> monad来表示失败的
context 的力量。把普通的函数套用换成了 <code>&gt;&gt;=</code> ，让我们可以轻松地应付可能会失败的情况，并帮我们传递context。这边的 context 就代表失败的可能性，当我们套用函数到 context的时候，就代表考虑进了失败的情况。
</p>
</div>
</div>

<div id="outline-container-org46b932e" class="outline-3">
<h3 id="org46b932e"><span class="section-number-3">1.4</span> do 表示法</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Monad 在 Haskell中是十分重要的，所以我们还特别为了操作他设置了特别的语法：
 <code>do</code> 表示法。我们在介绍 I/O 的时候已经用过 <code>do</code> 来把小的 I/O action串在一起了。其实 <code>do</code> 并不只是可以用在 <code>IO</code> ，他可以用在任何 monad上。他的原则是简单明了，把 monadic value 串成一串。我们这边来细看 <code>do</code> 是如何使用，以及为什么我们十分倚赖他。
</p>

<p>
来看一下熟悉的例子：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">(</span>show x <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">"!"</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"3!"</span>
</pre>
</div>

<p>
你说这没什么了不起，不过就是把 monadic value 喂给一个函数罢了。其中 <code>x</code> 就指定成 <code>3</code> 。也从 monadic value 变成了普通值。那如果我们要在 lambda中使用 <code>&gt;&gt;=</code>
呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"!"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">\</span>y <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">(</span>show x <span style="color: #8787d7;">++</span> y<span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"3!"</span>
</pre>
</div>

<p>
我们嵌一个 <code>&gt;&gt;=</code> 在另外一个 <code>&gt;&gt;=</code> 中。在外层的 lambda，我们把 <code>Just "!"​</code> 喂给
<code>\y -&gt; Just (show x ++ y)</code> 。在内层的 lambda， <code>y</code> 被指定成 =​"!"​= 。 <code>x</code> 仍被指定成 <code>3</code> ，是因为我们是从外层的 lambda取值的。这些行为让我们回想到下列式子：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> x <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">3</span>; y <span style="color: #8787d7;">=</span> <span style="color: #2aa198;">"!"</span> <span style="color: #268bd2; font-weight: bold;">in</span> show x <span style="color: #8787d7;">++</span> y
<span style="color: #2aa198;">"3!"</span>
</pre>
</div>

<p>
差别在于前述的值是 monadic，具有失败可能性的context。我们可以把其中任何一步代换成失败的状态：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"!"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">\</span>y <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">(</span>show x <span style="color: #8787d7;">++</span> y<span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">\</span>y <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">(</span>show x <span style="color: #8787d7;">++</span> y<span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"!"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">\</span>y <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
第一行中，把 <code>Nothing</code> 喂给一个函数，很自然地会回传 <code>Nothing</code> 。第二行里，我们把 <code>Just 3</code> 喂给一个函数，所以 <code>x</code> 就成了 <code>3</code> 。但我们把 <code>Nothing</code> 喂给内层的 lambda 所有的结果就成了 <code>Nothing</code> ，这也进一步使得外层的 lambda 成了
<code>Nothing=。这就好比我们在=let</code> expression 中来把值指定给变量一般。只差在我们这边的值是 monadic value。
</p>

<p>
要再说得更清楚点，我们来把 script 改写成每行都处理一个 <code>Maybe</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">foo</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #d75fd7; font-weight: bold;">foo</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span>   <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span>
      <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"!"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">\</span>y <span style="color: #8787d7;">-&gt;</span>
      <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">(</span>show x <span style="color: #8787d7;">++</span> y<span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
为了摆脱这些烦人的 lambda，Haskell 允许我们使用 <code>do</code> 表示法。他让我们可以把先前的程序写成这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">foo</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #d75fd7; font-weight: bold;">foo</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    x <span style="color: #8787d7;">&lt;-</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span>
    y <span style="color: #8787d7;">&lt;-</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"!"</span>
    <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>show x <span style="color: #8787d7;">++</span> y<span style="color: #268bd2;">)</span>
</pre>
</div>


<div class="figure">
<p><img src="owld.png" alt="owld.png">
</p>
</div>

<p>
这看起来好像让我们不用在每一步都去检查 <code>Maybe</code> 的值究竟是 <code>Just</code> 或 <code>Nothing</code>
。这蛮方便的，如果在任何一个步骤我们取出了 <code>Nothing</code> 。那整个 <code>do</code> 的结果就会是 <code>Nothing</code> 。我们把整个责任都交给 <code>&gt;&gt;=</code> ，他会帮我们处理所有 context 的问题。这边的 <code>do</code> 表示法不过是另外一种语法的形式来串连所有的 monadic value 罢了。
</p>

<p>
在 <code>do</code> expression 中，每一行都是一个 monadic value。要检查处理的结果的话，就要使用 <code>&lt;-</code> 。如果我们拿到一个 <code>Maybe String</code> ，并用 <code>&lt;-</code> 来绑定给一个变量，那个变量就会是一个 <code>String</code> ，就像是使用 <code>&gt;&gt;=</code> 来将 monadic value 带给 lambda
一样。至于=do= expression 中的最后一个值，好比说 <code>Just (show x ++ y)</code> ，就不能用 <code>&lt;-</code> 来绑定结果，因为那样的写法当转换成 <code>&gt;&gt;=</code> 的结果时并不合理。他必须要是所有 monadic value黏起来后的总结果，要考虑到前面所有可能失败的情形。
</p>

<p>
举例来说，来看看下面这行：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">9</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">(</span>x <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">8</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #df005f; font-weight: bold;">True</span>
</pre>
</div>

<p>
由于 <code>&gt;&gt;=</code> 左边的参数是一个 <code>Just</code> 型态的值，当 lambda 被套用至 <code>9</code> 就会得到
 <code>Just True</code> 。如果我们重写整个式子，改用 <code>do</code> 表示法：我们会得到：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">marySue</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Bool</span>
<span style="color: #d75fd7; font-weight: bold;">marySue</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    x <span style="color: #8787d7;">&lt;-</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">9</span>
    <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">8</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
如果我们比较这两种写法，就很容易看出为什么整个 monadic value的结果会是在 <code>do</code>
表示法中最后一个 monadic value的值。他串连了全面所有的结果。
</p>

<p>
我们走钢索的仿真程序也可以改用 <code>do</code> 表示法重写。 <code>landLeft</code> 跟 <code>landRight</code> 接受一个鸟的数字跟一个竿子来产生一个包在 <code>Just</code> 中新的竿子。而在失败的情况会产生 <code>Nothing</code> 。我们使用 <code>&gt;&gt;=</code> 来串连所有的步骤，每一步都倚赖前一步的结果，而且都带有可能失败的context。这边有一个范例，先是有两只鸟停在左边，接着有两只鸟停在右边，然后是一只鸟停在左边：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">routine</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">routine</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    start <span style="color: #8787d7;">&lt;-</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span>
    first <span style="color: #8787d7;">&lt;-</span> landLeft <span style="color: #d75fd7;">2</span> start
    second <span style="color: #8787d7;">&lt;-</span> landRight <span style="color: #d75fd7;">2</span> first
    landLeft <span style="color: #d75fd7;">1</span> second
</pre>
</div>

<p>
我们来看看成功的结果：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> routine
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
当我们要把这些 routine 用具体写出的 <code>&gt;&gt;=</code> ，我们会这样写： <code>return (0,0) &gt;&gt;=
   landLeft 2</code> ，而有了 <code>do</code> 表示法，每一行都必须是一个 monadic value。所以我们清楚地把前一个 <code>Pole</code> 传给 <code>landLeft</code> 跟 <code>landRight</code> 。如果我们查看我们绑定
<code>Maybe</code> 的变量， <code>start</code> 就是 <code>(0,0)</code> ，而 <code>first</code> 就会是 <code>(2,0)</code> 。
</p>

<p>
由于 <code>do</code> 表示法是一行一行写，他们会看起来很像是命令式的写法。但实际上他们只是代表串行而已，每一步的值都倚赖前一步的结果，并带着他们的context 继续下去。
</p>

<p>
我们再重新来看看如果我们没有善用 <code>Maybe</code> 的 monad 性质的程序：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">routine</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
    routine <span style="color: #8787d7;">=</span>
        <span style="color: #268bd2; font-weight: bold;">case</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">of</span>
            <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
            <span style="color: #df005f; font-weight: bold;">Just</span> start <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">case</span> landLeft <span style="color: #d75fd7;">2</span> start <span style="color: #268bd2; font-weight: bold;">of</span>
                <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
                <span style="color: #df005f; font-weight: bold;">Just</span> first <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">case</span> landRight <span style="color: #d75fd7;">2</span> first <span style="color: #268bd2; font-weight: bold;">of</span>
                    <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
                    <span style="color: #df005f; font-weight: bold;">Just</span> second <span style="color: #8787d7;">-&gt;</span> landLeft <span style="color: #d75fd7;">1</span> second
</pre>
</div>

<p>
在成功的情形下， <code>Just (0,0)</code> 变成了 <code>start</code> ， 而 <code>landLeft 2 start</code> 的结果成了 <code>first</code> 。
</p>

<p>
如果我们想在 <code>do</code> 表示法里面对皮尔斯丢出香蕉皮，我们可以这样做：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">routine</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Pole</span>
<span style="color: #d75fd7; font-weight: bold;">routine</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    start <span style="color: #8787d7;">&lt;-</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span>
    first <span style="color: #8787d7;">&lt;-</span> landLeft <span style="color: #d75fd7;">2</span> start
    <span style="color: #df005f; font-weight: bold;">Nothing</span>
    second <span style="color: #8787d7;">&lt;-</span> landRight <span style="color: #d75fd7;">2</span> first
    landLeft <span style="color: #d75fd7;">1</span> second
</pre>
</div>

<p>
当我们在 <code>do</code> 表示法写了一行运算，但没有用到 <code>&lt;-</code> 来绑定值的话，其实实际上就是用了 <code>&gt;&gt;</code> ，他会忽略掉计算的结果。我们只是要让他们有序，而不是要他们的结果，而且他比写成 <code>_ &lt;- Nothing</code> 要来得漂亮的多。
</p>

<p>
你会问究竟我们何时要使用 <code>do</code> 表示法或是 <code>&gt;&gt;=</code> ，这完全取决于你的习惯。在这个例子由于有每一步都倚赖于前一步结果的特性，所以我们使用 <code>&gt;&gt;=</code> 。如果用 <code>do</code> 表示法，我们就必须清楚写出鸟究竟是停在哪根竿子上，但其实每一次都是前一次的结果。不过他还是让我们了解到怎么使用 <code>do</code> 。
</p>

<p>
在 <code>do</code> 表示法中，我们其实可以用模式匹配来绑定 monadic value，就好像我们在
 <code>let</code> 表达式，跟函数参数中使用模式匹配一样。这边来看一个在 <code>do</code> 表示法中使用模式匹配的范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">justH</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Char</span>
<span style="color: #d75fd7; font-weight: bold;">justH</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"hello"</span>
    return x
</pre>
</div>

<p>
我们用模式匹配来取得 =​"hello"​= 的第一个字符，然后回传结果。所以 <code>justH</code> 计算会得到 =​Just 'h'​= 。
</p>

<p>
如果模式匹配失败怎么办？当定义一个函数的时候，一个模式不匹配就会跳到下一个模式。如果所有都不匹配，那就会造成错误，整个程序就当掉。另一方面，如果在 <code>let</code>
中进行模式匹配失败会直接造成错误。毕竟在 <code>let</code> 表达式的情况下并没有失败就跳下一个的设计。至于在 <code>do</code> 表示法中模式匹配失败的话，那就会调用 <code>fail</code> 函数。他定义在 <code>Monad</code> 的type class 定义猪。他允许在现在的 monad context底下，失败只会造成失败而不会让整个程序当掉。他缺省的实作如下：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">fail</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> m a
<span style="color: #d75fd7; font-weight: bold;">fail</span> msg <span style="color: #8787d7;">=</span> error msg
</pre>
</div>

<p>
可见缺省的实作的确是让程序挂掉，但在某些考虑到失败的可能性的 Monad（像是
 <code>Maybe</code> ）常常会有他们自己的实作。对于 <code>Maybe</code> ，他的实作像是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">fail</span> <span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
他忽略错误消息，并直接回传 <code>Nothing</code> 。所以当在 <code>do</code> 表示法中的 <code>Maybe</code> 模式匹配失败的时候，整个结果就会是 <code>Nothing</code> 。这种方式比起让程序挂掉要好多了。这边来看一下 <code>Maybe</code> 模式匹配失败的范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">wopwop</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Char</span>
<span style="color: #d75fd7; font-weight: bold;">wopwop</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">""</span>
    return x
</pre>
</div>

<p>
模式匹配的失败，所以那一行的效果相当于一个 <code>Nothing</code> 。我们来看看执行结果：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> wopwop
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
这样模式匹配的失败只会限制在我们 monad 的 context中，而不是整个程序的失败。这种处理方式要好多了。
</p>
</div>
</div>

<div id="outline-container-org9c6201e" class="outline-3">
<h3 id="org9c6201e"><span class="section-number-3">1.5</span> List Monad</h3>
<div class="outline-text-3" id="text-1-5">

<div class="figure">
<p><img src="deadcat.png" alt="deadcat.png">
</p>
</div>

<p>
我们已经了解了 <code>Maybe</code> 可以被看作具有失败可能性 context的值，也见识到如何用
 <code>&gt;&gt;=</code> 来把这些具有失败考量的值传给函数。在这一个章节中，我们要看一下如何利用
 list 的 monadic 的性质来写 non-deterministic 的程序。
</p>

<p>
我们已经讨论过在把 list 当作 applicatives 的时候他们具有non-deterministic 的性质。像 <code>5</code> 这样一个值是 deterministic的。他只有一种结果，而且我们清楚的知道他是什么结果。另一方面，像 <code>[3,8,9]</code> 这样的值包含好几种结果，所以我们能把他看作是同时具有好几种结果的值。把list 当作 applicative functors 展示了这种特性：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">100</span>,<span style="color: #d75fd7;">1000</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">100</span>,<span style="color: #d75fd7;">1000</span>,<span style="color: #d75fd7;">20</span>,<span style="color: #d75fd7;">200</span>,<span style="color: #d75fd7;">2000</span>,<span style="color: #d75fd7;">30</span>,<span style="color: #d75fd7;">300</span>,<span style="color: #d75fd7;">3000</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
将左边 list 中的元素乘上右边 list 中的元素这样所有的组合全都被放进结果的list
中。当处理 non-determinism的时候，这代表我们有好几种选择可以选，我们也会每种选择都试试看，因此最终的结果也会是一个non-deterministic 的值。只是包含更多不同可能罢了。
</p>

<p>
non-determinism 这样的 context 可以被漂亮地用 monad来考虑。所以我们这就来看看
list 的 <code>Monad</code> instance 的定义：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">Monad</span> <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    return x <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">[</span>x<span style="color: #268bd2;">]</span>
    xs <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> concat <span style="color: #268bd2;">(</span>map f xs<span style="color: #268bd2;">)</span>
    fail <span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">[]</span>
</pre>
</div>

<p>
<code>return</code> 跟 <code>pure</code> 是做同样的事，所以我们应该算已经理解了 <code>return</code> 的部份。他接受一个值，并把他放进一个最小的一个 context中。换种说法，就是他做了一个只包含一个元素的list。这样对于我们想要操作普通值的时候很有用，可以直接把他包起来变成non-deterministic value。
</p>

<p>
要理解 <code>&gt;&gt;=</code> 在 list monad的情形下是怎么运作的，让我们先来回归基本。 <code>&gt;&gt;=</code> 基本上就是接受一个有context 的值，把他喂进一个只接受普通值的函数，并回传一个具有 context的值。如果操作的函数只会回传普通值而不是具有 context 的值，那 <code>&gt;&gt;=</code>
在操作一次后就会失效，因为 context 不见了。让我们来试着把一个
non-deterministic value 塞到一个函数中：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">5</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>x,<span style="color: #8787d7;">-</span>x<span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">5</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
当我们对 <code>Maybe</code> 使用 <code>&gt;&gt;=</code> ，是有考虑到可能失败的 context。在这边 <code>&gt;&gt;=</code> 则是有考虑到 non-determinism。 <code>[3,4,5]</code> 是一个 non-deterministic value，我们把他喂给一个回传 non-deterministic value 的函数。那结果也会是non-deterministic。而且他包含了所有从 <code>[3,4,5]</code> 取值，套用 <code>\x -&gt; [x,-x]</code> 后的结果。这个函数他接受一个数值并产生两个数值，一个原来的数值与取过负号的数值。当我们用 <code>&gt;&gt;=</code> 来把一个 list 喂给这个函数，所有在 list中的数值都保留了原有的跟取负号过的版本。
<code>x</code> 会针对 list中的每个元素走过一遍。
</p>

<p>
要看看结果是如何算出来的，只要看看实作就好了。首先我们从 <code>[3,4,5]</code> 开始。然后我们用 lambda 映射过所有元素得到：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">[</span><span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">4</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">5</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">5</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
lambda 会扫过每个元素，所以我们有一串包含一堆 list 的list，最后我们在把这些
list 压扁，得到一层的 list。这就是我们得到non-deterministic value 的过程。
</p>

<p>
non-determinism 也有考虑到失败的可能性。 <code>[]</code> 其实等价于 <code>Nothing</code> ，因为他什么结果也没有。所以失败等同于回传一个空的list。所有的错误消息都不用。让我们来看看范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"bad"</span>,<span style="color: #2aa198;">"mad"</span>,<span style="color: #2aa198;">"rad"</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2; font-weight: bold;">[]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">[]</span>
<span style="color: #268bd2; font-weight: bold;">[]</span>
</pre>
</div>

<p>
第一行里面，一个空的 list 被丢给 lambda。因为 list没有任何元素，所以函数收不到任何东西而产生空的 list。这跟把 <code>Nothing</code> 喂给函数一样。第二行中，每一个元素都被喂给函数，但所有元素都被丢掉，而只回传一个空的list。因为所有的元素都造成了失败，所以整个结果也代表失败。
</p>

<p>
就像 <code>Maybe</code> 一样，我们可以用 <code>&gt;&gt;=</code> 把他们串起来：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>n <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'b'</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>ch <span style="color: #8787d7;">-&gt;</span> return <span style="color: #268bd2;">(</span>n,ch<span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #2aa198;">'a'</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #2aa198;">'b'</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #2aa198;">'a'</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #2aa198;">'b'</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
</pre>
</div>


<div class="figure">
<p><img src="concatmap.png" alt="concatmap.png">
</p>
</div>

<p>
<code>[1,2]</code> 被绑定到 <code>n</code> 而 <code>['a','b']</code> 被绑定到 <code>ch</code> 。最后我们用 <code>return
   (n,ch)</code> 来把他放到一个最小的 context 中。在这个案例中，就是把 <code>(n,ch)</code> 放到
list 中，这代表最低程度的non-determinism。整套结构要表达的意思就是对于
<code>[1,2]</code> 的每个元素，以及 <code>['a','b']</code> 的每个元素，我们产生一个 tuple，每项分别取自不同的 list。
</p>

<p>
一般来说，由于 <code>return</code> 接受一个值并放到最小的 context中，他不会多做什么额外的东西仅仅是展示出结果而已。
</p>

<pre class="example">
当你要处理 non-deterministic value 的时候，你可以把 list 中的每个元素想做计算路线的一个 branch。
</pre>

<p>
这边把先前的表达式用 <code>do</code> 重写：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">listOfTuples</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>,<span style="color: #df005f; font-weight: bold;">Char</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">listOfTuples</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    n <span style="color: #8787d7;">&lt;-</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">]</span>
    ch <span style="color: #8787d7;">&lt;-</span> <span style="color: #268bd2;">[</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'b'</span><span style="color: #268bd2;">]</span>
    return <span style="color: #268bd2;">(</span>n,ch<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
这样写可以更清楚看到 <code>n</code> 走过 <code>[1,2]</code> 中的每一个值，而 <code>ch</code> 则取过
<code>['a','b']</code> 中的每个值。正如 <code>Maybe</code> 一般，我们从 monadic value中取出普通值然后喂给函数。 <code>&gt;&gt;=</code> 会帮我们处理好一切 context相关的问题，只差在这边的 context
指的是 non-determinism。
</p>

<p>
使用 <code>do</code> 来对 list操作让我们回想起之前看过的一些东西。来看看下列的片段：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span> <span style="color: #d75fd7;">(</span>n,ch<span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">|</span> n <span style="color: #8787d7;">&lt;-</span> <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">]</span>, ch <span style="color: #8787d7;">&lt;-</span> <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'b'</span><span style="color: #d75fd7;">]</span> <span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #2aa198;">'a'</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #2aa198;">'b'</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #2aa198;">'a'</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #2aa198;">'b'</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
没错，就是 list comprehension。在先前的范例中， <code>n</code> 会走过 <code>[1,2]</code> 的每个元素，而 <code>ch</code> 会走过 <code>['a','b']</code> 的每个元素。同时我们又把 <code>(n,ch)</code> 放进一个 context
中。这跟 list comprehension 的目的一样，只是我们在 list comprehension 里面不用在最后写一个 <code>return</code> 来得到 <code>(n,ch)</code> 的结果。
</p>

<p>
实际上，list comprehension 不过是一个语法糖。不论是 list comprehension或是用
<code>do</code> 表示法来表示，他都会转换成用 <code>&gt;&gt;=</code> 来做计算。
</p>

<p>
List comprehension 允许我们 filter我们的结果。举例来说，我们可以只要包含 <code>7</code>
在表示位数里面的数值。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span> x <span style="color: #8787d7;">|</span> x <span style="color: #8787d7;">&lt;-</span> <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">50</span><span style="color: #d75fd7;">]</span>, <span style="color: #2aa198;">'7'</span> <span style="color: #8787d7;">`elem`</span> show x <span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">7</span>,<span style="color: #d75fd7;">17</span>,<span style="color: #d75fd7;">27</span>,<span style="color: #d75fd7;">37</span>,<span style="color: #d75fd7;">47</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
我们用 <code>show</code> 跟 <code>x</code> 来把数值转成字串，然后检查 =​'7'​= 是否包含在字串里面。要看看 filtering 要如何转换成用 list monad来表达，我们可以考虑使用 <code>guard</code> 函数，还有 <code>MonadPlus</code> 这个 type class。 <code>MonadPlus</code> 这个 type class 是用来针对可以同时表现成 monoid 的monad。下面是他的定义：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">class</span> <span style="color: #df005f; font-weight: bold;">Monad</span> m <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">MonadPlus</span> m <span style="color: #268bd2; font-weight: bold;">where</span>
    mzero <span style="color: #8787d7;">::</span> m a
    mplus <span style="color: #8787d7;">::</span> m a <span style="color: #8787d7;">-&gt;</span> m a <span style="color: #8787d7;">-&gt;</span> m a
</pre>
</div>

<p>
<code>mzero</code> 是其实是 <code>Monoid</code> 中 <code>mempty</code> 的同义词，而 <code>mplus</code> 则对应到 <code>mappend</code>
。因为 list 同时是 monoid 跟 monad，他们可以是 <code>MonadPlus</code> 的instance。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">MonadPlus</span> <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    mzero <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">[]</span>
    mplus <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">++</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
对于 list 而言， <code>mzero</code> 代表的是不产生任何结果的 non-deterministic value，也就是失败的结果。而 <code>mplus</code> 则把两个 non-deterministic value结合成一个。
<code>guard</code> 这个函数被定义成下列形式：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">guard</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">MonadPlus</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">Bool</span> <span style="color: #8787d7;">-&gt;</span> m <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">guard</span> <span style="color: #df005f; font-weight: bold;">True</span> <span style="color: #8787d7;">=</span> return <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">guard</span> <span style="color: #df005f; font-weight: bold;">False</span> <span style="color: #8787d7;">=</span> mzero
</pre>
</div>

<p>
这函数接受一个布林值，如果他是 <code>True</code> 就回传一个包在缺省 context 中的 <code>()</code> 。如果他失败就产生 mzero。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> guard <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">5</span> <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2; font-weight: bold;">()</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> guard <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> guard <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">5</span> <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7; font-weight: bold;">()</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7; font-weight: bold;">()</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> guard <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7; font-weight: bold;">()</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2; font-weight: bold;">[]</span>
</pre>
</div>

<p>
看起来蛮有趣的，但用起来如何呢？我们可以用他来过滤 non-deterministic
的计算。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">50</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> guard <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">'7'</span> <span style="color: #8787d7;">`elem`</span> show x<span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">&gt;&gt;</span> return x<span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">7</span>,<span style="color: #d75fd7;">17</span>,<span style="color: #d75fd7;">27</span>,<span style="color: #d75fd7;">37</span>,<span style="color: #d75fd7;">47</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
这边的结果跟我们之前 list comprehension 的结果一致。究竟 <code>guard</code> 是如何办到的？我们先看看 <code>guard</code> 跟 <code>&gt;&gt;</code> 是如何交互：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> guard <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">5</span> <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;</span> return <span style="color: #2aa198;">"cool"</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #2aa198;">"cool"</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> guard <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;</span> return <span style="color: #2aa198;">"cool"</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2; font-weight: bold;">[]</span>
</pre>
</div>

<p>
如果 <code>guard</code> 成功的话，结果就会是一个空的 tuple。接着我们用 <code>&gt;&gt;</code> 来忽略掉空的
tuple，而呈现不同的结果。另一方面，如果 <code>guard</code> 失败的话，后面的 <code>return</code> 也会失败。这是因为用 <code>&gt;&gt;=</code> 把空的 list喂给函数总是会回传空的 list。基本上
<code>guard</code> 的意思就是：如果一个布林值是=False= 那就产生一个失败状态，不然的话就回传一个基本的 <code>()</code> 。这样计算就可以继续进行。
</p>

<p>
这边我们把先前的范例用 <code>do</code> 改写：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">sevensOnly</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">sevensOnly</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    x <span style="color: #8787d7;">&lt;-</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">50</span><span style="color: #268bd2;">]</span>
    guard <span style="color: #268bd2;">(</span><span style="color: #2aa198;">'7'</span> <span style="color: #8787d7;">`elem`</span> show x<span style="color: #268bd2;">)</span>
    return x
</pre>
</div>

<p>
如果我们不写最后一行 <code>return x</code> ，那整个 list 就会是包含一堆空 tuple 的list。
</p>

<p>
把上述范例写成 list comprehension 的话就会像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span> x <span style="color: #8787d7;">|</span> x <span style="color: #8787d7;">&lt;-</span> <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">50</span><span style="color: #d75fd7;">]</span>, <span style="color: #2aa198;">'7'</span> <span style="color: #8787d7;">`elem`</span> show x <span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">7</span>,<span style="color: #d75fd7;">17</span>,<span style="color: #d75fd7;">27</span>,<span style="color: #d75fd7;">37</span>,<span style="color: #d75fd7;">47</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
所以 list comprehension 的 filtering 基本上跟 <code>guard</code> 是一致的。
</p>
</div>

<div id="outline-container-org11d50cb" class="outline-4">
<h4 id="org11d50cb"><span class="section-number-4">1.5.1</span> A knight's quest</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
这边来看一个可以用 non-determinism解决的问题。假设你有一个西洋棋盘跟一只西洋棋中的骑士摆在上面。我们希望知道是否这只骑士可以在三步之内移到我们想要的位置。我们只要用一对数值来表示骑士在棋盘上的位置。第一个数值代表棋盘的行，而第二个数值代表棋盘的列。
</p>


<div class="figure">
<p><img src="chess.png" alt="chess.png">
</p>
</div>

<p>
我们先帮骑士的位置定义一个 type synonym。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>,<span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
假设骑士现在是在 <code>(6,2)</code> 。究竟他能不能够在三步内移动到 <code>(6,1)</code> 呢？你可能会先考虑究竟哪一步是最佳的一步。但不如全部一起考虑吧！要好好利用所谓的
non-determinism。所以我们不是只选择一步，而是选择全部。我们先写一个函数回传所有可能的下一步：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">moveKnight</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">KnightPos</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">moveKnight</span> <span style="color: #268bd2;">(</span>c,r<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2;">(</span>c',r'<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>
                ,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>
                <span style="color: #268bd2;">]</span>
    guard <span style="color: #268bd2;">(</span>c' <span style="color: #8787d7;">`elem`</span> <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">8</span><span style="color: #d75fd7;">]</span> <span style="color: #8787d7;">&amp;&amp;</span> r' <span style="color: #8787d7;">`elem`</span> <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">8</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
    return <span style="color: #268bd2;">(</span>c',r'<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
骑士有可能水平或垂直移动一步或二步，但问题是他们必须要同时水平跟垂直移动。
 <code>(c',r')</code> 走过 list 中的每一个元素，而 <code>guard</code> 会保证产生的结果会停留在棋盘上。如果没有，那就会产生一个空的list，表示失败的结果， <code>return (c',r')</code> 也就不会被执行。
</p>

<p>
这个函数也可以不用 list monad 来写，但我们这边只是写好玩的。下面是一个用
<code>filter</code> 实现的版本：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">moveKnight</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">KnightPos</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">moveKnight</span> <span style="color: #268bd2;">(</span>c,r<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> filter onBoard
    <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>
    ,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span>c<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span>,r<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>
    <span style="color: #268bd2;">]</span>
    <span style="color: #268bd2; font-weight: bold;">where</span> onBoard <span style="color: #268bd2;">(</span>c,r<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> c <span style="color: #8787d7;">`elem`</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">8</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&amp;&amp;</span> r <span style="color: #8787d7;">`elem`</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">8</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
两个函数做的都是相同的事，所以选个你喜欢的吧。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> moveKnight <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">6</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">7</span>,<span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> moveKnight <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">6</span>,<span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">7</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
我们接受一个位置然后产生所有可能的移动方式。所以我们有一个non-deterministic
的下一个位置。我们用 <code>&gt;&gt;=</code> 来喂给 <code>moveKnight</code> 。接下来我们就可以写一个三步内可以达到的所有位置：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">in3</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">KnightPos</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">in3</span> start <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    first <span style="color: #8787d7;">&lt;-</span> moveKnight start
    second <span style="color: #8787d7;">&lt;-</span> moveKnight first
    moveKnight second
</pre>
</div>

<p>
如果你传 <code>(6,2)</code> ，得到的 list会很大，因为会有不同种方式来走到同样的一个位置。我们也可以不用 <code>do</code> 来写：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">in3</span> start <span style="color: #8787d7;">=</span> return start <span style="color: #8787d7;">&gt;&gt;=</span> moveKnight <span style="color: #8787d7;">&gt;&gt;=</span> moveKnight <span style="color: #8787d7;">&gt;&gt;=</span> moveKnight
</pre>
</div>

<p>
第一次 <code>&gt;&gt;=</code> 给我们移动一步的所有结果，第二次 ~&gt;&gt;=~给我们移动两步的所有结果，第三次则给我们移动三步的所有结果。
</p>

<p>
用 <code>return</code> 来把一个值放进缺省的 context 然后用 <code>&gt;&gt;=</code> 喂给一个函数其实跟函数调用是同样的，只是用不同的写法而已。接着我们写一个函数接受两个位置，然后可以测试是否可以在三步内从一个位置移到另一个位置：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">canReachIn3</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Bool</span>
<span style="color: #d75fd7; font-weight: bold;">canReachIn3</span> start end <span style="color: #8787d7;">=</span> end <span style="color: #8787d7;">`elem`</span> in3 start
</pre>
</div>

<p>
我们产生所有三步的可能位置，然后看看其中一个位置是否在里面。所以我们可以看看是否可以在三步内从 <code>(6,2)</code> 走到 <code>(6,1)</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">6</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`canReachIn3`</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">6</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">True</span>
</pre>
</div>

<p>
那从 <code>(6,2)</code> 到 <code>(7,3)</code> 呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">6</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`canReachIn3`</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">7</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">False</span>
</pre>
</div>

<p>
答案是不行。你可以修改函数改成当可以走到的时候，他还会告诉你实际的步骤。之后你也可以改成不只限定成三步，可以任意步。
</p>
</div>
</div>
</div>

<div id="outline-container-org081905f" class="outline-3">
<h3 id="org081905f"><span class="section-number-3">1.6</span> Monad laws (单子律)</h3>
<div class="outline-text-3" id="text-1-6">

<div class="figure">
<p><img src="judgedog.png" alt="judgedog.png">
</p>
</div>

<p>
正如 applicative functors 以及 functors，Monad也有一些要遵守的定律。我们定义一个 <code>Monad</code> 的 instance 并不代表他是一个monad，只代表他被定义成那个 type
class 的 instance。一个型态要是monad，则必须遵守单子律。这些定律让我们可以对这个型态的行为做一些合理的假设。
</p>

<p>
Haskell 允许任何型态是任何 type class 的instance。但他不会检查单子律是否有被遵守，所以如果我们要写一个 <code>Monad</code> 的instance，那最好我们确定他有遵守单子律。我们可以不用担心标准函式库中的型态是否有遵守单子律。但之后我们定义自己的型态时，我们必须自己检查是否有遵守单子律。不用担心，他们不会很复杂。
</p>
</div>

<div id="outline-container-orgd58c04c" class="outline-4">
<h4 id="orgd58c04c"><span class="section-number-4">1.6.1</span> Left identity</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
单子律的第一项说当我们接受一个值，将他用 <code>return</code> 放进一个缺省的 context并把他用 <code>&gt;&gt;=</code> 喂进一个函数的结果，应该要跟我们直接做函数调用的结果一样。
</p>

<ul class="org-ul">
<li><code>retrun x &gt;&gt;= f</code> 应该等于 <code>f x</code></li>
</ul>

<p>
如果你是把 monadic value 视为把一个值放进最小的 context中，仅仅是把同样的值放进结果中的话，那这个定律应该很直觉。因为把这个值放进 context中然后丢给函数，应该要跟直接把这个值丢给函数做调用应该没有差别。
</p>

<p>
对于 <code>Maybe</code> monad， <code>return</code> 被定义成 <code>Just</code> 。 <code>Maybe</code> monad讲的是失败的可能性，如果我们有普通值要把他放进 context中，那把这个动作当作是计算成功应该是很合理的，毕竟我们都知道那个值是很具体的。这边有些范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">100000</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">100003</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">100000</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #d75fd7;">3</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">100003</span>
</pre>
</div>

<p>
对于 list monad 而言，=return= 是把值放进一个 list中，变成只有一个元素的
list。 <code>&gt;&gt;=</code> 则会走过 list中的每个元素，并把他们丢给函数做运算，但因为在单一元素的 list中只有一个值，所以跟直接对那元素做运算是等价的：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #2aa198;">"WoM"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">[</span>x,x,x<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #2aa198;">"WoM"</span>,<span style="color: #2aa198;">"WoM"</span>,<span style="color: #2aa198;">"WoM"</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">[</span>x,x,x<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span> <span style="color: #2aa198;">"WoM"</span>
<span style="color: #268bd2;">[</span><span style="color: #2aa198;">"WoM"</span>,<span style="color: #2aa198;">"WoM"</span>,<span style="color: #2aa198;">"WoM"</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
至于 <code>IO</code> ，我们已经知道 <code>return</code> 并不会造成副作用，只不过是在结果中呈现原有值。所以这个定律对于 <code>IO</code> 也是有效的。
</p>
</div>
</div>

<div id="outline-container-orgdab7a24" class="outline-4">
<h4 id="orgdab7a24"><span class="section-number-4">1.6.2</span> Right identity</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
单子律的第二个规则是如果我们有一个 monadic value，而且我们把他用 <code>&gt;&gt;=</code> 喂给
 <code>return</code> ，那结果就会是原有的 monadic value。
</p>

<ul class="org-ul">
<li><code>m &gt;&gt;= return</code> 会等于 <code>m</code></li>
</ul>

<p>
这一个可能不像第一定律那么明显，但我们还是来看看为什么会遵守这条。当我们把一个monadic value 用 <code>&gt;&gt;=</code> 喂给函数，那些函数是接受普通值并回传具有 context的值。=return= 也是在他们其中。如果你仔细看他的型态， <code>return</code> 是把一个普通值放进一个最小 context 中。这就表示，对于 <code>Maybe</code> 他并没有造成任何失败的状态，而对于 list 他也没有多加 non-determinism。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"move on up"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return x<span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #2aa198;">"move on up"</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return x<span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> putStrLn <span style="color: #2aa198;">"Wah!"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return x<span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Wah</span><span style="color: #d75fd7; font-weight: bold;">!</span>
</pre>
</div>

<p>
如果我们仔细查看 list monad 的范例，会发现 <code>&gt;&gt;=</code> 的实作是：
</p>

<div class="org-src-container">
<pre class="src src-haskell">xs <span style="color: #d75fd7; font-weight: bold;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> concat <span style="color: #268bd2;">(</span>map f xs<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
所以当我们将 <code>[1,2,3,4]</code> 丢给 <code>return</code> ，第一个 <code>return</code> 会把 <code>[1,2,3,4]</code> 映射成 <code>[[1],[2],[3],[4]]</code> ，然后再把这些小 list 串接成我们原有的 list。
</p>

<p>
Left identity 跟 right identity 是描述 <code>return</code> 的行为。他重要的原因是因为他把普通值转换成具有 context的值，如果他出错的话会很头大。
</p>
</div>
</div>

<div id="outline-container-org2005965" class="outline-4">
<h4 id="org2005965"><span class="section-number-4">1.6.3</span> Associativity</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
单子律最后一条是说当我们用 <code>&gt;&gt;=</code> 把一串 monadic function串在一起，他们的先后顺序不应该影响结果：
</p>

<ul class="org-ul">
<li><code>(m &gt;&gt;= f) &gt;&gt;= g</code> 跟 <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> 是相等的</li>
</ul>

<p>
究竟这边说的是什么呢？我们有一个 monadic value <code>m</code> ，以及两个 monadic
function <code>f</code> 跟 <code>g</code> 。当我们写下 <code>(m &gt;&gt;= f) &gt;&gt;= g</code> ，代表的是我们把 <code>m</code> 喂给
<code>f</code> ，他的结果是一个 monadic value。然后我们把这个结果喂给 <code>g</code> 。而在 <code>m &gt;&gt;=
    (\x -&gt; f x &gt;&gt;= g)</code> 中，我们接受一个 monadic value然后喂给一个函数，这个函数会把 <code>f x</code> 的结果丢给 <code>g</code> 。我们不太容易直接看出两者相同，所以先来看个范例比较好理解。
</p>

<p>
还记得之前皮尔斯的范例吗？要仿真鸟停在他的平衡竿上，我们把好几个函数串在一起
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">2</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
从 <code>Just (0,0)</code> 出发，然后把值传给 <code>landRight 2</code> 。他的结果又被绑到下一个
monadic function，以此类推。如果我们用括号清楚标出优先级的话会是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span>return <span style="color: #2aa198;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #2aa198;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landLeft <span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> landRight <span style="color: #d75fd7;">2</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们也可以改写成这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">return</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span>
<span style="color: #d75fd7; font-weight: bold;">landRight</span> <span style="color: #d75fd7;">2</span> x <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">\</span>y <span style="color: #8787d7;">-&gt;</span>
<span style="color: #d75fd7; font-weight: bold;">landLeft</span> <span style="color: #d75fd7;">2</span> y <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #2aa198;">(</span><span style="color: #8787d7;">\</span>z <span style="color: #8787d7;">-&gt;</span>
<span style="color: #d75fd7; font-weight: bold;">landRight</span> <span style="color: #d75fd7;">2</span> z<span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
<code>return (0,0)</code> 等价于 <code>Just (0,0)</code> ，当我们把他喂给 lambda，里面的 <code>x</code> 就等于 <code>(0,0)</code> 。 <code>landRight</code> 接受一个数值跟 pole，算出来的结果是 <code>Just (0,2)</code>
 然后把他喂给另一个 lambda，里面的 <code>y</code> 就变成了 <code>(0,2)</code> 。这样的操作持续下去，直到最后一只鸟降落，而得到 <code>Just (2,4)</code> 的结果，这也是整个操作的总结果。
</p>

<p>
这些 monadic function的优先级并不重要，重点是他们的意义。从另一个角度来看这个定律：考虑两个函数 <code>f</code> 跟 <code>g</code> ，将两个函数组合起来的定义像是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">.</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span>b <span style="color: #8787d7;">-&gt;</span> c<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> c<span style="color: #268bd2;">)</span>
f <span style="color: #d75fd7; font-weight: bold;">.</span> g <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> f <span style="color: #d75fd7;">(</span>g x<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
如果 <code>g</code> 的型态是 <code>a -&gt; b</code> 且 <code>f</code> 的型态是 <code>b -&gt; c</code> ，我们可以把他们合成一个型态是 <code>a -&gt; c</code> 的新函数。所以中间的参数都有自动带过。现在假设这两个函数是
monadic function，也就是说如果他们的回传值是 monadic function？如果我们有一个函数他的型态是 <code>a -&gt; m b</code> ，我们并不能直接把结果丢给另一个型态为 <code>b -&gt; m
    c</code> 的函数，因为后者只接受型态为 <code>b</code> 的普通值。然而，我们可以用 <code>&gt;&gt;=</code> 来做到我们想要的事。有了 <code>&gt;&gt;=</code> ，我们可以合成两个 monadic function：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">&lt;=&lt;</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>b <span style="color: #8787d7;">-&gt;</span> m c<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> m b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> m c<span style="color: #268bd2;">)</span>
f <span style="color: #d75fd7; font-weight: bold;">&lt;=&lt;</span> g <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> g x <span style="color: #8787d7;">&gt;&gt;=</span> f<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
所以现在我们可以合成两个 monadic functions：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> f x <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">[</span>x,<span style="color: #8787d7;">-</span>x<span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> g x <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">[</span>x<span style="color: #8787d7;">*</span><span style="color: #d75fd7;">3</span>,x<span style="color: #8787d7;">*</span><span style="color: #d75fd7;">2</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> h <span style="color: #8787d7;">=</span> f <span style="color: #8787d7;">&lt;=&lt;</span> g
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> h <span style="color: #d75fd7;">3</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">9</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">6</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">6</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
至于这跟结合律有什么关系呢？当我们把这定律看作是合成的定律，他就只是说了 <code>f
    &lt;=&lt; (g &lt;=&lt; h)</code> 跟 <code>(f &lt;=&lt; g) &lt;=&lt; h</code> 应该等价。只是他是针对 monad而已。
</p>

<p>
如果我们把头两个单子律用 <code>&lt;=&lt;</code> 改写，那 left identity 不过就是说对于每个
monadic function <code>f</code> ， <code>f &lt;=&lt; return</code> 跟 <code>f</code> 是等价，而 right identity 说
<code>return &lt;=&lt; f</code> 跟 <code>f</code> 是等价。
</p>

<p>
如果看看普通函数的情形，就会发现很像， <code>(f . g) . h</code> 等价于 <code>f . (g . h)</code> ，
<code>f . id</code> 跟 <code>f</code> 等价，且 <code>id . f</code> 等价于 <code>f</code> 。
</p>

<p>
在这一章中，我们查看了 monad 的基本性质，而且也了解了 <code>Maybe</code> monad 跟list
monad 的运作方式。在下一章，我们会看看其他一些有特色的monad，我们也会学到如何定义自己的 monad。
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: 刘向</p>
<p class="date">Created: 2019-12-13 五 22:04</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
