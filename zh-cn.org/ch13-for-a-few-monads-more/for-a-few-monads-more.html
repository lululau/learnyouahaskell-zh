<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-12-13 五 22:04 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>再来看看更多 Monad</title>
<meta name="generator" content="Org mode">
<meta name="author" content="刘向">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://assets.hackit.fun/style/org/spacemacs-wide/htmlize.css"/>
 <script src="http://assets.hackit.fun/js/org/spacemacs-wide/jquery.min.js"></script>
 <script src="http://assets.hackit.fun/js/org/spacemacs-wide/bootstrap.min.js"></script>
 <script src="http://assets.hackit.fun/js/org/spacemacs-wide/readtheorg.js"></script>
 <link rel="stylesheet" type="text/css" href="http://assets.hackit.fun/style/org/spacemacs-wide/readtheorg.css"/>
 <link rel="stylesheet" type="text/css" href="http://assets.hackit.fun/style/org/spacemacs-wide/font-awesome.min.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">再来看看更多 Monad</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3a4d4b1">1. 再来看看更多 Monad</a>
<ul>
<li><a href="#orgb4d50dd">1.1. 你所不知道的 Writer Monad</a>
<ul>
<li><a href="#orgde4a37b">1.1.1. Monoids 的好处</a></li>
<li><a href="#orga21ed34">1.1.2. The Writer type</a></li>
<li><a href="#org45262c8">1.1.3. Using do notation with Writer</a></li>
<li><a href="#org62bb0f6">1.1.4. Adding logging to programs</a></li>
<li><a href="#orgcb3c491">1.1.5. Inefficient list construction</a></li>
<li><a href="#org80a8ea9">1.1.6. Difference lists</a></li>
<li><a href="#org20a10b2">1.1.7. Comparing Performance</a></li>
</ul>
</li>
<li><a href="#orgf5c7e3c">1.2. Reader Monad</a></li>
<li><a href="#org134bbac">1.3. State Monad</a>
<ul>
<li><a href="#org901fdfb">1.3.1. Stack and Stones</a></li>
<li><a href="#orgc2437be">1.3.2. The State Monad</a></li>
<li><a href="#org0f45463">1.3.3. 随机性与 state monad</a></li>
</ul>
</li>
<li><a href="#org3a57f05">1.4. Error Monad</a></li>
<li><a href="#org0becc85">1.5. 一些实用的 Moandic functions</a>
<ul>
<li><a href="#orgeec09da">1.5.1. liftM</a></li>
<li><a href="#orgb26dcb8">1.5.2. The join function</a></li>
<li><a href="#orgbbc3c09">1.5.3. filterM</a></li>
<li><a href="#org173630c">1.5.4. foldM</a></li>
<li><a href="#org4ede65f">1.5.5. Making a safe RPN calculator</a></li>
<li><a href="#orgc919084">1.5.6. Composing monadic functions</a></li>
</ul>
</li>
<li><a href="#org7a99f45">1.6. 定义自己的 Monad</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org3a4d4b1" class="outline-2">
<h2 id="org3a4d4b1"><span class="section-number-2">1</span> 再来看看更多 Monad</h2>
<div class="outline-text-2" id="text-1">

<div class="figure">
<p><img src="clint.png" alt="clint.png">
</p>
</div>

<p>
我们已经看过 Monad 是如何接受具有 context 的值，并如何用函数操作他们还有如何用
<code>&gt;&gt;=</code> 跟 <code>do</code> 来减轻我们对 context 的关注，集中精神在 value本身。
</p>

<p>
我们也看过了 <code>Maybe</code> 是如何把值加上一个可能会失败的 context。我们学习到List
Monad 是如何加进多重结果的 context。我们也了解 <code>IO</code> Monad如何运作，而且我们在知道什么是 Monad 之前就已经知道他了。
</p>

<p>
在这个章节，我们会介绍一些其他的 Monad。他们可以把值变成 monadic value，因此可以让我们的程序更简洁清晰。多见识几个 Monad 也可以敏锐我们对Monad 的直觉。
</p>

<p>
我们即将要介绍的 Monad 都包含在 <code>mtl</code> 这个套建中。一个 Haskell package包含了一堆模块。而 <code>mtl</code> 已经包含在 Haskell Platform中，所以你可能不用另外安装。要检查你有没有这套件，你可以下 <code>ghc-pkg list</code> 。这会列出你已经安装的套件，其中应该包含 <code>mtl</code> 后面接着对应的版号。
</p>
</div>

<div id="outline-container-orgb4d50dd" class="outline-3">
<h3 id="orgb4d50dd"><span class="section-number-3">1.1</span> 你所不知道的 Writer Monad</h3>
<div class="outline-text-3" id="text-1-1">
<p>
我们已经看过 <code>Maybe</code>, list 以及 <code>IO</code> Monad。现在我们要来看看 <code>Writer</code> Monad。
</p>

<p>
相对于 <code>Maybe</code> 是加入可能失败的 context，list 是加入 non-deterministic的
context， <code>Writer</code> 则是加进一个附加值的 context，好比 log一般。 <code>Writer</code> 可以让我们在计算的同时搜集所有 log 纪录，并汇集成一个 log并附加在结果上。
</p>

<p>
例如我们想要附加一个 String 好说明我们的值在干么（有可能是为了除错）。想像有一个函数接受一个代表帮派人数的数字，然后会回传值告诉我们这是否算是一个庞大的帮派：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">isBigGang</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Bool</span>
<span style="color: #d75fd7; font-weight: bold;">isBigGang</span> x <span style="color: #8787d7;">=</span> x <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">9</span>
</pre>
</div>

<p>
现在我们希望他不只是回传 <code>True</code> 或 <code>False</code> ，我们还希望他能够多回传一个字串代表 log。这很容易，只要多加一个 <code>String</code> 在 <code>Bool</code> 旁边就好了。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">isBigGang</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Bool</span>, <span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">isBigGang</span> x <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">9</span>, <span style="color: #2aa198;">"Compared gang size to 9."</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们现在回传了一个 Tuple，第一个元素是原来的布林值，第二个元素是一个String。现在我们的值有了一个 context。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> isBigGang <span style="color: #d75fd7;">3</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #2aa198;">"Compared gang size to 9."</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> isBigGang <span style="color: #d75fd7;">30</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #2aa198;">"Compared gang size to 9."</span><span style="color: #268bd2;">)</span>
</pre>
</div>


<div class="figure">
<p><img src="tuco.png" alt="tuco.png">
</p>
</div>

<p>
到目前为止都还不错， <code>isBigGang</code> 回传一个值跟他的context。对于正常的数值来说这样的写法都能运作良好。但如果我们想要把一个已经具有context 的值，像是 <code>(3,
   "Smallish gang.")</code> ，喂给 <code>isBigGang</code> 呢？我们又面对了同样的问题：如果我们有一个能接受正常数值并回传一个具有context 值的 function，那我们要如何喂给他一个具有 context 的值？
</p>

<p>
当我们在研究 <code>Maybe</code> monad 的时候，我们写了一个 <code>applyMaybe</code> 。他接受一个
<code>Maybe a</code> 值跟一个 <code>a -&gt; Maybe b</code> 型态的函数，他会把 <code>Maybe a</code> 喂给这个
function，即便这个 function 其实是接受 <code>a</code> 而非 <code>Maybe a</code> 。 <code>applyMaybe</code> 有针对这样的 context 做处理，也就是会留意有可能发生的失败情况。但在 <code>a -&gt; Maybe
   b</code> 里面，我们可以只专心处理正常数值即可。因为 <code>applyMaybe</code> (之后变成了 <code>&gt;&gt;=</code>
)会帮我们处理需要检查 <code>Nothing</code> 或 <code>Just</code> 的情况。
</p>

<p>
我们再来写一个接受附加 log 值的函数，也就是 <code>(a, String)</code> 型态的值跟 <code>a -&gt;
   (b, String)</code> 型态的函数。我们称呼这个函数为 <code>applyLog</code> 。这个函数有的 context
是附加 log 值，而不是一个可能会失败的context，因此 <code>applyLog</code> 会确保原有的
log被保留，并附上从函数产生出的新的 log。这边我们来看一下实作：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">applyLog</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span>a,<span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>b,<span style="color: #df005f; font-weight: bold;">String</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>b,<span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">applyLog</span> <span style="color: #268bd2;">(</span>x,log<span style="color: #268bd2;">)</span> f <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>y,newLog<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> f x <span style="color: #268bd2; font-weight: bold;">in</span> <span style="color: #268bd2;">(</span>y,log <span style="color: #8787d7;">++</span> newLog<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
当我们想把一个具有 context 的值喂给一个函数的时候，我们会尝试把值跟他的
context 分开，然后把值喂给函数再重新接回 context。在 <code>Maybe</code> monad的情况，我们检查值是否为 <code>Just x</code> ，如果是，便将 <code>x</code> 喂给函数。而在 log的情况，我们知道
pair 的其中一个 component 是 log而另一个是值。所以我们先取出值 <code>x</code> ，将 <code>f</code>
apply 到 <code>x</code> ，便获取 <code>(y,newLog)</code> ，其中 <code>y</code> 是新的值而 <code>newLog</code> 则是新的
log。但如果我们回传 <code>newLog</code> ，旧的 log 便不会包含进去，所以我们要回传的是
<code>(y, log ++ newLog)</code> 。我们用 <code>++</code> 来把新的 log 接到旧的上面。
</p>

<p>
来看看 <code>applyLog</code> 运作的情形：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>, <span style="color: #2aa198;">"Smallish gang."</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> isBigGang
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #2aa198;">"Smallish gang.Compared gang size to 9"</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">30</span>, <span style="color: #2aa198;">"A freaking platoon."</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> isBigGang
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #2aa198;">"A freaking platoon.Compared gang size to 9"</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
跟之前的结果很像，只差在我们多了伴随产生的 log。再来多看几个例子：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Tobin"</span>,<span style="color: #2aa198;">"Got outlaw name."</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>length x, <span style="color: #2aa198;">"Applied length."</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #2aa198;">"Got outlaw name.Applied length."</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Bathcat"</span>,<span style="color: #2aa198;">"Got outlaw name."</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>length x, <span style="color: #2aa198;">"Applied length"</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">7</span>,<span style="color: #2aa198;">"Got outlaw name.Applied length"</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
可以看到在 lambda 里面 <code>x</code> 只是个正常的字串而不是 tuple，且 <code>applyLog</code> 帮我们处理掉附加 log 的动作。
</p>
</div>

<div id="outline-container-orgde4a37b" class="outline-4">
<h4 id="orgde4a37b"><span class="section-number-4">1.1.1</span> Monoids 的好处</h4>
<div class="outline-text-4" id="text-1-1-1">
<pre class="example">
请确定你了解什么是 Monoids。
</pre>

<p>
到目前为止 <code>applyLog</code> 接受 <code>(a,String)</code> 型态的值，但为什么 log 一定要是
 <code>String</code> 呢？我们使用 <code>++</code> 来附加新的 log，难道 <code>++</code> 并不能运作在任何形式的
 list，而一定要限制我们在 <code>String</code> 上呢？我们当然可以摆脱 <code>String</code> ，我们可以如下改变他的型态：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">applyLog</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span>a,<span style="color: #d75fd7;">[</span>c<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>b,<span style="color: #2aa198;">[</span>c<span style="color: #2aa198;">]</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>b,<span style="color: #d75fd7;">[</span>c<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们用一个 List 来代表 Log。包含在 List 中的元素型态必须跟原有的 List跟回传的 List 型态相同，否则我们没办法用 <code>++</code> 来把他们接起来。
</p>

<p>
这能够运作在 bytestring 上吗？绝对没问题。只是我们现在的型态只对 List有效。我们必须要另外做一个 bytestring 版本的 <code>applyLog</code> 。但我们注意到List 跟
bytestring 都是 monoids。因此他们都是 <code>Monoid</code> type class 的instance，那代表他们都有实作 <code>mappend</code> 。对 List 以及 bytestring而言， <code>mappend</code> 都是拿来串接的。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">`mappend`</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">6</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">6</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> B.pack <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">99</span>,<span style="color: #d75fd7;">104</span>,<span style="color: #d75fd7;">105</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">`mappend`</span> B.pack <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">104</span>,<span style="color: #d75fd7;">117</span>,<span style="color: #d75fd7;">97</span>,<span style="color: #d75fd7;">104</span>,<span style="color: #d75fd7;">117</span>,<span style="color: #d75fd7;">97</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"chi"</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"huahua"</span> <span style="color: #df005f; font-weight: bold;">Empty</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
修改后我们的 <code>applyLog</code> 可以运作在任何 monoid上。我们必须要修改型态宣告来表示这件事，同时也要在实作中把 <code>++</code> 改成 <code>mappend</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">applyLog</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monoid</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a,m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>b,m<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>b,m<span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">applyLog</span> <span style="color: #268bd2;">(</span>x,log<span style="color: #268bd2;">)</span> f <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>y,newLog<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> f x <span style="color: #268bd2; font-weight: bold;">in</span> <span style="color: #268bd2;">(</span>y,log <span style="color: #8787d7;">`mappend`</span> newLog<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
由于现在包含的值可以是任何 monoid，我们不再需要把 tuple想成包含一个值跟对应的 log，我们可以想成他包含一个值跟一个对应的monoid。举例来说，可以说我们有一个 tuple 包含一个产品名称跟一个符合monoid 特性的产品价格。我们可以定义一个
<code>Sum</code> 的 newtype来保证我们在操作产品的时候也会把价钱跟着加起来。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.Monoid</span>

<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Food</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Price</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #df005f; font-weight: bold;">Int</span>

<span style="color: #d75fd7; font-weight: bold;">addDrink</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Food</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Food</span>,<span style="color: #df005f; font-weight: bold;">Price</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">addDrink</span> <span style="color: #2aa198;">"beans"</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"milk"</span>, <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">25</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">addDrink</span> <span style="color: #2aa198;">"jerky"</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"whiskey"</span>, <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">99</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">addDrink</span> <span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"beer"</span>, <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">30</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们用 string 来代表食物，用 <code>newtype</code> 重新定义 <code>nInt</code> 为 <code>Sum</code> ，来追踪总共需要花多少钱。可以注意到我们用 <code>mappend</code> 来操作 <code>Sum</code> 的时候，价钱会被一起加起来。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">`mappend`</span> <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">9</span>
<span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #268bd2;">{</span>getSum <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">12</span><span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
 <code>addDrink</code> 的实作很简单，如果我们想吃豆子，他会回传 =​"milk"​= 以及伴随的
<code>Sum 25</code> ，同样的如果我们要吃 "jerky"，他就会回传"whiskey"，要吃其他东西的话，就会回传"beer"。乍看之下这个函数没什么特别，但如果用 <code>applyLog</code> 的话就会有趣些。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci <span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"beans"</span>, <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> addDrink
<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"milk"</span>,<span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">{</span>getSum <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">35</span><span style="color: #d75fd7;">}</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"jerky"</span>, <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">25</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> addDrink
<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"whiskey"</span>,<span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">{</span>getSum <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">124</span><span style="color: #d75fd7;">}</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"dogmeat"</span>, <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">5</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> addDrink
<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"beer"</span>,<span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">{</span>getSum <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">35</span><span style="color: #d75fd7;">}</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
牛奶价值 <code>25</code> 美分，但如果我们也吃了价值 <code>10</code> 美分的豆子的话，总共需要付
<code>35</code> 美分。这样很清楚地展示了伴随的值不一定需要是 log，他可以是任何monoid。至于两个值要如何结合，那要看 monoid 中怎么定义。当我们需要的是log 的时候，他们是串接，但这个 case 里面，数字是被加起来。
</p>

<p>
由于 <code>addDrink</code> 回传一个 <code>(Food,Price)</code> ，我们可以再把结果重新喂给
<code>addDrink</code> ，这可以很容易告诉我们总共喝了多少钱：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"dogmeat"</span>, <span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">5</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`applyLog`</span> addDrink <span style="color: #8787d7;">`applyLog`</span> addDrink
<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"beer"</span>,<span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">{</span>getSum <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">65</span><span style="color: #d75fd7;">}</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
将狗食跟 30 美分的啤酒加在一起会得到 <code>("beer", Sum 35)</code> 。如果我们用
 <code>applyLog</code> 将上面的结果再喂给 <code>addDrink</code> ，我们会得到 <code>("beer", Sum 65)</code> 这样的结果。
</p>
</div>
</div>

<div id="outline-container-orga21ed34" class="outline-4">
<h4 id="orga21ed34"><span class="section-number-4">1.1.2</span> The Writer type</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
我们认识了一个附加 monoid 的值其实表现出来的是一个monad，我们来再来看看其他类似的 <code>Monad</code> instance。 <code>Control.Monad.Writer</code> 这模块含有 <code>Writer w a</code> 的一个型态，里面定义了他 <code>Monad</code> 的instance，还有一些操作这些值的函数。
</p>

<p>
首先，我们来看一下型态。要把一个 monoid 附加给一个值，只需要定义一个tuple 就好了。 <code>Writer w a</code> 这型态其实是一个 <code>newtype</code> wrapper。他的定义很简单：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">newtype</span> <span style="color: #df005f; font-weight: bold;">Writer</span> w a <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">{</span> runWriter <span style="color: #8787d7;">::</span> <span style="color: #d75fd7;">(</span>a, w<span style="color: #d75fd7;">)</span> <span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
他包在一个 <code>newtype</code> 里面，并且可以是一个 <code>Monad</code> 的instance，而且这样定义的好处是可以跟单纯 tuple 的型态区分开来。 <code>a</code> 这个型态参数代表是包含的值的型态，而 <code>w</code> 则是附加的 monoid 的型态。
</p>

<p>
他 <code>Monad</code> instance 的定义如下：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monoid</span> w<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">Monad</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Writer</span> w<span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    return x <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span>x, mempty<span style="color: #268bd2;">)</span>
    <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #d75fd7;">(</span>x,v<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #d75fd7;">(</span>y, v'<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> f x <span style="color: #268bd2; font-weight: bold;">in</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span>y, v <span style="color: #8787d7;">`mappend`</span> v'<span style="color: #268bd2;">)</span>
</pre>
</div>


<div class="figure">
<p><img src="angeleyes.png" alt="angeleyes.png">
</p>
</div>

<p>
首先，我们来看看 <code>&gt;&gt;=</code> 。他的实作基本上就是 <code>applyLog</code> ，只是我们的 tuple现在是包在一个 <code>Writer</code> 的 <code>newtype</code> 中，我们可以用 pattern matching的方式把他给
unwrap。我们将 <code>x</code> 喂给 <code>f</code> 。这会回给我们 <code>Writer w a</code> 。接着可以用 <code>let</code>
expression 来做 pattern matching。把结果绑定到 <code>y</code> 这个名字上，然后用
<code>mappend</code> 来结合旧的monoid 值跟新的 monoid 值。最后把结果跟 monoid 值用
<code>Writer</code> constructor包起来，形成我们最后的 <code>Writer</code> value。
</p>

<p>
那 <code>return</code> 呢？回想 <code>return</code> 的作用是接受一个值，并回传一个具有意义的最小
context来装我们的值。那究竟什么样的 context 可以代表我们的 <code>Writer</code> 呢？如果我们希望 monoid 值所造成的影响愈小愈好，那 <code>mempty</code> 是个合理的选择。
<code>mempty</code> 是被当作 identity monoid value，像是 =""= 或 <code>Sum 0</code> ，或是空的
bytestring。当我们对 <code>mempty</code> 用 <code>mappend</code> 跟其他monoid 值结合，结果会是其他的 monoid 值。所以如果我们用 <code>return</code> 来做一个 <code>Writer</code> ，然后用 <code>&gt;&gt;=</code> 来喂给其他的函数，那函数回传的便是算出来的 monoid。下面我们试着用 <code>return</code> 搭配不同 context 来回传 <code>3</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter <span style="color: #268bd2;">(</span>return <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #2aa198;">""</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter <span style="color: #268bd2;">(</span>return <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #d75fd7;">)</span> <span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #df005f; font-weight: bold;">Sum</span> <span style="color: #d75fd7;">{</span>getSum <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">0</span><span style="color: #d75fd7;">}</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter <span style="color: #268bd2;">(</span>return <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Product</span> <span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #d75fd7;">)</span> <span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #df005f; font-weight: bold;">Product</span> <span style="color: #d75fd7;">{</span>getProduct <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">}</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
因为 <code>Writer</code> 并没有定义成 <code>Show</code> 的 instance，我们必须用 <code>runWriter</code> 来把我们的 <code>Writer</code> 转成正常的 tuple。对于 <code>String</code> ，monoid的值就是空字串。而对于
<code>Sum</code> 来说则是 <code>0</code> ，因为 <code>0</code> 加上其他任何值都会是对方。而对 <code>Product</code> 来说，则是 <code>1</code> 。
</p>

<p>
这里的 <code>Writer</code> instance 并没有定义 <code>fail</code> ，所以如果 pattern matching失败的话，就会调用 <code>error</code> 。
</p>
</div>
</div>

<div id="outline-container-org45262c8" class="outline-4">
<h4 id="org45262c8"><span class="section-number-4">1.1.3</span> Using do notation with Writer</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
既然我们定义了 <code>Monad</code> 的 instance，我们自然可以用 <code>do</code> 串接 <code>Writer</code> 型态的值。这在我们需要对一群 <code>Writer</code> 型态的值做处理时显得特别方便。就如其他的
monad，我们可以把他们当作具有context 的值。在现在这个 case 中，所有的 monoid
的值都会用 <code>mappend</code> 来连接起来并得到最后的结果。这边有一个简单的范例，我们用 <code>Writer</code> 来相乘两个数。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.Writer</span>

<span style="color: #d75fd7; font-weight: bold;">logNumber</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">logNumber</span> x <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span>x, <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">"Got number: "</span> <span style="color: #8787d7;">++</span> show x<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">multWithLog</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">multWithLog</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    a <span style="color: #8787d7;">&lt;-</span> logNumber <span style="color: #d75fd7;">3</span>
    b <span style="color: #8787d7;">&lt;-</span> logNumber <span style="color: #d75fd7;">5</span>
    return <span style="color: #268bd2;">(</span>a<span style="color: #8787d7;">*</span>b<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
 <code>logNumber</code> 接受一个数并把这个数做成一个 <code>Writer</code> 。我们再用一串 string来当作我们的 monoid 值，每一个数都跟着一个只有一个元素的list，说明我们只有一个数。
<code>multWithLog</code> 式一个 <code>Writer</code> ，他将 <code>3</code> 跟 <code>5</code> 相乘并确保相乘的纪录有写进最后的 log 中。我们用 <code>return</code> 来做成 <code>a*b</code> 的结果。我们知道 <code>return</code> 会接受某个值并加上某个最小的context，我们可以确定他不会多添加额外的 log。如果我们执行程序会得到：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter multWithLog
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">15</span>,<span style="color: #d75fd7;">[</span><span style="color: #2aa198;">"Got number: 3"</span>,<span style="color: #2aa198;">"Got number: 5"</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
有时候我们就是想要在某个时间点放进某个 Monoid value。 <code>tell</code> 正是我们需要的函数。他实作了 <code>MonadWriter</code> 这个 type class，而且在当 <code>Writer</code> 用的时候也能接受一个 monoid value，好比说 <code>["This is going on"]</code> 。我们能用他来把我们的
monoid value 接到任何一个dummy value <code>()</code> 上来形成一个 Writer。当我们拿到的结果是 <code>()</code> 的时候，我们不会把他绑定到变量上。来看一个 <code>multWithLog</code> 的范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">multWithLog</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">multWithLog</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    a <span style="color: #8787d7;">&lt;-</span> logNumber <span style="color: #d75fd7;">3</span>
    b <span style="color: #8787d7;">&lt;-</span> logNumber <span style="color: #d75fd7;">5</span>
    tell <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"Gonna multiply these two"</span><span style="color: #268bd2;">]</span>
    return <span style="color: #268bd2;">(</span>a<span style="color: #8787d7;">*</span>b<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
 <code>return (a*b)</code> 是我们的最后一行，还记得在一个 <code>do</code> 中的最后一行代表整个
<code>do</code> 的结果。如果我们把 <code>tell</code> 摆到最后，则 <code>do</code> 的结果则会是 <code>()</code> 。我们会因此丢掉乘法运算的结果。除此之外，log 的结果是不变的。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter multWithLog
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">15</span>,<span style="color: #d75fd7;">[</span><span style="color: #2aa198;">"Got number: 3"</span>,<span style="color: #2aa198;">"Got number: 5"</span>,<span style="color: #2aa198;">"Gonna multiply these two"</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org62bb0f6" class="outline-4">
<h4 id="org62bb0f6"><span class="section-number-4">1.1.4</span> Adding logging to programs</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
欧几里得算法是找出两个数的最大公因数。Haskell 已经提供了 <code>gcd</code> 的函数，但我们来实作一个具有 log 功能的 gcd：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">gcd'</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">gcd'</span> a b
    <span style="color: #8787d7;">|</span> b <span style="color: #8787d7;">==</span> <span style="color: #d75fd7;">0</span>    <span style="color: #8787d7;">=</span> a
    <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> gcd' b <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">`mod`</span> b<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
算法的内容很简单。首先他检查第二个数字是否为零。如果是零，那就回传第一个数字。如果不是，那结果就是第二个数字跟将第一个数字除以第二个数字的余数两个数字的最大公因数。举例来说，如果我们想知道8 跟 3 的最大公因数，首先可以注意到 3 不是
0。所以我们要求的是 3 跟 2的最大公因数(8 除以 3 余二)。接下去我可以看到 2 不是 0，所以我们要再找 2跟 1 的最大公因数。同样的，第二个数不是 0，所以我们再找 1 跟 0的最大公因数。最后第二个数终于是 0 了，所以我们得到最大公因数是 1。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> gcd' <span style="color: #d75fd7;">8</span> <span style="color: #d75fd7;">3</span>
<span style="color: #d75fd7;">1</span>
</pre>
</div>

<p>
答案真的是这样。接着我们想加进 context，context 会是一个 monoid value并且像是一个 log 一样。就像之前的范例，我们用一串 string 来当作我们的monoid。所以
<code>gcd'​</code> 会长成这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">gcd'</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Int</span>
</pre>
</div>

<p>
而他的代码会像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.Writer</span>

<span style="color: #d75fd7; font-weight: bold;">gcd'</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">gcd'</span> a b
  <span style="color: #8787d7;">|</span> b <span style="color: #8787d7;">==</span> <span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
      tell <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"Finished with "</span> <span style="color: #8787d7;">++</span> show a<span style="color: #268bd2;">]</span>
      return a
  <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
      tell <span style="color: #268bd2;">[</span>show a <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" mod "</span> <span style="color: #8787d7;">++</span> show b <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" = "</span> <span style="color: #8787d7;">++</span> show <span style="color: #d75fd7;">(</span>a <span style="color: #8787d7;">`mod`</span> b<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
      gcd' b <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">`mod`</span> b<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
这个函数接受两个 <code>Int</code> 并回传一个 <code>Writer [String] Int</code> ，也就是说是一个有
log context 的 <code>Int</code> 。当 <code>b</code> 等于 <code>0</code> 的时候，我们用一个 <code>do</code> 来组成一个
<code>Writer</code> 的值。我们先用 <code>tell</code> 来写入我们的 log，然后用 <code>return</code> 来当作 <code>do</code>
的结果。当然我们也可以这样写：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span>a, <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">"Finished with "</span> <span style="color: #8787d7;">++</span> show a<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
但我想 <code>do</code> 的表达方式是比较容易阅读的。接下来我们看看当 <code>b</code> 不等于 <code>0</code> 的时候。我们会把 <code>mod</code> 的使用情况写进 log。然后在 <code>do</code> 当中的第二行递归调用
<code>gcd'​</code> 。 <code>gcd'​</code> 现在是回传一个 <code>Writer</code> 的型态，所以 <code>gcd' b (a `mod` b)</code>
这样的写法是完全没问题的。
</p>

<p>
尽管去 trace 这个 <code>gcd'​</code> 对于理解十分有帮助，但我想了解整个大概念，把值视为具有 context是更加有用的。
</p>

<p>
接着来试试跑我们的 <code>gcd'​</code> ，他的结果会是 <code>Writer [String] Int</code> ，如果我们把他从 <code>newtype</code> 中取出来，我们会拿到一个tuple。tuple 的第一个部份就是我们要的结果：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> fst <span style="color: #8787d7;">$</span> runWriter <span style="color: #268bd2;">(</span>gcd' <span style="color: #d75fd7;">8</span> <span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7;">1</span>
</pre>
</div>

<p>
至于 log 呢，由于 log 是一连串 string，我们就用 <code>mapM_ putStrLn</code> 来把这些
string 印出来：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM_ putStrLn <span style="color: #8787d7;">$</span> snd <span style="color: #8787d7;">$</span> runWriter <span style="color: #268bd2;">(</span>gcd' <span style="color: #d75fd7;">8</span> <span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7;">8</span> mod <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">3</span> mod <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">2</span> mod <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">0</span>
<span style="color: #df005f; font-weight: bold;">Finished</span> with <span style="color: #d75fd7;">1</span>
</pre>
</div>

<p>
把普通的算法转换成具有 log 是很棒的经验，我们不过是把普通的 value 重写成
Monadic value，剩下的就靠 <code>&gt;&gt;=</code> 跟 <code>Writer</code> 来帮我们处理一切。用这样的方法我们几乎可以对任何函数加上 logging的功能。我们只要把普通的值换成 <code>Writer</code> ，然后把一般的函数调用换成 <code>&gt;&gt;=</code> (当然也可以用 <code>do</code>)
</p>
</div>
</div>

<div id="outline-container-orgcb3c491" class="outline-4">
<h4 id="orgcb3c491"><span class="section-number-4">1.1.5</span> Inefficient list construction</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
当制作 <code>Writer</code> Monad 的时候，要特别注意你是使用哪种 monoid。使用 list的话性能有时候是没办法接受的。因为 list 是使用 <code>++</code> 来作为 <code>mappend</code> 的实现。而
<code>++</code> 在 list 很长的时候是非常慢的。
</p>

<p>
在之前的 <code>gcd'​</code> 中，log 并不会慢是因为 list append的动作实际上看起来是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell">a <span style="color: #d75fd7; font-weight: bold;">++</span> <span style="color: #268bd2;">(</span>b <span style="color: #8787d7;">++</span> <span style="color: #d75fd7;">(</span>c <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">(</span>d <span style="color: #8787d7;">++</span> <span style="color: #67b11d;">(</span>e <span style="color: #8787d7;">++</span> f<span style="color: #67b11d;">)</span><span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
list 是建立的方向是从左到右，当我们先建立左边的部份，而把另一串 list加到右边的时候性能会不错。但如果我们不小心使用，而让 <code>Writer</code> monad实际在操作 list
的时候变成像这样的话。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span><span style="color: #2aa198;">(</span><span style="color: #67b11d;">(</span>a <span style="color: #8787d7;">++</span> b<span style="color: #67b11d;">)</span> <span style="color: #8787d7;">++</span> c<span style="color: #2aa198;">)</span> <span style="color: #8787d7;">++</span> d<span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">++</span> e<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">++</span> f
</pre>
</div>

<p>
这会让我们的操作是 left associative，而不是 right associative。这非常没有效率，因为每次都是把右边的部份加到左边的部份，而左边的部份又必须要从头开始建起。
</p>

<p>
下面这个函数跟 <code>gcd'​</code> 差不多，只是 log的顺序是相反的。他先纪录剩下的操作，然后纪录现在的步骤。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.Writer</span>

<span style="color: #d75fd7; font-weight: bold;">gcdReverse</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">gcdReverse</span> a b
  <span style="color: #8787d7;">|</span> b <span style="color: #8787d7;">==</span> <span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
      tell <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"Finished with "</span> <span style="color: #8787d7;">++</span> show a<span style="color: #268bd2;">]</span>
      return a
    <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
      result <span style="color: #8787d7;">&lt;-</span> gcdReverse b <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">`mod`</span> b<span style="color: #268bd2;">)</span>
      tell <span style="color: #268bd2;">[</span>show a <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" mod "</span> <span style="color: #8787d7;">++</span> show b <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" = "</span> <span style="color: #8787d7;">++</span> show <span style="color: #d75fd7;">(</span>a <span style="color: #8787d7;">`mod`</span> b<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
      return result
</pre>
</div>

<p>
他先递归调用，然后把结果绑定到 <code>result</code> 。然后把目前的动作写到log，在递归的结果之后。最后呈现的就是完整的 log。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM_ putStrLn <span style="color: #8787d7;">$</span> snd <span style="color: #8787d7;">$</span> runWriter <span style="color: #268bd2;">(</span>gcdReverse <span style="color: #d75fd7;">8</span> <span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Finished</span> with <span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">2</span> mod <span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">0</span>
<span style="color: #d75fd7;">3</span> mod <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">8</span> mod <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">2</span>
</pre>
</div>

<p>
这没效率是因为他让 <code>++</code> 成为 left associative 而不是 right associative。
</p>
</div>
</div>

<div id="outline-container-org80a8ea9" class="outline-4">
<h4 id="org80a8ea9"><span class="section-number-4">1.1.6</span> Difference lists</h4>
<div class="outline-text-4" id="text-1-1-6">

<div class="figure">
<p><img src="cactus.png" alt="cactus.png">
</p>
</div>

<p>
由于 list 在重复 append 的时候显得低效，我们最好能使用一种支持高效appending
的数据结构。其中一种就是 difference list。difference list很类似 list，只是他是一个函数。他接受一个 list 并 prepend 另一串 list到他前面。一个等价于
<code>[1,2,3]</code> 的 difference list 是这样一个函数 <code>\xs -&gt; [1,2,3] \++ xs</code> 。一个等价于 <code>[]</code> 的 difference list 则是 <code>\xs -&gt; [] ++ xs</code> 。
</p>

<p>
Difference list 最酷的地方在于他支持高效的 appending。当我们用 <code>++</code> 来实现
appending 的时候，他必须要走到左边的 list 的尾端，然后把右边的list 一个个从这边接上。那 difference list 是怎么作的呢？appending 两个difference list 就像这样
</p>

<div class="org-src-container">
<pre class="src src-haskell">f <span style="color: #8787d7;">`</span><span style="color: #d75fd7; font-weight: bold;">append</span><span style="color: #8787d7;">`</span> g <span style="color: #8787d7;">=</span> <span style="color: #8787d7;">\</span>xs <span style="color: #8787d7;">-&gt;</span> f <span style="color: #268bd2;">(</span>g xs<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
 <code>f</code> 跟 <code>g</code> 这边是两个函数，他们都接受一个 list 并 prepend 另一串list。举例来说，如果 <code>f</code> 代表 <code>("dog"\++)</code> （可以写成 <code>\xs -&gt; "dog" \++ xs</code> ）而 <code>g</code>
是 <code>("meat"++)</code> ，那 <code>f `append` g</code> 就会做成一个新的函数，等价于：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">\</span>xs <span style="color: #8787d7;">-&gt;</span> <span style="color: #2aa198;">"dog"</span> <span style="color: #8787d7;">++</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"meat"</span> <span style="color: #8787d7;">++</span> xs<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
append 两个 difference list 其实就是用一个函数，这函数先喂一个 list给第一个
difference list，然后再把结果喂给第二个 difference list。
</p>

<p>
我们可以用一个 <code>newtype</code> 来包起来
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">newtype</span> <span style="color: #df005f; font-weight: bold;">DiffList</span> a <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">DiffList</span> <span style="color: #268bd2;">{</span> getDiffList <span style="color: #8787d7;">::</span> <span style="color: #d75fd7;">[</span>a<span style="color: #d75fd7;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">[</span>a<span style="color: #d75fd7;">]</span> <span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
我们包起来的型态是 <code>[a] -&gt; [a]</code> ，因为 difference list不过就是一个转换一个
list 到另一个 list 的函数。要把普通 list 转换成difference list 也很容易。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">toDiffList</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">DiffList</span> a
<span style="color: #d75fd7; font-weight: bold;">toDiffList</span> xs <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">DiffList</span> <span style="color: #268bd2;">(</span>xs<span style="color: #8787d7;">++</span><span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">fromDiffList</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">DiffList</span> a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">fromDiffList</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">DiffList</span> f<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> f <span style="color: #268bd2; font-weight: bold;">[]</span>
</pre>
</div>

<p>
要把一个普通 list 转成 difference list 不过就是照之前定义的，作一个prepend
另一个 list 的函数。由于 difference list 只是一个 prepend 另一串list 的一个函数，假如我们要转回来的话，只要喂给他空的 list 就行了。
</p>

<p>
这边我们给一个 difference list 的 <code>Monoid</code> 定义
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">Monoid</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">DiffList</span> a<span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    mempty <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">DiffList</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>xs <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7; font-weight: bold;">[]</span> <span style="color: #8787d7;">++</span> xs<span style="color: #268bd2;">)</span>
    <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">DiffList</span> f<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`mappend`</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">DiffList</span> g<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">DiffList</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>xs <span style="color: #8787d7;">-&gt;</span> f <span style="color: #d75fd7;">(</span>g xs<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们可以看到 <code>mempty</code> 不过就是 <code>id=，而 =mappend</code> 其实是 function
composition。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> fromDiffList <span style="color: #268bd2;">(</span>toDiffList <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">]</span> <span style="color: #8787d7;">`mappend`</span> toDiffList <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
现在我们可以用 difference list 来加速我们的 <code>gcdReverse</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.Writer</span>

<span style="color: #d75fd7; font-weight: bold;">gcd'</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">DiffList</span> <span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">)</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">gcd'</span> a b
  <span style="color: #8787d7;">|</span> b <span style="color: #8787d7;">==</span> <span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
      tell <span style="color: #268bd2;">(</span>toDiffList <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">"Finished with "</span> <span style="color: #8787d7;">++</span> show a<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
      return a
  <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
      result <span style="color: #8787d7;">&lt;-</span> gcd' b <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">`mod`</span> b<span style="color: #268bd2;">)</span>
      tell <span style="color: #268bd2;">(</span>toDiffList <span style="color: #d75fd7;">[</span>show a <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" mod "</span> <span style="color: #8787d7;">++</span> show b <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" = "</span> <span style="color: #8787d7;">++</span> show <span style="color: #2aa198;">(</span>a <span style="color: #8787d7;">`mod`</span> b<span style="color: #2aa198;">)</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
      return result
</pre>
</div>

<p>
我们只要把 monoid 的型态从 <code>[String]</code> 改成 <code>DiffList String</code> ，并在使用
<code>tell</code> 的时候把普通的 list 用 <code>toDiffList</code> 转成 difference list就可以了。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM_ putStrLn <span style="color: #8787d7;">.</span> fromDiffList <span style="color: #8787d7;">.</span> snd <span style="color: #8787d7;">.</span> runWriter <span style="color: #8787d7;">$</span> gcdReverse <span style="color: #d75fd7;">110</span> <span style="color: #d75fd7;">34</span>
<span style="color: #df005f; font-weight: bold;">Finished</span> with <span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">8</span> mod <span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">0</span>
<span style="color: #d75fd7;">34</span> mod <span style="color: #d75fd7;">8</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">110</span> mod <span style="color: #d75fd7;">34</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">8</span>
</pre>
</div>

<p>
我们用 <code>runWriter</code> 来取出 <code>gcdReverse 110 34</code> 的结果，然后用 <code>snd</code> 取出log，并用 <code>fromDiffList</code> 转回普通的 list 印出来。
</p>
</div>
</div>

<div id="outline-container-org20a10b2" class="outline-4">
<h4 id="org20a10b2"><span class="section-number-4">1.1.7</span> Comparing Performance</h4>
<div class="outline-text-4" id="text-1-1-7">
<p>
要体会 Difference List 能如何增进效率，考虑一个从某数数到零的case。我们纪录的时候就像 <code>gcdReverse</code> 一样是反过来记的，所以在 log中实际上是从零数到某个数。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">finalCountDown</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">DiffList</span> <span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">finalCountDown</span> <span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    tell <span style="color: #268bd2;">(</span>toDiffList <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">"0"</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">finalCountDown</span> x <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    finalCountDown <span style="color: #268bd2;">(</span>x<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
    tell <span style="color: #268bd2;">(</span>toDiffList <span style="color: #d75fd7;">[</span>show x<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
如果我们喂 <code>0</code> ，他就只 log 0。如果喂其他正整数，他会先倒数到 <code>0</code> 然后append
那些数到 log 中，所以如果我们调用 <code>finalCountDown</code> 并喂给他 <code>100</code> ，那 log
的最后一笔就会是 =​"100"​= 。
</p>

<p>
如果你把这个函数 load 进 GHCi 中并喂给他一个比较大的整数 <code>500000</code> ，你会看到他无停滞地从 <code>0</code> 开始数起：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM_ putStrLn <span style="color: #8787d7;">.</span> fromDiffList <span style="color: #8787d7;">.</span> snd <span style="color: #8787d7;">.</span> runWriter <span style="color: #8787d7;">$</span> finalCountDown <span style="color: #d75fd7;">500000</span>
<span style="color: #d75fd7;">0</span>
<span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">2</span>
</pre>
</div>

<p>
但如果我们用普通的 list 而不用 difference list
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">finalCountDown</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">finalCountDown</span> <span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    tell <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"0"</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">finalCountDown</span> x <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    finalCountDown <span style="color: #268bd2;">(</span>x<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
    tell <span style="color: #268bd2;">[</span>show x<span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
并下同样的指令
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM_ putStrLn <span style="color: #8787d7;">.</span> snd <span style="color: #8787d7;">.</span> runWriter <span style="color: #8787d7;">$</span> finalCountDown <span style="color: #d75fd7;">500000</span>
</pre>
</div>

<p>
我们会看到整个运算卡卡的。
</p>

<p>
当然这不是一个严谨的测试方法，但足以表显出 difference list是比较有效率的写法。
</p>
</div>
</div>
</div>

<div id="outline-container-orgf5c7e3c" class="outline-3">
<h3 id="orgf5c7e3c"><span class="section-number-3">1.2</span> Reader Monad</h3>
<div class="outline-text-3" id="text-1-2">

<div class="figure">
<p><img src="revolver.png" alt="revolver.png">
</p>
</div>

<p>
在讲 Applicative 的章节中，我们说过了 <code>(-&gt;) r</code> 的型态只是 <code>Functor</code> 的一个
instance。要将一个函数 <code>f</code> map over 一个函数 <code>g</code> ，基本上等价于一个函数，他可以接受原本 <code>g</code> 接受的参数，先套用 <code>g</code> 然后再把其结果丢给 <code>f</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> f <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">5</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> g <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span>fmap f g<span style="color: #268bd2;">)</span> <span style="color: #d75fd7;">8</span>
</pre>
</div>

<p>
我们已经见识过函数当作 applicative functors的例子。这样能让我们对函数的结果直接进行操作。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> f <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> f <span style="color: #d75fd7;">3</span>
<span style="color: #d75fd7;">19</span>
</pre>
</div>

<p>
 <code>(+) &lt;$&gt; (*2) &lt;*&gt; (+10)</code> 代表一个函数，他接受一个数值，分别把这数值交给
<code>(*2)</code> 跟 <code>(\+10)</code> 。然后把结果加起来。例如说，如果我们喂 <code>3</code> 给这个函数，他会分别对 <code>3</code> 做 <code>(*2)</code> 跟 <code>(\+10)</code> 的动作。而得到 <code>6</code> 跟 <code>13</code> 。然后调用
<code>(+)</code> ，而得到 <code>19</code> 。
</p>

<p>
其实 <code>(-&gt;) r</code> 不只是一个 functor 跟一个 applicative functor，他也是一个monad。就如其他 monadic value 一般，一个函数也可以被想做是包含一个context 的。这个
context是说我们期待某个值，他还没出现，但我们知道我们会把他当作函数的参数，调用函数来得到结果。
</p>

<p>
我们已经见识到函数是怎样可以看作 functor 或是 applicative functors了。再来让我们看看当作 <code>Monad</code> 的一个 instance 时会是什么样子。你可以在
<code>Control.Monad.Instances</code> 里面找到，他看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">Monad</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">(</span><span style="color: #df005f; font-weight: bold;">-&gt;</span><span style="color: #d75fd7; font-weight: bold;">)</span> r<span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    return x <span style="color: #8787d7;">=</span> <span style="color: #8787d7;">\</span><span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">-&gt;</span> x
    h <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> <span style="color: #8787d7;">\</span>w <span style="color: #8787d7;">-&gt;</span> f <span style="color: #268bd2;">(</span>h w<span style="color: #268bd2;">)</span> w
</pre>
</div>

<p>
我们之前已经看过函数的 <code>pure</code> 实作了，而 <code>return</code> 差不多就是 <code>pure</code> 。他接受一个值并把他放进一个 minimal context里面。而要让一个函数能够是某个定值的唯一方法就是让他完全忽略他的参数。
</p>

<p>
而 <code>&gt;&gt;=</code> 的实作看起来有点难以理解，我们可以仔细来看看。当我们使用 <code>&gt;&gt;=</code> 的时候，喂进去的是一个 monadic value，处理他的是一个函数，而吐出来的也是一个
monadic value。在这个情况下，当我们将一个函数喂进一个函数，吐出来的也是一个函数。这就是为什么我们在最外层使用了一个lambda。在我们目前看过的实作中， <code>&gt;&gt;=</code>
几乎都是用 lambda将内部跟外部隔开来，然后在内部来使用 <code>f</code> 。这边也是一样的道理。要从一个函数得到一个结果，我们必须喂给他一些东西，这也是为什么我们先用
<code>(h w)</code> 取得结果，然后将他丢给 <code>f</code> 。而 <code>f</code> 回传一个 monadic value，在这边这个 monadic value 也就是一个函数。我们再把 <code>w</code> 喂给他。
</p>

<p>
如果你还不太懂 <code>&gt;&gt;=</code> 怎么写出来的，不要担心，因为接下来的范例会让你晓得这真的是一个简单的Monad。我们造一个 <code>do</code> expression 来使用这个 Monad。
</p>

<pre class="example">
import Control.Monad.Instances

addStuff :: Int -&gt; Int
addStuff = do
  a &lt;- (*2)
  b &lt;- (+10)
  return (a+b)
</pre>

<p>
这跟我们之前写的 applicative expression 差不多，只差在他是运作在 monad上。一个 <code>do</code> expression 的结果永远会是一个 monadic vlaue，这个也不例外。而这个
monadic value其实是一个函数。只是在这边他接受一个数字，然后套用 <code>(*2)</code> ，把结果绑定到 <code>a</code> 上面。而 <code>(+10)</code> 也同用被套用到同样的参数。结果被绑定到 <code>b</code> 上。
<code>return</code> 就如其他 monad 一样，只是制作一个简单的 monadic value而不会作多余的事情。这让整个函数的结果是 <code>a+b</code> 。如果我们试着跑跑看，会得到之前的结果。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> addStuff <span style="color: #d75fd7;">3</span>
<span style="color: #d75fd7;">19</span>
</pre>
</div>

<p>
其中 <code>3</code> 会被喂给 <code>(*2)</code> 跟 <code>(+10)</code> 。而且他也会被喂给 <code>return (a+b)</code> ，只是他会忽略掉 <code>3</code> 而永远回传 <code>a+b</code> 正因为如此，function monad 也被称作 reader
monad。所有函数都从一个固定的地方读取。要写得更清楚一些，可以把 <code>addStuff</code> 改写如下：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">addStuff</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">addStuff</span> x <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">let</span>
    a <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">2</span><span style="color: #268bd2;">)</span> x
    b <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span> x
    <span style="color: #268bd2; font-weight: bold;">in</span> a<span style="color: #8787d7;">+</span>b
</pre>
</div>

<p>
我们见识了把函数视作具有 context 的值很自然的可以表达成 reader monad。只要我们当作我们知道函数会回传什么值就好。他作的就是把所有的函数都黏在一起做成一个大的函数，然后把这个函数的参数都喂给全部组成的函数，这有点取出他们未来的值的意味。实作做完了然后 <code>&gt;&gt;=</code> 就会保证一切都能正常运作。
</p>
</div>
</div>

<div id="outline-container-org134bbac" class="outline-3">
<h3 id="org134bbac"><span class="section-number-3">1.3</span> State Monad</h3>
<div class="outline-text-3" id="text-1-3">

<div class="figure">
<p><img src="texas.png" alt="texas.png">
</p>
</div>

<p>
Haskell是一个纯粹的语言，正因为如此，我们的程序是有一堆没办法改变全域状态或变量的函数所组成，他们只会作些处理并回传结果。这样的性质让我们很容易思考我们的程序在干嘛，因为我们不需要担心变量在某一个时间点的值是什么。然而，有一些领域的问题根本上就是依赖于随着时间而改变的状态。虽然我们也可以用Haskell 写出这样的程序，但有时候写起来蛮痛苦的。这也是为什么 Haskell要加进 State Monad 这个特性。这让我们在 Haskell中可以容易地处理状态性的问题，并让其他部份的程序还是保持纯粹性。
</p>

<p>
当我们处理乱数的时候，我们的函数接受一个 random generator并回传一个新的乱数跟一个新的 random generator。如果我们需要很多个乱数，我们可以用前一个函数回传的
random generator 继续做下去。当我们要写一个接受 <code>StdGen</code> 的函数并产生丢三个硬币结果的函数，我们会这样写：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">threeCoins</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">StdGen</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Bool</span>, <span style="color: #df005f; font-weight: bold;">Bool</span>, <span style="color: #df005f; font-weight: bold;">Bool</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">threeCoins</span> gen <span style="color: #8787d7;">=</span>
    <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>firstCoin, newGen<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random gen
        <span style="color: #268bd2;">(</span>secondCoin, newGen'<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random newGen
        <span style="color: #268bd2;">(</span>thirdCoin, newGen'''<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random newGen'
    <span style="color: #268bd2; font-weight: bold;">in</span>  <span style="color: #268bd2;">(</span>firstCoin, secondCoin, thirdCoin<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
他接受一个 <code>gen</code> 然后用 <code>random gen</code> 产生一个 <code>Bool</code> 型态的值以及新的
generator。要仿真丢第二个硬币的话，便使用新的generator。在其他语言中，多半除了乱数之外不需要多回传一个generator。那是因为我们可以对现有的进行修改。但
Haskell是纯粹的语言，我们没办法那么做，所以我们必须要接受一个状态，产生结果然后回传一个新的状态，然后用新的状态来继续做下去。
</p>

<p>
一般来讲你应该不会喜欢这么写，在程序中有赤裸裸的状态，但我们又不想放弃Haskell
的纯粹性质。这就是 State Monad的好处了，他可以帮我们处理这些琐碎的事情，又让我们保持 Haskell的纯粹性。
</p>

<p>
为了深入理解状态性的计算，我们先来看看应该给他们什么样的型态。我们会说一个状态性的计算是一个函数，他接受一个状态，回传一个值跟一个新的状态。写起来会像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell">s <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a,s<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
<code>s</code> 是状态的型态，而 <code>a</code> 是计算结果的型态。
</p>

<pre class="example">
在其他的语言中，赋值大多是被当作会改变状态的操作。举例来说，当我们在命令式
语言写 `x = 5`， 这通常代表的是把 `5` 指定给 `x` 这变量。而且这边
`5` 是一个 expression。 如果你用函数语言的角度去思考，你可以把他想做是一
个函数，接受一个状态，并回传结果跟新的状态。那新的状态代表所有已指定的值与
新加入的变量。
</pre>

<p>
这种改变状态的计算，除了想做是一个接受状态并回传结果跟新状态的函数外，也可以想做是具有context 的值。实际的值是结果。然而要得到结果，我们必须要给一个初始的状态，才能得到结果跟最后的状态。
</p>
</div>

<div id="outline-container-org901fdfb" class="outline-4">
<h4 id="org901fdfb"><span class="section-number-4">1.3.1</span> Stack and Stones</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
考虑现在我们要对一个堆叠的操作建立模型。你可以把东西推上堆叠顶端，或是把东西从顶端拿下来。如果你要的元素是在堆叠的底层的话，你必须要把他上面的东西都拿下来才能拿到他。
</p>

<p>
我们用一个 list 来代表我们的堆叠。而我们把 list的头当作堆叠的顶端。为了正确的建立模型，我们要写两个函数： <code>pop</code> 跟 <code>push</code> 。 <code>pop</code> 会接受一个堆叠，取下一个元素并回传一个新的堆叠，这个新的堆叠不包含取下的元素。 <code>push</code> 会接受一个元素，把他堆到堆叠中，并回传一个新的堆叠，其包含这个新的元素。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #268bd2;">]</span>

<span style="color: #d75fd7; font-weight: bold;">pop</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>,<span style="color: #df005f; font-weight: bold;">Stack</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">pop</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span>x,xs<span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">push</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #df005f; font-weight: bold;">Stack</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">push</span> a xs <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">()</span>,a<span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们用 <code>()</code> 来当作 pushing的结果，毕竟推上堆叠并不需要什么回传值，他的重点是在改变堆叠。注意到 <code>push</code> 跟 <code>pop</code> 都是改变状态的计算，可以从他们的型态看出来。
</p>

<p>
我们来写一段程序来仿真一个堆叠的操作。我们接受一个堆叠，把 <code>3</code> 推上去，然后取出两个元素。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">stackManip</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>, <span style="color: #df005f; font-weight: bold;">Stack</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">stackManip</span> stack <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">let</span>
    <span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">()</span>,newStack1<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> push <span style="color: #d75fd7;">3</span> stack
    <span style="color: #268bd2;">(</span>a ,newStack2<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> pop newStack1
    <span style="color: #268bd2; font-weight: bold;">in</span> pop newStack2
</pre>
</div>

<p>
我们拿一个 <code>stack</code> 来作 <code>push 3 stack</code> 的动作，其结果是一个 tuple。tuple的第一个部份是 <code>()</code> ，而第二个部份是新的堆叠，我们把他命名成 <code>newStack1</code> 。然后我们从 <code>newStack1</code> 上 pop 出一个数字。其结果是我们之前push 上去的一个数字
<code>a</code> ，然后把这个更新的堆叠叫做 <code>newStack2</code> 。然后我们从 <code>newStack2</code> 上再 pop
出一个数字 <code>b</code> ，并得到 <code>newStack3</code> 。我们回传一个 tuple 跟最终的堆叠。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> stackManip <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
结果就是 <code>5</code> 跟新的堆叠 <code>[8,2,1]</code> 。注意到 <code>stackManip</code> 是一个会改变状态的操作。我们把一堆会改变状态的操作绑在一起操作，有没有觉得很耳熟的感觉。
</p>

<p>
<code>stackManip</code> 的程序有点冗长，因为我们要写得太详细，必须把状态给每个操作，然后把新的状态再喂给下一个。如果我们可以不要这样作的话，那程序应该会长得像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">stackManip</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    push <span style="color: #d75fd7;">3</span>
    a <span style="color: #8787d7;">&lt;-</span> pop
    pop
</pre>
</div>

<p>
这就是 State Monad在做的事。有了他，我们便可以免除于要把状态操作写得太明白的窘境。
</p>
</div>
</div>

<div id="outline-container-orgc2437be" class="outline-4">
<h4 id="orgc2437be"><span class="section-number-4">1.3.2</span> The State Monad</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
<code>Control.Monad.State</code> 这个模块提供了一个 <code>newtype</code> 包起来的型态。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">newtype</span> <span style="color: #df005f; font-weight: bold;">State</span> s a <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #268bd2;">{</span> runState <span style="color: #8787d7;">::</span> s <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>a,s<span style="color: #d75fd7;">)</span> <span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
一个 <code>State s a</code> 代表的是一个改变状态的操作，他操纵的状态为型态 <code>s</code> ，而产生的结果是 <code>a</code> 。
</p>

<p>
我们已经见识过什么是改变状态的操作，以及他们是可以被看成具有 context的值。接着来看看他们 <code>Monad</code> 的 instance：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">Monad</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">State</span> s<span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    return x <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #8787d7;">$</span> <span style="color: #8787d7;">\</span>s <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>x,s<span style="color: #268bd2;">)</span>
    <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">State</span> h<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #8787d7;">$</span> <span style="color: #8787d7;">\</span>s <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>a, newState<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> h s
                                        <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">State</span> g<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> f a
                                    <span style="color: #268bd2; font-weight: bold;">in</span>  g newState
</pre>
</div>

<p>
我们先来看看 <code>return</code> 那一行。我们 <code>return</code> 要作的事是接受一个值，并做出一个改变状态的操作，让他永远回传那个值。所以我们才做了一个lambda 函数， <code>\s -&gt;
    (x,s)</code> 。我们把 <code>x</code> 当成是结果，并且状态仍然是 <code>s</code> 。这就是 <code>return</code> 要完成的 minimal context。
</p>


<div class="figure">
<p><img src="badge.png" alt="badge.png">
</p>
</div>

<p>
那 <code>&gt;&gt;=</code> 的实作呢？很明显的把改变状态的操作喂进 <code>&gt;&gt;=</code> 也必须要丢出另一个改变状态的操作。所以我们用 <code>State</code> 这个 <code>newtype</code> wrapper 来把一个 lambda 函数包住。这个 lambda会是新的一个改变状态的操作。但里面的内容是什么？首先我们应该要从接受的操作取出结果。由于lambda 是在一个大的操作中，所以我们可以喂给 <code>h</code>
我们现在的状态，也就是 <code>s</code> 。那会产生 <code>(a, newState)</code> 。到目前为止每次我们在实作 <code>&gt;&gt;=</code> 的时候，我们都会先从 monadic value 中取出结果，然后喂给 <code>f</code> 来得到新的monadic value。在写 <code>Writer</code> 的时候，我们除了这样作还要确保 context 是用 <code>mappend</code> 把旧的 monoid value 跟新的接起来。在这边我们则是用 <code>f a</code> 得到一个新的操作 <code>g</code> 。现在我们有了新的操作跟新的状态（叫做 <code>newState</code> ），我们就把 <code>newState</code> 喂给 <code>g</code> 。结果便是一个tuple，里面包含了最后的结果跟最终的状态。
</p>

<p>
有了 <code>&gt;&gt;=</code> ，我们便可以把两个操作黏在一起，只是第二个被放在一个函数中，专门接受第一个的结果。由于=pop= 跟 <code>push</code> 已经是改变状态的操作了，我们可以把他们包在 <code>State</code> 中
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.State</span>

<span style="color: #d75fd7; font-weight: bold;">pop</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">pop</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #8787d7;">$</span> <span style="color: #8787d7;">\</span><span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>x,xs<span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">push</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">push</span> a <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #8787d7;">$</span> <span style="color: #8787d7;">\</span>xs <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">()</span>,a<span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
  <code>pop</code> 已经满足我们的条件，而 <code>push</code> 要先接受一个 <code>Int</code> 才会回传我们要的操作。所以我们可以改写先前的范例如下：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.State</span>

<span style="color: #d75fd7; font-weight: bold;">stackManip</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">stackManip</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
  push <span style="color: #d75fd7;">3</span>
  a <span style="color: #8787d7;">&lt;-</span> pop
  pop
</pre>
</div>

<p>
看到我们是怎么把一个 <code>push</code> 跟两个 <code>pop</code> 黏成一个操作吗？当我们将他们从一个
  <code>newtype</code> 取出，其实就是需要一个能喂进初始状态的函数：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runState stackManip <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们不须绑定第二个 <code>pop</code> ，因为我们根本不会用到 <code>a</code> ，所以可以写成下面的样子：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">stackManip</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">stackManip</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    push <span style="color: #d75fd7;">3</span>
    pop
    pop
</pre>
</div>

<p>
再来尝试另外一种方式，先从堆叠上取下一个数字，看看他是不是 <code>5</code> ，如果是的话就把他放回堆叠上，如果不是的话就堆上 <code>3</code> 跟 <code>8</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">stackStuff</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">stackStuff</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    a <span style="color: #8787d7;">&lt;-</span> pop
    <span style="color: #268bd2; font-weight: bold;">if</span> a <span style="color: #8787d7;">==</span> <span style="color: #d75fd7;">5</span>
        <span style="color: #268bd2; font-weight: bold;">then</span> push <span style="color: #d75fd7;">5</span>
        <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">do</span>
            push <span style="color: #d75fd7;">3</span>
            push <span style="color: #d75fd7;">8</span>
</pre>
</div>

<p>
很直觉吧！我们来看看初始的堆叠的样子。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runState stackStuff <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">0</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
还记得我们说过 <code>do</code> 的结果会是一个 monadic value，而在 <code>State</code> monad 的case，
  <code>do</code> 也就是一个改变状态的函数。而由于 <code>stackManip</code> 跟 <code>stackStuff</code> 都是改变状态的计算，因此我们可以把他们黏在一起：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">moreStack</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">moreStack</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    a <span style="color: #8787d7;">&lt;-</span> stackManip
    <span style="color: #268bd2; font-weight: bold;">if</span> a <span style="color: #8787d7;">==</span> <span style="color: #d75fd7;">100</span>
        <span style="color: #268bd2; font-weight: bold;">then</span> stackStuff
        <span style="color: #268bd2; font-weight: bold;">else</span> return <span style="color: #268bd2; font-weight: bold;">()</span>
</pre>
</div>

<p>
如果 <code>stackManip</code> 的结果是 <code>100</code> ，我们就会跑 <code>stackStuff</code> ，如果不是的话就什么都不做。 <code>return ()</code> 不过就是什么是都不做，全部保持原样。
</p>

<p>
  <code>Contorl.Monad.State</code> 提供了一个 <code>MonadState</code> 的typeclass，他有两个有用的函数，分别是 <code>get</code> 跟 <code>put</code> 。对于 <code>State</code> 来说， <code>get</code> 的实作就像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">get</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #8787d7;">$</span> <span style="color: #8787d7;">\</span>s <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>s,s<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
他只是取出现在的状态除此之外什么也不做。而 <code>put</code> 函数会接受一个状态并取代掉现有的状态。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">put</span> newState <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #8787d7;">$</span> <span style="color: #8787d7;">\</span>s <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">()</span>,newState<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
有了这两个状态，我们便可以看到现在堆叠中有什么，或是把整个堆叠中的元素换掉。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">stackyStack</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">Stack</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">stackyStack</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    stackNow <span style="color: #8787d7;">&lt;-</span> get
    <span style="color: #268bd2; font-weight: bold;">if</span> stackNow <span style="color: #8787d7;">==</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
        <span style="color: #268bd2; font-weight: bold;">then</span> put <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
        <span style="color: #268bd2; font-weight: bold;">else</span> put <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
我们可以看看对于 <code>State</code> 而言， <code>&gt;&gt;=</code> 的型态会是什么：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">&gt;&gt;=</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> s a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">State</span> s b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">State</span> s b
</pre>
</div>

<p>
我们可以看到状态的型态都是 <code>s</code> ，而结果从型态 <code>a</code> 变成型态 <code>b</code> 。这代表我们可以把好几个改变状态的计算黏在一起，这些计算的结果可以都不一样，但状态的型态会是一样的。举例来说，对于 <code>Maybe</code> 而言， <code>&gt;&gt;=</code> 的型态会是：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">&gt;&gt;=</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> b
</pre>
</div>

<p>
<code>Maybe</code> 不变是有道理的，但如果用 <code>&gt;&gt;=</code> 来把两种不同的 monad接起来是没道理的。但对于 state monad 而言，monad 其实是 <code>State s</code> ，所以如果 <code>s</code> 不一样，我们就要用 <code>&gt;&gt;=</code> 来把两个 monad 接起来。
</p>
</div>
</div>

<div id="outline-container-org0f45463" class="outline-4">
<h4 id="org0f45463"><span class="section-number-4">1.3.3</span> 随机性与 state monad</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
在章节的一开始，我们知道了在 Haskell中要产生乱数的不方便。我们要拿一个产生器，并回传一个乱数跟一个新的产生器。接下来我们还一定要用新的产生器不可。但State
Monad 让我们可以方便一些。
</p>

<p>
<code>System.Random</code> 中的 <code>random</code> 函数有下列的型态：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">random</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">RandomGen</span> g, <span style="color: #df005f; font-weight: bold;">Random</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> g <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span>a, g<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
代表他接受一个乱数产生器，并产生一个乱数跟一个新的产生器。很明显他是一个会改变状态的计算，所以我们可以用=newtype= 把他包在一个 <code>State</code> 中，然后把他当作
monadic value 来操作。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.State</span>

<span style="color: #d75fd7; font-weight: bold;">randomSt</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">RandomGen</span> g, <span style="color: #df005f; font-weight: bold;">Random</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">State</span> g a
<span style="color: #d75fd7; font-weight: bold;">randomSt</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">State</span> random
</pre>
</div>

<p>
这样我们要丢三个硬币的结果可以改写成这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad.State</span>

<span style="color: #d75fd7; font-weight: bold;">threeCoins</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #df005f; font-weight: bold;">StdGen</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Bool</span>,<span style="color: #df005f; font-weight: bold;">Bool</span>,<span style="color: #df005f; font-weight: bold;">Bool</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">threeCoins</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
  a <span style="color: #8787d7;">&lt;-</span> randomSt
  b <span style="color: #8787d7;">&lt;-</span> randomSt
  c <span style="color: #8787d7;">&lt;-</span> randomSt
  return <span style="color: #268bd2;">(</span>a,b,c<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
<code>threeCoins</code> 是一个改变状态的计算，他接受一个初始的乱数产生器，他会把他喂给 <code>randomSt</code> ，他会产生一个数字跟一个新的产生器，然后会一直传递下去。我们用 <code>return (a,b,c)</code> 来呈现 <code>(a,b,c)</code> ，这样并不会改变最近一个产生器的状态。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runState threeCoins <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">33</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #df005f; font-weight: bold;">True</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">680029187</span> <span style="color: #d75fd7;">2103410263</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
要完成像这样要改变状态的任务便因此变得轻松了很多。
</p>
</div>
</div>
</div>

<div id="outline-container-org3a57f05" class="outline-3">
<h3 id="org3a57f05"><span class="section-number-3">1.4</span> Error Monad</h3>
<div class="outline-text-3" id="text-1-4">
<p>
我们知道 <code>Maybe</code> 是拿来赋予一个值具有可能失败的 context。一个值可能会是 <code>Just
   something</code> 或是一个 <code>Nothing</code> 。尽管这很有用，但当我们拿到了一个 <code>Nothing</code> ，我们只知道他失败了，但我们没办法塞进一些有用的信息，告诉我们究竟是在什么样的情况下失败了。
</p>

<p>
而 <code>Either e a</code> 则能让我们可以加入一个可能会发生错误的context，还可以增加些有用的消息，这样能让我们知道究竟是什么东西出错了。一个 <code>Either e a</code> 的值可以是代表正确的 <code>Right</code> ，或是代表错误的 <code>Left</code> ，例如说：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">:</span>t <span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">4</span>
<span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Num</span> t<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">Either</span> a t
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">:</span>t <span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"out of cheese error"</span>
<span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"out of cheese error"</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Either</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Char</span><span style="color: #268bd2;">]</span> b
</pre>
</div>

<p>
这就像是加强版的 <code>Maybe</code> ，他看起来实在很像一个monad，毕竟他也可以当作是一个可能会发生错误的context，只是多了些消息罢了。
</p>

<p>
在 <code>Control.Monad.Error</code> 里面有他的 <code>Monad</code> instance。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Error</span> e<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">Monad</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Either</span> e<span style="color: #268bd2;">)</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    return x <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Right</span> x
    <span style="color: #df005f; font-weight: bold;">Right</span> x <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> f x
    <span style="color: #df005f; font-weight: bold;">Left</span> err <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Left</span> err
    fail msg <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #268bd2;">(</span>strMsg msg<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
  <code>return</code> 就是建立起一个最小的 context，由于我们用 <code>Right</code> 代表正确的结果，所以他把值包在一个 <code>Right</code> constructor 里面。就像实作 <code>Maybe</code> 时的 <code>return</code>
一样。
</p>

<p>
<code>&gt;&gt;=</code> 会检查两种可能的情况：也就是 <code>Left</code> 跟 <code>Right</code> 。如果进来的是 <code>Right</code>
，那我们就调用 <code>f</code> ，就像我们在写 <code>Just</code> 的时候一样，只是调用对应的函数。而在错误的情况下， <code>Left</code> 会被传出来，而且里面保有描述失败的值。
</p>

<p>
  <code>Either e</code> 的 <code>Monad</code> instance 有一项额外的要求，就是包在 <code>Left</code> 中的型态，也就是 <code>e</code> ，必须是 <code>Error</code> typeclass 的 instance。 <code>Error</code> 这个typeclass 描述一个可以被当作错误消息的型态。他定义了 <code>strMsg</code> 这个函数，他接受一个用字串表达的错误。一个明显的范例就是 <code>String</code> 型态，当他是 <code>String</code> 的时候，
<code>strMsg</code> 只不过回传他接受到的字串。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">:</span>t strMsg
<span style="color: #d75fd7; font-weight: bold;">strMsg</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Error</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> a
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> strMsg <span style="color: #2aa198;">"boom!"</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #2aa198;">"boom!"</span>
</pre>
</div>

<p>
但因为我们通常在用 <code>Either</code> 来描述错误的时候，是用 <code>String</code> 来装错误消息，所以我们也不用担心这一点。当在 <code>do</code> 里面做 pattern match失败的时候， <code>Left</code> 的值会拿来代表失败。
</p>

<p>
总之来看看一个范例吧：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"boom"</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #268bd2;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"boom"</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">100</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"no way!"</span>
<span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"no way!"</span>
</pre>
</div>

<p>
当我们用 <code>&gt;&gt;=</code> 来把一个 <code>Left</code> 喂进一个函数，函数的运算会被忽略而直接回传丢进去的 <code>Left</code> 值。当我们喂 <code>Right</code> 值给函数，函数就会被计算而得到结果，但函数还是产生了一个 <code>Left</code> 值。
</p>

<p>
当我们试着喂一个 <code>Right</code> 值给函数，而且函数也成功地计算，我们却碰到了一个奇怪的 type error。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">+</span> <span style="color: #d75fd7;">100</span><span style="color: #268bd2;">)</span>

<span style="color: #8787d7;">&lt;</span>interactive<span style="color: #8787d7;">&gt;:</span><span style="color: #d75fd7;">1</span><span style="color: #df005f; font-weight: bold;">:</span><span style="color: #d75fd7;">0</span><span style="color: #df005f; font-weight: bold;">:</span>
  <span style="color: #df005f; font-weight: bold;">Ambiguous</span> <span style="color: #268bd2; font-weight: bold;">type</span> variable `a' <span style="color: #268bd2; font-weight: bold;">in</span> the constraints<span style="color: #df005f; font-weight: bold;">:</span>
    `<span style="color: #df005f; font-weight: bold;">Error</span> a' arising from a use <span style="color: #268bd2; font-weight: bold;">of</span> `it' at <span style="color: #8787d7;">&lt;</span>interactive<span style="color: #8787d7;">&gt;:</span><span style="color: #d75fd7;">1</span><span style="color: #df005f; font-weight: bold;">:</span><span style="color: #d75fd7;">0</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">33</span>
    `<span style="color: #df005f; font-weight: bold;">Show</span> a' arising from a use <span style="color: #268bd2; font-weight: bold;">of</span> `print' at <span style="color: #8787d7;">&lt;</span>interactive<span style="color: #8787d7;">&gt;:</span><span style="color: #d75fd7;">1</span><span style="color: #df005f; font-weight: bold;">:</span><span style="color: #d75fd7;">0</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">33</span>
  <span style="color: #df005f; font-weight: bold;">Probable</span> fix<span style="color: #df005f; font-weight: bold;">:</span> add a <span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #268bd2; font-weight: bold;">signature</span> that fixes these <span style="color: #268bd2; font-weight: bold;">type</span> variable<span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
Haskell 警告说他不知道要为 <code>e</code> 选择什么样的型态，尽管我们是要印出 <code>Right</code> 的值。这是因为 <code>Error e</code> 被限制成 <code>Monad</code> 。把 <code>Either</code> 当作Monad 使用就会碰到这样的错误，你只要明确写出 type signature 就行了：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">+</span> <span style="color: #d75fd7;">100</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Either</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">103</span>
</pre>
</div>

<p>
这样就没问题了。
</p>

<p>
撇除这个小毛病，把 <code>Either</code> 当 Monad 使用就像使用 <code>Maybe</code> 一样。在前一章中，我们展示了 <code>Maybe</code> 的使用方式。你可以把前一章的范例用 <code>Either</code> 重写当作练习。
</p>
</div>
</div>

<div id="outline-container-org0becc85" class="outline-3">
<h3 id="org0becc85"><span class="section-number-3">1.5</span> 一些实用的 Moandic functions</h3>
<div class="outline-text-3" id="text-1-5">
<p>
在这个章节，我们会看看一些操作 monadic value的函数。这样的函数通常我们称呼他们为 monadic function。其中有些你是第一次见到，但有些不过是 <code>filter</code> 或
<code>foldl</code> 的变形。让我们来看看吧！
</p>
</div>

<div id="outline-container-orgeec09da" class="outline-4">
<h4 id="orgeec09da"><span class="section-number-4">1.5.1</span> liftM</h4>
<div class="outline-text-4" id="text-1-5-1">

<div class="figure">
<p><img src="wolf.png" alt="wolf.png">
</p>
</div>

<p>
当我们开始学习 Monad 的时候，我们是先学习 functors，他代表可以被 map over 的事物。接着我们学了 functors 的加强版，也就是 applicative functors，他可以对
applicative values做函数的套用，也可以把一个一般值放到一个缺省的 context中。最后，我们介绍在 applicative functors 上更进一步的monad，他让这些具有
context 的值可以被喂进一般函数中。
</p>

<p>
也就是说每一个 monad 都是个 applicative functor，而每一个 applicative
functor 也都是一个 functor。 <code>Applicative</code> typeclass中有加入限制，让每一个
<code>Applicative</code> 都是 <code>Functor</code> 。但 <code>Monad</code> 却没有这样的限制，让每个 <code>Monad</code>
都是 <code>Applicative</code> 。这是因为 <code>Monad</code> 这个 typeclass 是在 <code>Applicative</code> 引入前就存在的缘故。
</p>

<p>
但即使每个 monad 都是一个 functor，但我们不需要依赖 <code>Functor</code> 的定义。那是因为我们有 <code>liftM</code> 这个函数。他会接受一个函数跟一个 monadic value，然后把函数
map over 那些 monadic value。所以他其实就是 <code>fmap</code> ，以下是他的型态：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">liftM</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m a <span style="color: #8787d7;">-&gt;</span> m b
</pre>
</div>

<p>
而这是 <code>fmap</code> 的型态：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">fmap</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Functor</span> f<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> f a <span style="color: #8787d7;">-&gt;</span> f b
</pre>
</div>

<p>
如果 <code>Functor</code> 跟 <code>Monad</code> 的 instance 遵守 functor 跟 monad的法则（到目前为止我们看过的 monad都遵守），那这两个函数其实是等价的。这就像 <code>pure</code> 跟
<code>return</code> 其实是同一件事，只是一个在 <code>Applicative</code> 中，而另外一个在 <code>Monad</code>
里面，我们来试试看 <code>liftM</code> 吧：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> liftM <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">8</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">24</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> fmap <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">8</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">24</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter <span style="color: #8787d7;">$</span> liftM not <span style="color: #8787d7;">$</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>, <span style="color: #2aa198;">"chickpeas"</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #2aa198;">"chickpeas"</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter <span style="color: #8787d7;">$</span> fmap not <span style="color: #8787d7;">$</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>, <span style="color: #2aa198;">"chickpeas"</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #2aa198;">"chickpeas"</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runState <span style="color: #268bd2;">(</span>liftM <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">100</span><span style="color: #d75fd7;">)</span> pop<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">101</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runState <span style="color: #268bd2;">(</span>fmap <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">100</span><span style="color: #d75fd7;">)</span> pop<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">101</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们已经知道 <code>fmap</code> 是如何运作在 <code>Maybe</code> 上。而 <code>liftM</code> 又跟 <code>fmap</code> 等价。对于 <code>Writer</code> 型态的值而言，函数只有对他的第一个 component做处理。而对于改变状态的计算， <code>fmap</code> 跟 <code>liftM</code> 也都是产生另一个改变状态的计算。我们也看过了
<code>(+100)</code> 当作用在 <code>pop</code> 上会产生 <code>(1, [2,3,4])</code> 。
</p>

<p>
来看看 <code>liftM</code> 是如何被实作的：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">liftM</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m a <span style="color: #8787d7;">-&gt;</span> m b
<span style="color: #d75fd7; font-weight: bold;">liftM</span> f m <span style="color: #8787d7;">=</span> m <span style="color: #8787d7;">&gt;&gt;=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #d75fd7;">(</span>f x<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
或者用 <code>do</code> 来表示得清楚些
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">liftM</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m a <span style="color: #8787d7;">-&gt;</span> m b
<span style="color: #d75fd7; font-weight: bold;">liftM</span> f m <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    x <span style="color: #8787d7;">&lt;-</span> m
    return <span style="color: #268bd2;">(</span>f x<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们喂一个 monadic value <code>m</code> 给函数，我们套用那个函数然后把结果放进一个缺省的 context。由于遵守 monad laws，这保证这操作不会改变context，只会呈现最后的结果。我们可以看到实作中 <code>liftM</code> 也没有用到 <code>Functor</code> 的性质。这代表我们能只用 monad 提供给我们的就实作完 <code>fmap</code> 。这特性让我们可以得到 monad 比 functor
性质要强的结论。
</p>

<p>
<code>Applicative</code> 让我们可以操作具有 context 的值就像操作一般的值一样。就像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">5</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">8</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;$&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
使用 applicative 的特性让事情变得很精简。 <code>&lt;$&gt;</code> 不过就是 <code>fmap=，而=&lt;*&gt;</code> 只是一个具有下列型态的函数：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">&lt;*&gt;</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Applicative</span> f<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> f <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> f a <span style="color: #8787d7;">-&gt;</span> f b
</pre>
</div>

<p>
他有点像 <code>fmap</code> ，只是函数本身有一个 context。我们必须把他从 context中抽出，对 <code>f a</code> 做 map over 的东做，然后再放回 context 中。由于在Haskel 中函数缺省都是 curried，我们便能用 <code>&lt;$&gt;</code> 以及 <code>&lt;*&gt;</code> 来让接受多个参数的函数也能接受
applicative 种类的值。
</p>

<p>
总之 <code>&lt;*&gt;</code> 跟 <code>fmap</code> 很类似，他也能只用 <code>Monad</code> 保证的性质实作出来。 <code>ap</code> 这个函数基本上就是 <code>&lt;*&gt;</code> ，只是他是限制在 <code>Monad</code> 上而不是 <code>Applicative</code> 上。这边是他的定义：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">ap</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> m <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m a <span style="color: #8787d7;">-&gt;</span> m b
<span style="color: #d75fd7; font-weight: bold;">ap</span> mf m <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    f <span style="color: #8787d7;">&lt;-</span> mf
    x <span style="color: #8787d7;">&lt;-</span> m
    return <span style="color: #268bd2;">(</span>f x<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
 <code>mf</code> 是一个 monadic value，他的结果是一个函数。由于函数跟值都是放在context
中，假设我们从 context 取出的函数叫 <code>f</code> ，从 context 取出的值叫 <code>x</code> ，我们把
<code>x</code> 喂给 <code>f</code> 然后再把结果放回 context。像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">4</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">7</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">`ap`</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">4</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">7</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&lt;*&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">11</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">11</span>,<span style="color: #d75fd7;">12</span>,<span style="color: #d75fd7;">12</span>,<span style="color: #d75fd7;">13</span>,<span style="color: #d75fd7;">13</span>,<span style="color: #d75fd7;">14</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">`ap`</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">11</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">11</span>,<span style="color: #d75fd7;">12</span>,<span style="color: #d75fd7;">12</span>,<span style="color: #d75fd7;">13</span>,<span style="color: #d75fd7;">13</span>,<span style="color: #d75fd7;">14</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
由于我们能用 <code>Monad</code> 提供的函数实作出 <code>Applicative</code> 的函数，因此我们看到
Monad 有比 applicative 强的性质。事实上，当我们知道一个型态是 monad的时候，大多数会先定义出 <code>Monad</code> 的 instance，然后才定义 <code>Applicative</code> 的 instance。而且只要把 <code>pure</code> 定义成 <code>return</code> ， <code>&lt;*&gt;</code> 定义成 <code>ap</code> 就行了。同样的，如果你已经有了 <code>Monad</code> 的 instance，你也可以简单的定义出 <code>Functor</code> ，只要把
<code>fmap</code> 定义成 <code>liftM</code> 就行了。
</p>

<p>
 <code>liftA2</code> 是一个方便的函数，他可以把两个 applicative的值喂给一个函数。他的定义很简单：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">liftA2</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Applicative</span> f<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b <span style="color: #8787d7;">-&gt;</span> c<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> f a <span style="color: #8787d7;">-&gt;</span> f b <span style="color: #8787d7;">-&gt;</span> f c
<span style="color: #d75fd7; font-weight: bold;">liftA2</span> f x y <span style="color: #8787d7;">=</span> f <span style="color: #8787d7;">&lt;$&gt;</span> x <span style="color: #8787d7;">&lt;*&gt;</span> y
</pre>
</div>

<p>
<code>liftM2</code> 也是做差不多的事情，只是多了 <code>Monad</code> 的限制。在函式库中其实也有
<code>liftM3</code> ， <code>liftM4</code> 跟 <code>liftM5</code> 。
</p>

<p>
我们看到了 monad 相较于 applicative 跟 functor 有比较强的性质。尽管moand 有
functor 跟 applicative functor 的性质，但他们不见得有 <code>Functor</code> 跟
<code>Applicative</code> 的 instance 定义。所以我们查看了一些在 monad中定义，且等价于
functor 或 applicative functor 所具有的函数。
</p>
</div>
</div>

<div id="outline-container-orgb26dcb8" class="outline-4">
<h4 id="orgb26dcb8"><span class="section-number-4">1.5.2</span> The join function</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
如果一个 monadic value 的结果是另一个 monadic value，也就是其中一个monadic
value 被包在另一个里面，你能够把他们变成一个普通的 monadic value吗？就好像把他们打平一样。譬如说，我们有 <code>Just (Just 9)</code> ，我们能够把他变成 <code>Just 9</code> 吗？事实上是可以的，这也是monad 的一个性质。也就是我要看的 <code>join</code> 函数，他的型态是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">join</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> m <span style="color: #268bd2;">(</span>m a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m a
</pre>
</div>

<p>
他接受一个包在另一个 monadic value 中的 monadic value，然后会回给我们一个普通的 monadic value。这边有一些 =Maybe=的范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> join <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">9</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">9</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> join <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #df005f; font-weight: bold;">Nothing</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> join <span style="color: #df005f; font-weight: bold;">Nothing</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
第一行是一个计算成功的结果包在另一个计算成功的结果，他们应该要能结合成为一个比较大的计算成功的结果。第二行则是一个=Nothing= 包在一个 <code>Just</code> 中。我们之前在处理 <code>Maybe</code> 型态的值时，会用 <code>&lt;*&gt;</code> 或 <code>&gt;&gt;=</code> 把他们结合起来。输入必须都是
<code>Just</code> 时结果出来才会是 <code>Just</code> 。如果中间有任何的失败，结果就会是一个失败的结果。而第三行就是这样，我们尝试把失败的结果接合起来，结果也会是一个失败。
</p>

<p>
要 <code>join</code> 一个 list 也是很简单：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> join <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">6</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">6</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
你可以看到，对于 list 而言 <code>join</code> 不过就是 <code>concat</code> 。 而要 <code>join</code> 一个包在
 <code>Writer</code> 中的 <code>Writer</code> ， 我们必须用 <code>mappend</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runWriter <span style="color: #8787d7;">$</span> join <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #2aa198;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #2aa198;">"aaa"</span><span style="color: #2aa198;">)</span>,<span style="color: #2aa198;">"bbb"</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #2aa198;">"bbbaaa"</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
 =​"bbb"​= 先被加到 monoid 中，接着 =​"aaa"​= 被附加上去。你想要查看 <code>Writer</code> 中的值的话，必须先把值写进去才行。
</p>

<p>
要对 <code>Either</code> 做 <code>join</code> 跟对 <code>Maybe</code> 做 <code>join</code> 是很类似的：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> join <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">9</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Either</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">9</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> join <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Right</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"error"</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Either</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"error"</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> join <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"error"</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Either</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #df005f; font-weight: bold;">Left</span> <span style="color: #2aa198;">"error"</span>
</pre>
</div>

<p>
如果我们对一个包了另外一个改变状态的计算的进行改变状态的计算，要作 <code>join</code> 的动作会让外面的先被计算，然后才是计算里面的：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> runState <span style="color: #268bd2;">(</span>join <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">State</span> <span style="color: #8787d7;">$</span> <span style="color: #8787d7;">\</span>s <span style="color: #8787d7;">-&gt;</span> <span style="color: #2aa198;">(</span>push <span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">1</span><span style="color: #df005f; font-weight: bold;">:</span><span style="color: #d75fd7;">2</span><span style="color: #df005f; font-weight: bold;">:</span>s<span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span>,<span style="color: #d75fd7;">0</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
这边的 lambda 函数接受一个状态，并把 <code>2</code> 跟 <code>1</code> 放到堆叠中，并把 <code>push 10</code>
当作他的结果。当对整个东西做 <code>join</code> 的时候，他会先把 <code>2</code> 跟 <code>1</code> 放到堆叠上，然后进行 <code>push 10</code> 的计算，因而把 <code>10</code> 放到堆叠的顶端。
</p>

<p>
<code>join</code> 的实作像是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">join</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> m <span style="color: #268bd2;">(</span>m a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> m a
<span style="color: #d75fd7; font-weight: bold;">join</span> mm <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    m <span style="color: #8787d7;">&lt;-</span> mm
    m
</pre>
</div>

<p>
因为 <code>mm</code> 的结果会是一个 monadic value，我们单独用 <code>m &lt;- mm</code> 拿取他的结果。这也可以说明 <code>Maybe</code> 只有当外层跟内层的值都是 <code>Just</code> 的时候才会是 <code>Just</code> 。如果把 <code>mm</code> 的值设成 <code>Just (Just 8)</code> 的话，他看起来会是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">joinedMaybes</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">joinedMaybes</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    m <span style="color: #8787d7;">&lt;-</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">8</span><span style="color: #268bd2;">)</span>
    m
</pre>
</div>


<div class="figure">
<p><img src="tipi.png" alt="tipi.png">
</p>
</div>

<p>
最有趣的是对于一个 monadic value 而言，用 <code>&gt;&gt;=</code> 把他喂进一个函数其实等价于对
monad 做 mapping over 的动作，然后用 <code>join</code> 来 把值从 nested 的状态变成扁平的状 态。也就是说 <code>m &gt;&gt;= f</code> 其实就是 <code>join (fmap f m)</code> 。如果你仔细想想的话其实很明显。 ~&gt;&gt;=~的使用方式是，把一个 monadic value喂进一个接受普通值的函数，但他却会回传 monadic value。如果我们 map over一个 monadic value，我们会做成一个 monadic value 包了另外一个 monadic value。例如说，我们现在手上有 <code>Just
    9</code> 跟 <code>\x -&gt; Just (x+1)</code> 。如果我们把这个函数 map over <code>Just 9</code> ，我们会得到
<code>Just (Just 10)</code> 事实上 <code>m &gt;&gt;= f</code> 永远等价于 <code>join (fmap f m)</code> 这性质非常有用。如果我们要定义自己的 <code>Monad</code> instance，要知道怎么把nested monadic value
变成扁平比起要定义 <code>&gt;&gt;=</code> 是比较容易的一件事。
</p>
</div>
</div>

<div id="outline-container-orgbbc3c09" class="outline-4">
<h4 id="orgbbc3c09"><span class="section-number-4">1.5.3</span> filterM</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
 <code>filter</code> 函数是 Haskell中不可或缺的要素。他接受一个断言(predicate)跟一个
list来过滤掉断言为否的部份并回传一个新的 list。他的型态是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">filter</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Bool</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
predicate 能接 list 中的一个元素并回传一个 <code>Bool</code> 型态的值。但如果 <code>Bool</code> 型态其实是一个 monadic value 呢？也就是他有一个context。例如说除了 <code>True</code> 跟
<code>False</code> 之外还伴随一个 monoid，像是 <code>["Accepted the number 5"]</code> ，或 <code>["3 is
    too small"]</code> 。照前面所学的听起来是没问题，而且产出的 list也会跟随 context，在这个例子中就是 log。所以如果 <code>Bool</code> 会回传伴随context 的布林值，我们会认为最终的结果也会具有 context。要不然这些context 都会在处理过程中遗失。
</p>

<p>
在 <code>Control.Monad</code> 中的 <code>filterM</code> 函数正是我们所需要的，他的型态如下：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">filterM</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> m <span style="color: #df005f; font-weight: bold;">Bool</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> m <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
predicate 会回传一个 monadic value，他的结果会是 <code>Bool</code> 型态，由于他是
monadic value，他的 context 有可能会是任何context，譬如说可能的失败，
non-determinism，甚至其他的context。一旦我们能保证 context 也会被保存在最后的结果中，结果也就是一个monadic value。
</p>

<p>
我们来写一个接受 list 然后过滤掉小于 4 的函数。先尝试使用 <code>filter</code> 函数：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> filter <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> x <span style="color: #8787d7;">&lt;</span> <span style="color: #d75fd7;">4</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
很简单吧。接着我们在做个 predicate，除了表达 <code>True</code> 或 <code>False</code> 之外，还提供了一个 log。我们会用 <code>Writer</code> monad 来表达这件事：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">keepSmall</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Writer</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Bool</span>
<span style="color: #d75fd7; font-weight: bold;">keepSmall</span> x
    <span style="color: #8787d7;">|</span> x <span style="color: #8787d7;">&lt;</span> <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        tell <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"Keeping "</span> <span style="color: #8787d7;">++</span> show x<span style="color: #268bd2;">]</span>
        return <span style="color: #df005f; font-weight: bold;">True</span>
    <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        tell <span style="color: #268bd2;">[</span>show x <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" is too large, throwing it away"</span><span style="color: #268bd2;">]</span>
        return <span style="color: #df005f; font-weight: bold;">False</span>
</pre>
</div>

<p>
这个函数会回传 <code>Writer [String] Bool</code> 而不是一个单纯的 <code>Bool</code> 。他是一个
monadic predicate。如果扫到的数字小于 <code>4</code> 的话，我们就会回报要保存他，而且回传 <code>return True</code> 。
</p>

<p>
接着，我们把他跟一个 list 喂给 <code>filterM</code> 。由于 predicate 会回传 <code>Writer</code> ，所以结果仍会是一个 <code>Writer</code> 值。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> fst <span style="color: #8787d7;">$</span> runWriter <span style="color: #8787d7;">$</span> filterM keepSmall <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
要检查 <code>Writer</code> 的结果，我们想要印出 log 看看里面有什么东西：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM_ putStrLn <span style="color: #8787d7;">$</span> snd <span style="color: #8787d7;">$</span> runWriter <span style="color: #8787d7;">$</span> filterM keepSmall <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">10</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7;">9</span> is too large, throwing it away
<span style="color: #df005f; font-weight: bold;">Keeping</span> <span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">5</span> is too large, throwing it away
<span style="color: #df005f; font-weight: bold;">Keeping</span> <span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">10</span> is too large, throwing it away
<span style="color: #df005f; font-weight: bold;">Keeping</span> <span style="color: #d75fd7;">3</span>
</pre>
</div>

<p>
提供 monadic predicate 给 <code>filterM</code> ，我们便能够做 filter的动作，同时还能保有 monadic context。
</p>

<p>
一个比较炫的技巧是用 <code>filterM</code> 来产生一个 list 的 powerset。一个powerset 就是一个集合所有子集所形成的集合。如果说我们的 list 是 <code>[1,2,3]</code> ，那他个
powerset 就会是：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">2</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2; font-weight: bold;">[]</span>
</pre>
</div>

<p>
换句话说，要产生一个 powerset 就是要列出所有要丢掉跟保留的组合。 <code>[2,3]</code> 只不过代表我们把 <code>1</code> 给丢掉而已。
</p>

<p>
我们要依赖 non-determinism 来写我们这产生 powerset 的函数。我们接受一个list
 <code>[1,2,3]</code> 然后查看第一个元素，这个例子中是 <code>1</code> ，我们会问：我们要保留他呢？还是丢掉他呢？答案是我们都要做。所以我们会用一个non-determinism 的
 predicate 来过滤我的 list。也就是我们的 <code>powerset</code> 函数：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">powerset</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">[</span>a<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">powerset</span> xs <span style="color: #8787d7;">=</span> filterM <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">[</span><span style="color: #df005f; font-weight: bold;">True</span>, <span style="color: #df005f; font-weight: bold;">False</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span> xs
</pre>
</div>

<p>
等等，我们已经写完了吗？没错，就这么简单，我们可以同时丢掉跟保留每个元素。只要我们用non-deterministic predicate，那结果也就是一个 non-deterministic
value，也便是一个 list 的 list。试着跑跑看：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> powerset <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">3</span><span style="color: #d75fd7;">]</span>,<span style="color: #d75fd7; font-weight: bold;">[]</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
这样的写法需要让你好好想一下，但如果你能接受 list 其实就是non-deterministic
value 的话，那要想通会比较容易一些。
</p>
</div>
</div>

<div id="outline-container-org173630c" class="outline-4">
<h4 id="org173630c"><span class="section-number-4">1.5.4</span> foldM</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
 <code>foldl</code> 的 monadic 的版本叫做 <code>foldM</code> 。如果你还有印象的话， <code>foldl</code> 会接受一个 binary 函数，一个起始累加值跟一串 list，他会从左边开始用binary 函数每次带进一个值来 fold。 <code>foldM</code> 也是做同样的事，只是他接受的这个 binary 函数会产生 monadic value。不意外的，他的结果也会是 monadic value。 <code>foldl</code> 的型态是：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">foldl</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b <span style="color: #8787d7;">-&gt;</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>b<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> a
</pre>
</div>

<p>
而 <code>foldM</code> 的型态则是：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">foldM</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Monad</span> m<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #268bd2;">(</span>a <span style="color: #8787d7;">-&gt;</span> b <span style="color: #8787d7;">-&gt;</span> m a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>b<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> m a
</pre>
</div>

<p>
binary 函数的回传值是 monadic，所以结果也会是 monadic。我们来试着把 list的值用 fold 全部加起来：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldl <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>acc x <span style="color: #8787d7;">-&gt;</span> acc <span style="color: #8787d7;">+</span> x<span style="color: #268bd2;">)</span> <span style="color: #d75fd7;">0</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7;">14</span>
</pre>
</div>

<p>
这边起始的累加值是 <code>0</code> ，首先 <code>2</code> 会被加进去，变成 <code>2</code> 。然后 <code>8</code> 被加进去变成 <code>10</code> ，直到我们没有值可以再加，那便是最终的结果。
</p>

<p>
但如果我们想额外加一个条件，也就是当碰到一个数字大于 <code>9</code> 时候，整个运算就算失败呢？一种合理的修改就是用一个 binary函数，他会检查现在这个数是否大于 <code>9</code>
，如果是便引发失败，如果不是就继续。由于有失败的可能性，我们便需要这个binary
函数回传一个 <code>Maybe</code> ，而不是一个普通的值。我们来看看这个函数：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">binSmalls</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #d75fd7; font-weight: bold;">binSmalls</span> acc x
    <span style="color: #8787d7;">|</span> x <span style="color: #8787d7;">&gt;</span> <span style="color: #d75fd7;">9</span>     <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
    <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">(</span>acc <span style="color: #8787d7;">+</span> x<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
由于这边的 binary 函数是 monadic function，我们不能用普通的 <code>foldl</code> ，我们必须用 <code>foldM</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldM binSmalls <span style="color: #d75fd7;">0</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">8</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">14</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldM binSmalls <span style="color: #d75fd7;">0</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">11</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
由于这串 list 中有一个数值大于 <code>9</code> ，所以整个结果会是 <code>Nothing</code> 。另外你也可以尝试 fold 一个回传 <code>Writer</code> 的 binary函数，他会在 fold 的过程中纪录你想纪录的信息。
</p>
</div>
</div>

<div id="outline-container-org4ede65f" class="outline-4">
<h4 id="org4ede65f"><span class="section-number-4">1.5.5</span> Making a safe RPN calculator</h4>
<div class="outline-text-4" id="text-1-5-5">

<div class="figure">
<p><img src="miner.png" alt="miner.png">
</p>
</div>

<p>
之前的章节我们实作了一个 RPN计算机，但我们没有做错误的处理。他只有在输入是合法的时候才会运算正确。假如有东西出错了，整个程序便会当掉。我们在这章看到了要怎样把代码转换成monadic 的版本，我们先尝适用 <code>Maybe</code> monad 来帮我们的 RPN计算机加上些错误处理。
</p>

<p>
我们的 RPN 计算机接受一个像 =​"1 3 + 2 *"​= 这样的字串，把他断成word，变成
 <code>["1","3","+","2","*"]</code> 这样。然后用一个 binary函数，跟一个空的堆叠，从左边开始或是将数值推进堆叠中，或是操作堆叠最上层的两个元素。
</p>

<p>
以下便是程序的核心部份：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">solveRPN</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Double</span>
<span style="color: #d75fd7; font-weight: bold;">solveRPN</span> <span style="color: #8787d7;">=</span> head <span style="color: #8787d7;">.</span> foldl foldingFunction <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #8787d7;">.</span> words
</pre>
</div>

<p>
我们把输入变成一个字串的 list，从左边开始fold，当堆叠中只剩下一个元素的时候，他便是我们要的答案。以下是我们的folding 函数：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Double</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Double</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>y<span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span> <span style="color: #2aa198;">"*"</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">*</span> y<span style="color: #268bd2;">)</span><span style="color: #df005f; font-weight: bold;">:</span>ys
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>y<span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span> <span style="color: #2aa198;">"+"</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span>x <span style="color: #8787d7;">+</span> y<span style="color: #268bd2;">)</span><span style="color: #df005f; font-weight: bold;">:</span>ys
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>y<span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span> <span style="color: #2aa198;">"-"</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span>y <span style="color: #8787d7;">-</span> x<span style="color: #268bd2;">)</span><span style="color: #df005f; font-weight: bold;">:</span>ys
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> xs numberString <span style="color: #8787d7;">=</span> read numberString<span style="color: #df005f; font-weight: bold;">:</span>xs
</pre>
</div>

<p>
这边我们的累加元素是一个堆叠，我们用一个 <code>Double</code> 的 list来表示他。当我们在做 folding 的过程，如果当前的元素是一个operator，他会从堆叠上拿下两个元素，用 operator施行运算然后把结果放回堆叠。如果当前的元素是一个表示成字串的数字，他会把字串转换成数字，并回传一个新的堆叠包含了转换后的数字。
</p>

<p>
我们首先把我们的 folding 函数加上处理错误的case，所以他的型态会变成这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Double</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Double</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
他不是回传一个 <code>Just</code> 的堆叠就是回传 <code>Nothing</code> 。
</p>

<p>
 <code>reads</code> 函数就像 <code>read</code> 一样，差别在于他回传一个list。在成功读取的情况下
list中只包含读取的那个元素。如果他失败了，他会回传一个空的list。除了回传读取的元素，他也回传剩下读取失败的元素。他必须要看完整串输入，我们想把他弄成一个
<code>readMaybe</code> 的函数，好方便我们进行。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">readMaybe</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Read</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> a
<span style="color: #d75fd7; font-weight: bold;">readMaybe</span> st <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">case</span> reads st <span style="color: #268bd2; font-weight: bold;">of</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span>x,<span style="color: #2aa198;">""</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> x
                                <span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
测试结果如下：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> readMaybe <span style="color: #2aa198;">"1"</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">1</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> readMaybe <span style="color: #2aa198;">"GO TO HELL"</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Int</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
看起来运作正常。我们再把他变成一个可以处理失败情况的 monadic 函数
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Double</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Double</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>y<span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span> <span style="color: #2aa198;">"*"</span> <span style="color: #8787d7;">=</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span>x <span style="color: #8787d7;">*</span> y<span style="color: #d75fd7;">)</span><span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>y<span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span> <span style="color: #2aa198;">"+"</span> <span style="color: #8787d7;">=</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span>x <span style="color: #8787d7;">+</span> y<span style="color: #d75fd7;">)</span><span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>y<span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span> <span style="color: #2aa198;">"-"</span> <span style="color: #8787d7;">=</span> return <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span>y <span style="color: #8787d7;">-</span> x<span style="color: #d75fd7;">)</span><span style="color: #df005f; font-weight: bold;">:</span>ys<span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">foldingFunction</span> xs numberString <span style="color: #8787d7;">=</span> liftM <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>readMaybe numberString<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
前三种 case 跟前面的很像，只差在堆叠现在是包在 <code>Just</code> 里面（我们常常是用
 <code>return</code> 来做到这件事，但其实我们也可以用 <code>Just</code> ）。在最后一种情况，我们用
 <code>readMaybe numberString</code> 然后我们用 <code>(:xs)</code> map over 他。所以如果堆叠 <code>xs</code>
 是 <code>[1.0,2.0]</code> 且 <code>readMaybe numberString</code> 产生 <code>Just 3.0</code> ，那结果便是
 <code>Just [3.0,1.0,2.0]</code> 。如果 <code>readyMaybe numberString</code> 产生 <code>Nothing</code> 那结果便是 <code>Nothing</code> 。我们来试着跑跑看 folding 函数
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldingFunction <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">]</span> <span style="color: #2aa198;">"*"</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">6.0</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldingFunction <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">2</span><span style="color: #268bd2;">]</span> <span style="color: #2aa198;">"-"</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">[</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1.0</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldingFunction <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #2aa198;">"*"</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldingFunction <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #2aa198;">"1"</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1.0</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldingFunction <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #2aa198;">"1 wawawawa"</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
看起来正常运作。我们可以用他来写一个新的 <code>solveRPN</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">solveRPN</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Maybe</span> <span style="color: #df005f; font-weight: bold;">Double</span>
<span style="color: #d75fd7; font-weight: bold;">solveRPN</span> st <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
  <span style="color: #268bd2;">[</span>result<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">&lt;-</span> foldM foldingFunction <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #268bd2;">(</span>words st<span style="color: #268bd2;">)</span>
  return result
</pre>
</div>

<p>
我们仍是接受一个字串把他断成一串 word。然后我们用一个空的堆叠来作folding 的动作，只差在我们用的是 <code>foldM</code> 而不是 <code>foldl</code> 。 <code>foldM</code> 的结果会是 <code>Maybe</code>
，=Maybe= 里面包含了一个只有一个元素的 list。我们用 <code>do</code> expression 来取出值，把他绑定到 <code>result</code> 上。当 <code>foldM</code> 回传 <code>Nothing</code> 的时候，整个结果就变成
<code>Nothing</code> 。也特别注意我们有在 <code>do</code> 里面做 pattern match 的动作，所以如果
list中不是只有一个元素的话，最后结果便会是 <code>Nothing</code> 。最后一行我们用
<code>return result</code> 来展示 RPN 计算的结果，把他包在一个 <code>Maybe</code> 里面。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> solveRPN <span style="color: #2aa198;">"1 2 * 4 +"</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">6.0</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> solveRPN <span style="color: #2aa198;">"1 2 * 4 + 5 *"</span>
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">30.0</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> solveRPN <span style="color: #2aa198;">"1 2 * 4"</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> solveRPN <span style="color: #2aa198;">"1 8 wharglbllargh"</span>
<span style="color: #df005f; font-weight: bold;">Nothing</span>
</pre>
</div>

<p>
第一个例子会失败是因为 list 中不是只有一个元素，所以 <code>do</code> 里面的 pattern
matching 失败了。第二个例子会失败是因为 <code>readMaybe</code> 回传了 <code>Nothing</code> 。
</p>
</div>
</div>

<div id="outline-container-orgc919084" class="outline-4">
<h4 id="orgc919084"><span class="section-number-4">1.5.6</span> Composing monadic functions</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
当我们介绍 monad law 的时候，我们说过 <code>&lt;=&lt;</code> 就像是函数合成一样，只差在一个是作用在普通函数 <code>a -&gt; b</code> 。一个是作用在monadic 函数 <code>a -&gt; m b</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> f <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">.</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">100</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> f <span style="color: #d75fd7;">4</span>
<span style="color: #d75fd7;">401</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> g <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #d75fd7;">(</span>x<span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;=&lt;</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>x <span style="color: #8787d7;">-&gt;</span> return <span style="color: #d75fd7;">(</span>x<span style="color: #8787d7;">*</span><span style="color: #d75fd7;">100</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">&gt;&gt;=</span> g
<span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">401</span>
</pre>
</div>

<p>
在这个例子中我们合成了两个普通的函数，并喂给给他 <code>4</code> 。我们也合成了两个
monadic 函数并用 <code>&gt;&gt;=</code> 喂给他 <code>Just 4</code> 。
</p>

<p>
如果我们在 list 中有一大堆函数，我们可以把他们合成一个巨大的函数。用 <code>id</code> 当作累加的起点， <code>.</code> 当作 binary 函数，用 fold 来作这件事。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">let</span> f <span style="color: #8787d7;">=</span> foldr <span style="color: #268bd2;">(</span><span style="color: #8787d7;">.</span><span style="color: #268bd2;">)</span> id <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #8787d7;">*</span><span style="color: #d75fd7;">100</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #8787d7;">+</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> f <span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">201</span>
</pre>
</div>

<p>
<code>f</code> 接受一个数字，然后会帮他加 <code>1=，乘以 =100</code> ，再加 <code>1</code> 。我们也可以将
monadic 函数用同样的方式做合成，只是不用 <code>.</code> 而用 <code>&lt;=&lt;</code> ，不用 <code>id</code> 而用
<code>return</code> 。我们不需要 <code>foldM</code> ，由于 <code>&lt;=&lt;</code> 只用 <code>foldr</code> 就足够了。
</p>

<p>
当我们在之前的章节介绍 list monad 的时候，我们用他来解决一个骑士是否能在三步内走到另一点的问题。 那个函数叫做=moveKnight=， 他接受一个座标然后回传所有可能的下一步。然后产生出所有可能三步的移动。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">in3</span> start <span style="color: #8787d7;">=</span> return start <span style="color: #8787d7;">&gt;&gt;=</span> moveKnight <span style="color: #8787d7;">&gt;&gt;=</span> moveKnight <span style="color: #8787d7;">&gt;&gt;=</span> moveKnight
</pre>
</div>

<p>
要检查我们是否能只用三步从 <code>start</code> 走到 <code>end</code> ，我们用下列函数
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">canReachIn3</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Bool</span>
<span style="color: #d75fd7; font-weight: bold;">canReachIn3</span> start end <span style="color: #8787d7;">=</span> end <span style="color: #8787d7;">`elem`</span> in3 start
</pre>
</div>

<p>
如果使用 monadic 版本的合成的话，我们也可以做一个类似的 <code>in3</code> ，但我们希望他不只有三步的版本，而希望有任意步的版本。如果你仔细观察 <code>in3</code> ，他只不过用
<code>&gt;&gt;=</code> 跟 <code>moveKnight</code> 把之前所有可能结果喂到下一步。把他一般化，就会像下面的样子：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">inMany</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">KnightPos</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">inMany</span> x start <span style="color: #8787d7;">=</span> return start <span style="color: #8787d7;">&gt;&gt;=</span> foldr <span style="color: #268bd2;">(</span><span style="color: #8787d7;">&lt;=&lt;</span><span style="color: #268bd2;">)</span> return <span style="color: #268bd2;">(</span>replicate x moveKnight<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
首先我们用 <code>replicate</code> 来做出一个 list，里面有 <code>x</code> 份的 <code>moveKnight</code> 。然后我们把所有函数都合成起来，就会给我们从起点走 <code>x</code> 步内所有可能的的位置。然后我们只需要把起始位置喂给他就好了。
</p>

<p>
我们也可以一般化我们的 <code>canReachIn3</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">canReachIn</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Int</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">KnightPos</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Bool</span>
<span style="color: #d75fd7; font-weight: bold;">canReachIn</span> x start end <span style="color: #8787d7;">=</span> end <span style="color: #8787d7;">`elem`</span> inMany x start
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7a99f45" class="outline-3">
<h3 id="org7a99f45"><span class="section-number-3">1.6</span> 定义自己的 Monad</h3>
<div class="outline-text-3" id="text-1-6">

<div class="figure">
<p><img src="spearhead.png" alt="spearhead.png">
</p>
</div>

<p>
在这一章节，我们会带你看看究竟一个型态是怎么被辨认，确认是一个 monad而且正确定义出 <code>Monad</code> 的 instance。我们通常不会为了定义 monad而定义。比较常发生的是，我们想要针对一个问题建立模型，却稍后发现我们定义的型态其实是一个Monad，所以就定义一个 <code>Monad</code> 的 instance。
</p>

<p>
正如我们看到的，list 是被拿来当作 non-deterministic values。对于 <code>[3,5,9]</code> ，我们可以看作是一个 non-deterministic value，我们不能知道究竟是哪一个。当我们把一个 list 用 <code>&gt;&gt;=</code> 喂给一个函数，他就是把一串可能的选择都丢给函数，函数一个个去计算在那种情况下的结果，结果也便是一个list。
</p>

<p>
如果我们把 <code>[3,5,9]</code> 看作是 <code>3</code> , <code>5</code> , <code>9</code> 各出现一次，但这边没有每一种数字出现的机率。如果我们把 non-deterministic的值看作是 <code>[3,5,9]</code> ，但 <code>3</code> 出现的机率是 50%， <code>5</code> 跟 <code>9</code> 出现的机率各是25%呢？我们来试着用 Haskell 描述看看。
</p>

<p>
如果说 list 中的每一个元素都伴随着他出现的机率。那下面的形式就蛮合理的：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">0.5</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">0.25</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">0.25</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
在数学上，机率通常不是用百分比表示，而是用介于 0 跟 1 的实数表示。0代表不可能会发生，而 1代表绝对会发生。但浮点数很有可能很快随着运算失去精准度，所以
Haskell有提供有理数。他的型态是摆在 <code>Data.Ratio</code> 中，叫做 <code>Rational</code> 。要创造出一个 <code>Rational</code> ，我们会把他写成一个分数的形式。分子跟分母用 <code>%</code> 分隔。这边有几个例子：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span>
<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">4</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">+</span> <span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">1</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">+</span> <span style="color: #d75fd7;">5</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span>
<span style="color: #d75fd7;">19</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">12</span>
</pre>
</div>

<p>
第一行代表四分之一，第二行代表两个二分之一加起来变成一。而第三行我们把三分之一跟四分之五加起来变成十二分之十九。所以我们来用 <code>Rational</code> 取代浮点数来当作我们的机率值吧。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">4</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
所以 <code>3</code> 有二分之一的机会出现，而 <code>5</code> 跟 <code>9</code> 有四分之一的机会出现。
</p>

<p>
可以看到我们帮 list 加上了一些额外的context。再我们继续深入之前，我们用一个
 <code>newtype</code> 把他包起来，好让我们帮他写 instance。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.Ratio</span>

<span style="color: #268bd2; font-weight: bold;">newtype</span> <span style="color: #df005f; font-weight: bold;">Prob</span> a <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2;">{</span> getProb <span style="color: #8787d7;">::</span> <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">(</span>a,<span style="color: #df005f; font-weight: bold;">Rational</span><span style="color: #2aa198;">)</span><span style="color: #d75fd7;">]</span> <span style="color: #268bd2;">}</span> <span style="color: #268bd2; font-weight: bold;">deriving</span> <span style="color: #df005f; font-weight: bold;">Show</span>
</pre>
</div>

<p>
接着我们想问，这是一个 functor 吗？list 是一个functor，所以很有可能他也是一个
functor，毕竟我们只是在 list上多加一些东西而已。在 list的情况下，我们可以针对每个元素用函数做处理。这边我们也是用函数针对每个元素做处理，只是我们是输出机率值。所以我们就来写个functor 的 instance 吧。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">Functor</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    fmap f <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Prob</span> xs<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #8787d7;">$</span> map <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span><span style="color: #d75fd7;">(</span>x,p<span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>f x,p<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> xs
</pre>
</div>

<p>
我们可以用 pattern matching 的方式把 <code>newtype</code> 解开来，套用函数 <code>f</code> 之后再包回去。过程中不会动到机率值。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> fmap negate <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #2aa198;">)</span>,<span style="color: #2aa198;">(</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span><span style="color: #2aa198;">)</span>,<span style="color: #2aa198;">(</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span><span style="color: #2aa198;">)</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2;">{</span>getProb <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">2</span><span style="color: #2aa198;">)</span>,<span style="color: #2aa198;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">5</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">4</span><span style="color: #2aa198;">)</span>,<span style="color: #2aa198;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">9</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">4</span><span style="color: #2aa198;">)</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
要注意机率的和永远是 <code>1</code> 。如果我们没有漏掉某种情形的话，没有道理他们加起来的值不为 <code>1</code> 。一个有 75% 机率是正面以及 50% 机率是反面的硬币根本没什么道理。
</p>

<p>
接着要问一个重要的问题，他是一个 monad 吗？我们知道 list 是一个monad，所以他很有可能也是一个 monad。首先来想想 <code>return</code> 。他在 list是怎么运作的？他接受一个普通的值并把他放到一个 list 中变成只有一个元素的list。那在这边又如何？由于他是一个最小的 context，他也应该是一个元素的list。那机率值呢？ <code>return x</code> 的值永远都是 <code>x</code> ，所以机率值不应该是 <code>0</code> ，而应该是 <code>1</code> 。
</p>

<p>
至于 <code>&gt;&gt;=</code> 呢？看起来有点复杂，所以我们换种方式来思考，我们知道 <code>m &gt;&gt;= f</code> 会等价于 <code>join (fmap f m)</code> ，所以我们来想要怎么把一串包含probability list 的
list 弄平。举个例子，考虑一个 list， =​'a'​= 跟 =​'b'​= 恰出现其中一个的机率为
25%，两个出现的机率相等。而 =​'c'​= 跟 =​'d'​= 恰出现其中一个的机率为75%，两个出现的机率也是相等。这边有一个图将情形画出来。
</p>


<div class="figure">
<p><img src="prob.png" alt="prob.png">
</p>
</div>

<p>
每个字母发生的机率有多高呢？如果我们用四个盒子来代表每个字母，那每个盒子的机率为何？每个盒子的机率是他们所装有的机率值相乘的结果。 =​'a'​= 的机率是八分之一，
=​'b'​= 同样也是八分之一。八分之一是因为我们把二分之一跟四分之一相乘得到的结果。而 =​'c'​= 发生的机率是八分之三，是因为二分之一乘上四分之三。 =​'d'​= 同样也是八分之三。如果把所有的机率加起来，就会得到一，符合机率的规则。
</p>

<p>
来看看怎么用一个 list 表达我们要说明的东西：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">thisSituation</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #df005f; font-weight: bold;">Char</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">thisSituation</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span>
    <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #2aa198;">[</span><span style="color: #67b11d;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #67b11d;">)</span>,<span style="color: #67b11d;">(</span><span style="color: #2aa198;">'b'</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #67b11d;">)</span><span style="color: #2aa198;">]</span> , <span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span> <span style="color: #d75fd7;">)</span>
    ,<span style="color: #d75fd7;">(</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #2aa198;">[</span><span style="color: #67b11d;">(</span><span style="color: #2aa198;">'c'</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #67b11d;">)</span>,<span style="color: #67b11d;">(</span><span style="color: #2aa198;">'d'</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #67b11d;">)</span><span style="color: #2aa198;">]</span> , <span style="color: #d75fd7;">3</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">4</span> <span style="color: #d75fd7;">)</span>
    <span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
注意到这边的型态是 <code>Prob (Prob Char)</code> 。所以我们要思考的是如何把一串包含机率
list 的 list打平。如果能成功写出这样的逻辑， <code>&gt;&gt;=</code> 不过就是 <code>join (fmap f m)</code>
，我们便得到了一个 monad。我们这边写了一个 <code>flatten</code> 来做这件事。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">flatten</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Prob</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">Prob</span> a
<span style="color: #d75fd7; font-weight: bold;">flatten</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Prob</span> xs<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #8787d7;">$</span> concat <span style="color: #8787d7;">$</span> map multAll xs
    <span style="color: #268bd2; font-weight: bold;">where</span> multAll <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Prob</span> innerxs,p<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> map <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span><span style="color: #d75fd7;">(</span>x,r<span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #d75fd7;">(</span>x,p<span style="color: #8787d7;">*</span>r<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> innerxs
</pre>
</div>

<p>
 <code>multAll</code> 接受一个 tuple，里面包含一个 probability list跟一个伴随的机率值
<code>p</code> ，所以我们要作的事是把 list 里面的机率值都乘以 <code>p</code> ，并回传一个新的 tuple
包含新的 list 跟新的机率值。我们将 <code>multAll</code> map over 到我们的 probability
list 上，我们就成功地打平了我们的 list。
</p>

<p>
现在我们就能定义我们的 <code>Monad</code> instance。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">instance</span> <span style="color: #df005f; font-weight: bold;">Monad</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2; font-weight: bold;">where</span>
    return x <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span>x,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">1</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
    m <span style="color: #8787d7;">&gt;&gt;=</span> f <span style="color: #8787d7;">=</span> flatten <span style="color: #268bd2;">(</span>fmap f m<span style="color: #268bd2;">)</span>
    fail <span style="color: #268bd2; font-weight: bold;">_</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2; font-weight: bold;">[]</span>
</pre>
</div>


<div class="figure">
<p><img src="ride.png" alt="ride.png">
</p>
</div>

<p>
由于我们已经把所有苦工的做完了，定义这个 instance显得格外轻松。我们也定义了
 <code>fail</code> ，我们定义他的方式跟定义 list一样。如果在 <code>do</code> 中发生了失败的 pattern
 match，那就会调用 <code>fail</code> 。
</p>

<p>
检查我们定义的 instance 是否遵守 monad law 也是很重要的。monad law的第一个定律是 <code>return x &gt;&gt;= f</code> 应该要等价于 <code>f x</code> 。要写出严格的证明会很麻烦，但我们可以观察到下列事实：首先用=return= 做一个最小的 context，然后用 <code>fmap</code> 将一个函数 map over 这个context，再将他打平。这样做出来的 probability list，每一个机率值都相当于将我们最初放到 minimal context 中的值乘上 <code>1%1</code> 。同样的逻辑，也可以看出 <code>m &gt;&gt;= return</code> 是等价于 <code>m</code> 。第三个定律是 <code>f &lt;=&lt; (g &lt;=&lt; h)</code> 应该要等价于 <code>(f &lt;=&lt; g) &lt;=&lt; h</code> 。我们可以从乘法有结合律的性质，以及 list monad的特性上推出 probability monad 也符合这个定律。 <code>1%2 * (1%3 * 1%5)</code> 等于 <code>(1%2 *
   1%3) * 1%5</code> 。
</p>

<p>
现在我们有了一个monad，这样有什么好处呢？他可以帮助我们计算机率值。我们可以把机率事件看作是具有context 的 value，而 probability monad可以保证机率值能正确地被计算成最终的结果。
</p>

<p>
好比说我们现在有两个普通的硬币以及一个灌铅的硬币。灌铅的硬币十次中有九次会出现正面，只有一次会出现反面。如果我们一次丢掷这三个硬币，有多大的机会他们都会出现正面呢？让我们先来表达丢掷硬币这件事，分别丢的是灌铅的跟普通的硬币。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">data</span> <span style="color: #df005f; font-weight: bold;">Coin</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Heads</span> <span style="color: #8787d7;">|</span> <span style="color: #df005f; font-weight: bold;">Tails</span> <span style="color: #268bd2; font-weight: bold;">deriving</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Show</span>, <span style="color: #df005f; font-weight: bold;">Eq</span><span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">coin</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #df005f; font-weight: bold;">Coin</span>
<span style="color: #d75fd7; font-weight: bold;">coin</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Heads</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Tails</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">2</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>

<span style="color: #d75fd7; font-weight: bold;">loadedCoin</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #df005f; font-weight: bold;">Coin</span>
<span style="color: #d75fd7; font-weight: bold;">loadedCoin</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Heads</span>,<span style="color: #d75fd7;">1</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">10</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Tails</span>,<span style="color: #d75fd7;">9</span><span style="color: #8787d7;">%</span><span style="color: #d75fd7;">10</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
最后，来看看掷硬币的函数：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span> <span style="color: #268bd2;">(</span>all<span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">flipThree</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">Prob</span> <span style="color: #df005f; font-weight: bold;">Bool</span>
<span style="color: #d75fd7; font-weight: bold;">flipThree</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
  a <span style="color: #8787d7;">&lt;-</span> coin
  b <span style="color: #8787d7;">&lt;-</span> coin
  c <span style="color: #8787d7;">&lt;-</span> loadedCoin
  return <span style="color: #268bd2;">(</span>all <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">==</span><span style="color: #df005f; font-weight: bold;">Tails</span><span style="color: #d75fd7;">)</span> <span style="color: #d75fd7;">[</span>a,b,c<span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
试着跑一下的话，我们会看到尽管我们用了不公平的硬币，三个反面的机率还是不高。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> getProb flipThree
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">9</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">9</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span>,
 <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">9</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span>,<span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #d75fd7;">9</span> <span style="color: #8787d7;">%</span> <span style="color: #d75fd7;">40</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
同时出现正面的机率是四十分之九，差不多是 25%的机会。我们的 monad并没有办法
join 所有都是 <code>False</code> 的情形，也就是所有硬币都是出现反面的情况。不过那不是个严重的问题，可以写个函数来将同样的结果变成一种结果，这就留给读者当作习题。
</p>

<p>
在这章节中，我们从提出问题到真的写出型态，并确认这个型态是一个monad，写出他的
instance并实际操作他。这是个很棒的经验。现在读者们应该对于 monad有不少的了解才是。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: 刘向</p>
<p class="date">Created: 2019-12-13 五 22:04</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
