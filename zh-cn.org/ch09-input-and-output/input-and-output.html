<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-12-13 五 22:03 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>输入与输出</title>
<meta name="generator" content="Org mode">
<meta name="author" content="刘向">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://liuxiang.coding.me/liuxiang/style/org/spacemacs-wide/htmlize.css"/>
 <script src="https://liuxiang.coding.me/liuxiang/js/org/spacemacs-wide/jquery.min.js"></script>
 <script src="https://liuxiang.coding.me/liuxiang/js/org/spacemacs-wide/bootstrap.min.js"></script>
 <script src="https://liuxiang.coding.me/liuxiang/js/org/spacemacs-wide/readtheorg.js"></script>
 <link rel="stylesheet" type="text/css" href="https://liuxiang.coding.me/liuxiang/style/org/spacemacs-wide/readtheorg.css"/>
 <link rel="stylesheet" type="text/css" href="https://liuxiang.coding.me/liuxiang/style/org/spacemacs-wide/font-awesome.min.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">输入与输出</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb4cd4db">1. 输入与输出</a>
<ul>
<li><a href="#orgbe6a77b">1.1. Hello, world!</a></li>
<li><a href="#orga90af47">1.2. 文件与字符流</a></li>
<li><a href="#org2fc2c03">1.3. 命令行引数</a></li>
<li><a href="#orgad4348b">1.4. 乱数</a></li>
<li><a href="#org095f38a">1.5. Bytestrings</a></li>
<li><a href="#org4c779d3">1.6. Exceptions (例外)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb4cd4db" class="outline-2">
<h2 id="orgb4cd4db"><span class="section-number-2">1</span> 输入与输出</h2>
<div class="outline-text-2" id="text-1">

<div class="figure">
<p><img src="dognap.png" alt="dognap.png">
</p>
</div>

<p>
我们已经说明了 Haskell是一个纯粹函数式语言。虽说在命令式语言中我们习惯给电脑执行一连串指令，在函数式语言中我们是用定义东西的方式进行。在Haskell中，一个函数不能改变状态，像是改变一个变量的内容。（当一个函数会改变状态，我们说这函数是有副作用的。）在Haskell中函数唯一可以做的事是根据我们给定的参数来算出结果。如果我们用同样的参数调用两次同一个函数，它会回传相同的结果。尽管这从命令式语言的角度来看是蛮大的限制，我们已经看过它可以达成多么酷的效果。在一个命令式语言中，编程语言没办法给你任何保证在一个简单如打印出几个数字的函数不会同时烧掉你的房子，绑架你的狗并刮伤你车子的烤漆。例如，当我们要建立一棵二元树的时候，我们并不插入一个节点来改变原有的树。由于我们无法改变状态，我们的函数实际上回传了一棵新的二元树。
</p>

<p>
函数无法改变状态的好处是它让我们促进了我们理解程序的容易度，但同时也造成了一个问题。假如说一个函数无法改变现实世界的状态，那它要如何打印出它所计算的结果？毕竟要告诉我们结果的话，它必须要改变输出设备的状态（譬如说屏幕），然后从屏幕传达到我们的脑，并改变我们心智的状态。
</p>

<p>
不要太早下结论，Haskell实际上设计了一个非常聪明的系统来处理有副作用的函数，它漂亮地将我们的程序区分成纯粹跟非纯粹两部分。非纯粹的部分负责跟键盘还有屏幕沟通。有了这区分的机制，在跟外界沟通的同时，我们还是能够有效运用纯粹所带来的好处，像是惰性求值、容错性跟模块性。
</p>
</div>

<div id="outline-container-orgbe6a77b" class="outline-3">
<h3 id="orgbe6a77b"><span class="section-number-3">1.1</span> Hello, world!</h3>
<div class="outline-text-3" id="text-1-1">

<div class="figure">
<p><img src="helloworld.png" alt="helloworld.png">
</p>
</div>

<p>
到目前为止我们都是将函数加载 GHCi中来测试，像是标准函式库中的一些函式。但现在我们要做些不一样的，写一个真实跟世界交互的Haskell 程序。当然不例外，我们会来写个 "hello world"。
</p>

<p>
现在，我们把下一行打到你熟悉的编辑器中
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> putStrLn <span style="color: #2aa198;">"hello, world"</span>
</pre>
</div>

<p>
我们定义了一个 <code>main</code> ，并在里面以 =​"hello, world"​= 为参数调用了 <code>putStrLn</code>
。看起来没什么大不了，但不久你就会发现它的奥妙。把这程序存成 <code>helloworld.hs</code>
。
</p>

<p>
现在我们将做一件之前没做过的事：编译你的程序。打开你的终端并切换到包含
<code>helloworld.hs</code> 的目录，并输入下列指令。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> ghc <span style="color: #008787;">--</span><span style="color: #008787;">make helloworld</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span> <span style="color: #268bd2; font-weight: bold;">of</span> <span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Compiling</span> <span style="color: #df005f; font-weight: bold;">Main</span>                 <span style="color: #268bd2;">(</span> helloworld<span style="color: #8787d7;">.</span>hs, hellowowlrd<span style="color: #8787d7;">.</span>o <span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Linking</span> helloworld <span style="color: #8787d7;">...</span>
</pre>
</div>

<p>
顺利的话你就会得到如上的消息，接着你便可以执行你的程序 <code>./helloworld</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>helloworld
hello, world
</pre>
</div>

<p>
这就是我们第一个编译成功并打印出字串到屏幕的程序。很简单吧。
</p>

<p>
让我们来看一下我们究竟做了些什么，首先来看一下 <code>putStrLn</code> 函数的型态：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">:</span>t putStrLn
<span style="color: #d75fd7; font-weight: bold;">putStrLn</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">:</span>t putStrLn <span style="color: #2aa198;">"hello, world"</span>
<span style="color: #d75fd7; font-weight: bold;">putStrLn</span> <span style="color: #2aa198;">"hello, world"</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
</pre>
</div>

<p>
我们可以这么解读 <code>putStrLn</code> 的型态： <code>putStrLn</code> 接受一个字串并回传一个I/O
action，这 I/O action 包含了 <code>()</code> 的型态。（即空的 tuple，或者是unit 型态）。一个 I/O action是一个会造成副作用的动作，常是指读取输入或输出到屏幕，同时也代表会回传某些值。在屏幕打印出几个字串并没有什么有意义的回传值可言，所以这边用一个 <code>()</code> 来代表。
</p>

<p>
那究竟 I/O action 会在什么时候被触发呢？这就是 <code>main</code> 的功用所在。一个I/O
action 会在我们把它绑定到 <code>main</code> 这个名字并且执行程序的时候触发。
</p>

<p>
把整个程序限制在只能有一个 I/O action看似是个极大的限制。这就是为什么我们需要
do 表示法来将所有 I/O action绑成一个。来看看下面这个例子。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    putStrLn <span style="color: #2aa198;">"Hello, what's your name?"</span>
    name <span style="color: #8787d7;">&lt;-</span> getLine
    putStrLn <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Hey "</span> <span style="color: #8787d7;">++</span> name <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">", you rock!"</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
新的语法，有趣吧！它看起来就像一个命令式的程序。如果你编译并执行它，它便会照你预期的方式执行。我们写了一个do 并且接着一连串指令，就像写个命令式程序一般，每一步都是一个 I/O action。将所有 I/O action 用 do 绑在一起变成了一个大的 I/O
action。这个大的 I/O action 的型态是 =IO ()=，这完全是由最后一个 I/O action
所决定的。
</p>

<p>
这就是为什么 <code>main</code> 的型态永远都是 <code>main :: IO something</code> ，其中 <code>something</code>
是某个具体的型态。按照惯例，我们通常不会把 <code>main</code> 的型态在程序中写出来。
</p>

<p>
另一个有趣的事情是第三行 <code>name &lt;- getLine</code> 。它看起来像是从输入读取一行并存到一个变量 <code>name</code> 之中。真的是这样吗？我们来看看 <code>getLine</code> 的型态吧
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #df005f; font-weight: bold;">:</span>t getLine
<span style="color: #d75fd7; font-weight: bold;">getLine</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #df005f; font-weight: bold;">String</span>
</pre>
</div>


<div class="figure">
<p><img src="luggage.png" alt="luggage.png">
</p>
</div>

<p>
我们可以看到 <code>getLine</code> 是一个回传 <code>String</code> 的 I/O action。因为它会等用户输入某些字串，这很合理。那 <code>name &lt;- getLine</code> 又是如何？你能这样解读它：执行一个
I/O action <code>getLine</code> 并将它的结果绑定到 <code>name</code> 这个名字。 <code>getLine</code> 的型态是
<code>IO String</code> ，所以 <code>name</code> 的型态会是 <code>String</code> 。你能把 I/O action想成是一个长了脚的盒子，它会跑到真实世界中替你做某些事，像是在墙壁上涂鸦，然后带回来某些数据。一旦它带了某些数据给你，打开盒子的唯一办法就是用 <code>&lt;-</code> 。而且如果我们要从 I/O action 拿出某些数据，就一定同时要在另一个 I/O action 中。这就是
Haskell如何漂亮地分开纯粹跟不纯粹的程序的方法。 <code>getLine</code> 在这样的意义下是不纯粹的，因为执行两次的时候它没办法保证会回传一样的值。这也是为什么它需要在一个 <code>IO</code> 的型态建构子中，那样我们才能在 I/O action中取出数据。而且任何一段程序一旦依赖着 I/O 数据的话，那段程序也会被视为I/O code。
</p>

<p>
但这不表示我们不能在纯粹的代码中使用 I/O action回传的数据。只要我们绑定它到一个名字，我们便可以暂时地使用它。像在 <code>name &lt;- getLine</code> 中 <code>name</code> 不过是一个普通字串，代表在盒子中的内容。我们能将这个普通的字串传给一个极度复杂的函数，并回传你一生会有多少财富。像是这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    putStrLn <span style="color: #2aa198;">"Hello, what's your name?"</span>
    name <span style="color: #8787d7;">&lt;-</span> getLine
    putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"Read this carefully, because this is your future: "</span> <span style="color: #8787d7;">++</span> tellFortune name
</pre>
</div>

<p>
<code>tellFortune</code> 并不知道任何 I/O 有关的事，它的型态只不过是
=String -&gt; String=。
</p>

<p>
再来看看这段代码吧，他是合法的吗?
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">nameTag</span> <span style="color: #8787d7;">=</span> <span style="color: #2aa198;">"Hello, my name is "</span> <span style="color: #8787d7;">++</span> getLine
</pre>
</div>

<p>
如果你回答不是，恭喜你。如果你说是，你答错了。这么做不对的理由是 <code>++</code> 要求两个参数都必须是串列。他左边的参数是 <code>String</code> ，也就是 <code>[Char]</code> 。然而
<code>getLine</code> 的型态是 <code>IO String</code> 。你不能串接一个字串跟 I/O action。我们必须先把 <code>String</code> 的值从 I/O action中取出，而唯一可行的方法就是在 I/O action 中使用
<code>name &lt;- getLine</code> 。如果我们需要处理一些非纯粹的数据，那我们就要在非纯粹的环境中做。所以我们最好把I/O 的部分缩减到最小的比例。
</p>

<p>
每个 I/O action
都有一个值封装在里面。这也是为什么我们之前的程序可以这么写：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    foo <span style="color: #8787d7;">&lt;-</span> putStrLn <span style="color: #2aa198;">"Hello, what's your name?"</span>
    name <span style="color: #8787d7;">&lt;-</span> getLine
    putStrLn <span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Hey "</span> <span style="color: #8787d7;">++</span> name <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">", you rock!"</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
然而， <code>foo</code> 只会有一个 <code>()</code> 的值，所以绑定到 <code>foo</code> 这个名字似乎是多余的。另外注意到我们并没有绑定最后一行的 <code>putStrLn</code> 给任何名字。那是因为在一个 do
block 中，最后一个 action不能绑定任何名字。我们在之后讲解 Monad的时候会说明为什么。现在你可以先想成 do block 会自动从最后一个 action取出值并绑定给他的结果。
</p>

<p>
除了最后一行之外，其他在 do中没有绑定名字的其实也可以写成绑定的形式。所以
 <code>putStrLn "BLAH"​</code> 可以写成 <code>_ &lt;- putStrLn "BLAH"​</code> 。但这没什么实际的意义，所以我们宁愿写成 <code>putStrLn something</code> 。
</p>

<p>
初学者有时候会想错
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">name</span> <span style="color: #8787d7;">=</span> getLine
</pre>
</div>

<p>
以为这行会读取输入并给他绑定一个名字叫 <code>name</code> 但其实只是把 <code>getLine</code> 这个 I/O
action 指定一个名字叫 <code>name</code> 罢了。记住，要从一个 I/O action中取出值，你必须要在另一个 I/O action 中将他用 <code>&lt;-</code> 绑定给一个名字。
</p>

<p>
I/O actions 只会在绑定给 <code>main</code> 的时候或是在另一个用 do 串起来的 I/O action
才会执行。你可以用 do 来串接 I/O actions，再用 do来串接这些串接起来的 I/O
actions。不过只有最外面的 I/O action 被指定给main 才会触发执行。
</p>

<p>
喔对，其实还有另外一个情况。就是在 GHCi 中输入一个 I/O action 并按下Enter 键，那也会被执行
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> putStrLn <span style="color: #2aa198;">"HEEY"</span>
<span style="color: #df005f; font-weight: bold;">HEEY</span>
</pre>
</div>

<p>
就算我们只是在 GHCi 中打几个数字或是调用一个函数，按下 Enter就会计算它并调用
 <code>show</code> ，再用 <code>putStrLn</code> 将字串打印出在终端上。
</p>

<p>
还记得 let binding 吗？如果不记得，回去温习一下这个章节。它们的形式是 <code>let
   bindings in expression</code> ，其中 <code>bindings</code> 是 expression中的名字、
<code>expression</code> 则是被运用到这些名字的算式。我们也提到了 list comprehensions 中，
<code>in</code> 的部份不是必需的。你能够在 do blocks 中使用 let bindings 如同在 list
comprehensions 中使用它们一样，像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.Char</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    putStrLn <span style="color: #2aa198;">"What's your first name?"</span>
    firstName <span style="color: #8787d7;">&lt;-</span> getLine
    putStrLn <span style="color: #2aa198;">"What's your last name?"</span>
    lastName <span style="color: #8787d7;">&lt;-</span> getLine
    <span style="color: #268bd2; font-weight: bold;">let</span> bigFirstName <span style="color: #8787d7;">=</span> map toUpper firstName
        bigLastName <span style="color: #8787d7;">=</span> map toUpper lastName
    putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"hey "</span> <span style="color: #8787d7;">++</span> bigFirstName <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" "</span> <span style="color: #8787d7;">++</span> bigLastName <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">", how are you?"</span>
</pre>
</div>

<p>
注意我们是怎么编排在 do block 中的 I/O actions，也注意到我们是怎么编排let 跟其中的名字的，由于对齐在 Haskell中并不会被无视，这么编排才是好的习惯。我们的程序用 <code>map toUpper firstName</code> 将 =​"John"​= 转成大写的 =​"JOHN"​= ，并将大写的结果绑定到一个名字上，之后在输出的时候参考到了这个名字。
</p>

<p>
你也许会问究竟什么时候要用 <code>&lt;-</code> ，什么时候用 let bindings？记住， <code>&lt;-</code> 是用来运算 I/O actions 并将他的结果绑定到名称。而 <code>map toUpper firstName</code> 并不是一个 I/O action。他只是一个纯粹的expression。所以总结来说，当你要绑定 I/O
actions 的结果时用 <code>&lt;-</code> ，而对于纯粹的 expression 使用 let bindings。对于错误的 <code>let firstName = getLine</code> ，我们只不过是把 <code>getLine</code> 这个 I/O actions给了一个不同的名字罢了。最后还是要用 <code>&lt;-</code> 将结果取出。
</p>

<p>
现在我们来写一个会一行一行不断地读取输入，并将读进来的字反过来输出到屏幕上的程序。程序会在输入空白行的时候停止。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    line <span style="color: #8787d7;">&lt;-</span> getLine
    <span style="color: #268bd2; font-weight: bold;">if</span> null line
        <span style="color: #268bd2; font-weight: bold;">then</span> return <span style="color: #268bd2; font-weight: bold;">()</span>
        <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">do</span>
            putStrLn <span style="color: #8787d7;">$</span> reverseWords line
            main

<span style="color: #d75fd7; font-weight: bold;">reverseWords</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #d75fd7; font-weight: bold;">reverseWords</span> <span style="color: #8787d7;">=</span> unwords <span style="color: #8787d7;">.</span> map reverse <span style="color: #8787d7;">.</span> words
</pre>
</div>

<p>
在分析这段程序前，你可以执行看看来感受一下程序的运行。
</p>

<p>
首先，我们来看一下 <code>reverseWords</code> 。他不过是一个普通的函数，假如接受了个字串
 =​"hey there man"​= ，他会先调用 <code>words</code> 来产生一个字的串列 <code>["hey", "there",
    "man"]</code> 。然后用 <code>reverse</code> 来 map 整个串列，得到 <code>["yeh", "ereht", "nam"]</code>
 ，接着用 <code>unwords</code> 来得到最终的结果 =​"yeh ereht nam"​= 。这些用函数合成来简洁的表达。如果没有用函数合成，那就会写成丑丑的样子 <code>reverseWords st = unwords
    (map reverse (words st))</code>
</p>

<p>
那 <code>main</code> 又是怎么一回事呢？首先，我们用 <code>getLine</code> 从终端读取了一行，并把这行输入取名叫 <code>line</code> 。然后接着一个条件式expression。记住，在 Haskell 中 if 永远要伴随一个 else，这样每个expression 才会有值。当 if 的条件是 true（也就是输入了一个空白行），我们便执行一个 I/O action，如果 if 的条件是false，那 else 底下的 I/O action 被执行。这也就是说当 if 在一个 I/O do block 中的时候，长的样子是 <code>if condition then I/O action else I/O action</code> 。
</p>

<p>
我们首先来看一下在 else 中发生了什么事。由于我们在 else 中只能有一个 I/O
action，所以我们用 do 来将两个 I/O actions 绑成一个，你可以写成这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">do</span>
    putStrLn <span style="color: #8787d7;">$</span> reverseWords line
    main<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
这样可以明显看到整个 do block 可以看作一个 I/O action，只是比较丑。但总之，在
do block 里面，我们依序调用了 <code>getLine</code> 以及 <code>reverseWords</code> ，在那之后，我们递归调用了 <code>main</code> 。由于 main 也是一个I/O action，所以这不会造成任何问题。调用 <code>main</code> 也就代表我们回到程序的起点。
</p>

<p>
那假如 <code>null line</code> 的结果是 true 呢？也就是说 then的区块被执行。我们看一下区块里面有 <code>then return ()</code> 。如果你是从 C、Java或 Python 过来的，你可能会认为
<code>return</code> 不过是作一样的事情便跳过这一段。但很重要的： <code>return</code> 在 Hakell里面的意义跟其他语言的 <code>return</code> 完全不同！他们有相同的样貌，造成了许多人搞错，但确实他们是不一样的。在命令式语言中， <code>return</code> 通常结束 method 或 subroutine
的执行，并且回传某个值给调用者。在 Haskell中，他的意义则是利用某个 pure value
造出 I/O action。用之前盒子的比喻来说，就是将一个 value 装进箱子里面。产生出的I/O action 并没有作任何事，只不过将 value 包起来而已。所以在 I/O的情况下来说，=return "haha"​= 的型态是 <code>IO String</code> 。将 pure value 包成I/O action 有什么实质意义呢？为什么要弄成 <code>IO</code> 包起来的值？这是因为我们一定要在 else 中摆上某些 I/O action，所以我们才用 <code>return ()</code> 做了一个没作什么事情的 I/O action。
</p>

<p>
在 I/O do block 中放一个 <code>return</code> 并不会结束执行。像下面这个程序会执行到底。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    return <span style="color: #268bd2; font-weight: bold;">()</span>
    return <span style="color: #2aa198;">"HAHAHA"</span>
    line <span style="color: #8787d7;">&lt;-</span> getLine
    return <span style="color: #2aa198;">"BLAH BLAH BLAH"</span>
    return <span style="color: #d75fd7;">4</span>
    putStrLn line
</pre>
</div>

<p>
所有在程序中的 <code>return</code> 都是将 value 包成 I/O actions，而且由于我们没有将他们绑定名称，所以这些结果都被忽略。我们能用 <code>&lt;-</code> 与 <code>return</code> 来达到绑定名称的目的。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    a <span style="color: #8787d7;">&lt;-</span> return <span style="color: #2aa198;">"hell"</span>
    b <span style="color: #8787d7;">&lt;-</span> return <span style="color: #2aa198;">"yeah!"</span>
    putStrLn <span style="color: #8787d7;">$</span> a <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" "</span> <span style="color: #8787d7;">++</span> b
</pre>
</div>

<p>
可以看到 <code>return</code> 与 <code>&lt;-</code> 作用相反。 <code>return</code> 把 value 装进盒子中，而 <code>&lt;-</code> 将
value从盒子拿出来，并绑定一个名称。不过这么做是有些多余，因为你可以用 let
bindings 来绑定
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2; font-weight: bold;">let</span> a <span style="color: #8787d7;">=</span> <span style="color: #2aa198;">"hell"</span>
        b <span style="color: #8787d7;">=</span> <span style="color: #2aa198;">"yeah"</span>
    putStrLn <span style="color: #8787d7;">$</span> a <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" "</span> <span style="color: #8787d7;">++</span> b
</pre>
</div>

<p>
在 I/O do block 中需要 <code>return</code> 的原因大致上有两个：一个是我们需要一个什么事都不做的 I/O action，或是我们不希望这个 do block 形成的 I/O action 的结果值是这个block 中的最后一个 I/O action，我们希望有一个不同的结果值，所以我们用
<code>return</code> 来作一个 I/O action 包了我们想要的结果放在 do block 的最后。
</p>

<p>
在我们接下去讲文件之前，让我们来看看有哪些实用的函数可以处理 I/O。
</p>

<p>
 <code>putStr</code> 跟 <code>putStrLn</code> 几乎一模一样，都是接受一个字串当作参数，并回传一个
I/O action打印出字串到终端上，只差在 <code>putStrLn</code> 会换行而 <code>putStr</code> 不会罢了。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> putStr <span style="color: #2aa198;">"Hey, "</span>
          putStr <span style="color: #2aa198;">"I'm "</span>
          putStrLn <span style="color: #2aa198;">"Andy!"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell putstr_test<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">Hey</span>, <span style="color: #df005f; font-weight: bold;">I'm</span> <span style="color: #df005f; font-weight: bold;">Andy</span><span style="color: #8787d7;">!</span>
</pre>
</div>

<p>
他的 type signature 是 <code>putStr :: String -&gt; IO ()</code> ，所以是一个包在 I/O
action 中的 unit。也就是空值，没有办法绑定他。
</p>

<p>
<code>putChar</code> 接受一个字符，并回传一个 I/O action 将他打印到终端上。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> putChar <span style="color: #2aa198;">'t'</span>
          putChar <span style="color: #2aa198;">'e'</span>
          putChar <span style="color: #2aa198;">'h'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell putchar_test<span style="color: #8787d7;">.</span>hs
teh
</pre>
</div>

<p>
 <code>putStr</code> 实际上就是 <code>putChar</code> 递归定义出来的。 <code>putStr</code> 的边界条件是空字串，所以假设我们打印一个空字串，那他只是回传一个什么都不做的I/O action，像
<code>return ()</code> 。如果打印的不是空字串，那就先用 <code>putChar</code> 打印出字串的第一个字符，然后再用 <code>putStr</code> 打印出字串剩下部份。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">putStr</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">putStr</span> <span style="color: #268bd2; font-weight: bold;">[]</span> <span style="color: #8787d7;">=</span> return <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">putStr</span> <span style="color: #268bd2;">(</span>x<span style="color: #df005f; font-weight: bold;">:</span>xs<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    putChar x
    putStr xs
</pre>
</div>

<p>
看看我们如何在 I/O 中使用递归，就像我们在 pure code中所做的一样。先定义一个边界条件，然后再思考剩下如何作。
</p>

<p>
 <code>print</code> 接受任何是 <code>Show</code> typeclass 的 instance的型态的值，这代表我们知道如何用字串表示他，调用 <code>show</code> 来将值变成字串然后将其输出到终端上。基本上，他就是=putStrLn . show= 。首先调用 <code>show</code> 然后把结果喂给 <code>putStrLn</code> ，回传一个I/O
action 打印出我们的值。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> print <span style="color: #df005f; font-weight: bold;">True</span>
          print <span style="color: #d75fd7;">2</span>
          print <span style="color: #2aa198;">"haha"</span>
          print <span style="color: #d75fd7;">3.2</span>
          print <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell print_test<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">True</span>
<span style="color: #d75fd7;">2</span>
<span style="color: #2aa198;">"haha"</span>
<span style="color: #d75fd7;">3.2</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
就像你看到的，这是个很方便的函数。还记得我们提到 I/O actions 只有在 <code>main</code> 中才会被执行以及在 GHCI 中运算的事情吗？当我们用键盘打了些值，像 <code>3</code> 或
<code>[1,2,3]</code> 并按下 Enter，GHCI 实际上就是用了 <code>print</code> 来将这些值输出到终端。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #d75fd7;">3</span>
<span style="color: #d75fd7;">3</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> print <span style="color: #d75fd7;">3</span>
<span style="color: #d75fd7;">3</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> map <span style="color: #268bd2;">(</span><span style="color: #8787d7;">++</span><span style="color: #2aa198;">"!"</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"hey"</span>,<span style="color: #2aa198;">"ho"</span>,<span style="color: #2aa198;">"woo"</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #2aa198;">"hey!"</span>,<span style="color: #2aa198;">"ho!"</span>,<span style="color: #2aa198;">"woo!"</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> print <span style="color: #268bd2;">(</span>map <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">++</span><span style="color: #2aa198;">"!"</span><span style="color: #d75fd7;">)</span> <span style="color: #d75fd7;">[</span><span style="color: #2aa198;">"hey"</span>, <span style="color: #2aa198;">"ho"</span>, <span style="color: #2aa198;">"woo"</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">[</span><span style="color: #2aa198;">"hey!"</span>,<span style="color: #2aa198;">"ho!"</span>,<span style="color: #2aa198;">"woo!"</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
当我们需要打印出字串，我们会用 <code>putStrLn</code> ，因为我们不想要周围有引号，但对于输出值来说， <code>print</code> 才是最常用的。
</p>

<p>
<code>getChar</code> 是一个从输入读进一个字符的 I/O action，因此他的 type signature是
<code>getChar :: IO Char</code> ，代表一个 I/O action 的结果是 <code>Char</code> 。注意由于缓冲区的关系，只有当 Enter被按下的时候才会触发读取字符的行为。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    c <span style="color: #8787d7;">&lt;-</span> getChar
    <span style="color: #268bd2; font-weight: bold;">if</span> c <span style="color: #8787d7;">/=</span> <span style="color: #2aa198;">' '</span>
        <span style="color: #268bd2; font-weight: bold;">then</span> <span style="color: #268bd2; font-weight: bold;">do</span>
            putChar c
            main
        <span style="color: #268bd2; font-weight: bold;">else</span> return <span style="color: #268bd2; font-weight: bold;">()</span>
</pre>
</div>

<p>
这程序看起来像是读取一个字符并检查他是否为一个空白。如果是的话便停止，如果不是的话便打印到终端上并重复之前的行为。在某种程度上来说也不能说错，只是结果不如你预期而已。来看看结果吧。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell getchar_test<span style="color: #8787d7;">.</span>hs
<span style="color: #d75fd7; font-weight: bold;">hello</span> sir
hello
</pre>
</div>

<p>
上面的第二行是输入。我们输入了 <code>hello sir</code> 并按下了Enter。由于缓冲区的关系，程序是在我们按了 Enter后才执行而不是在某个输入字符的时候。一旦我们按下了Enter，那他就把我们直到目前输入的一次做完。
</p>

<p>
 <code>when</code> 这函数可以在 <code>Control.Monad</code> 中找到他 (你必须 <code>import Contorl.Monad</code>
才能使用他)。他在一个 do block中看起来就像一个控制流程的statement，但实际上他的确是一个普通的函数。他接受一个 boolean 值跟一个I/O action。如果 boolean 值是 <code>True</code> ，便回传我们传给他的 I/O action。如果 boolean 值是 <code>False</code> ，便回传
<code>return ()</code> ，即什么都不做的I/O action。我们接下来用 <code>when</code> 来改写我们之前的程序。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    c <span style="color: #8787d7;">&lt;-</span> getChar
    when <span style="color: #268bd2;">(</span>c <span style="color: #8787d7;">/=</span> <span style="color: #2aa198;">' '</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">$</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        putChar c
        main
</pre>
</div>

<p>
就像你看到的，他可以将 <code>if something then do some I/O action else return ()</code>
这样的模式封装起来。
</p>

<p>
 <code>sequence</code> 接受一串 I/O action，并回传一个会依序执行他们的 I/O action。运算的结果是包在一个 I/O action 的一连串 I/O action的运算结果。他的 type
signature 是 <code>sequence :: [IO a] -&gt; IO [a]</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    a <span style="color: #8787d7;">&lt;-</span> getLine
    b <span style="color: #8787d7;">&lt;-</span> getLine
    c <span style="color: #8787d7;">&lt;-</span> getLine
    print <span style="color: #268bd2;">[</span>a,b,c<span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
其实可以写成
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    rs <span style="color: #8787d7;">&lt;-</span> sequence <span style="color: #268bd2;">[</span>getLine, getLine, getLine<span style="color: #268bd2;">]</span>
    print rs
</pre>
</div>

<p>
所以 <code>sequence [getLine, getLine, getLine]</code> 作成了一个执行 <code>getLine</code> 三次的
I/O action。如果我们对他绑定一个名字，结果便是这串结果的串列。也就是说，三个用户输入的东西组成的串列。
</p>

<p>
一个常见的使用方式是我们将 <code>print</code> 或 <code>putStrLn</code> 之类的函数 map到串列上。
<code>map print [1,2,3,4]</code> 这个动作并不会产生一个 I/O action，而是一串 I/O action，就像是 <code>[print 1, print 2, print 3, print 4]</code> 。如果我们将一串 I/O action变成一个 I/O action，我们必须用 <code>sequence</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> sequence <span style="color: #268bd2;">(</span>map print <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span>,<span style="color: #d75fd7;">5</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">3</span>
<span style="color: #d75fd7;">4</span>
<span style="color: #d75fd7;">5</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7; font-weight: bold;">()</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
那 <code>[(),(),(),(),()]</code> 是怎么回事？当我们在 GHCI 中运算 I/O action，他会被执行并把结果打印出来，唯一例外是结果是 <code>()</code> 的时候不会被打印出。这也是为什么
<code>putStrLn "hehe"​</code> 在 GHCI 中只会打印出 <code>hehe</code> （因为 <code>putStrLn "hehe"​</code> 的结果是 <code>()</code> ）。但当我们使用 <code>getLine</code> 时，由于 <code>getLine</code> 的型态是 <code>IO String</code> ，所以结果会被打印出来。
</p>

<p>
由于对一个串列 map 一个回传 I/O action 的函数，然后再 sequence他这个动作太常用了。所以有一些函数在函式库中 <code>mapM</code> 跟 <code>mapM_</code> 。 <code>mapM</code> 接受一个函数跟一个串列，将对串列用函数 map 然后 sequence 结果。 <code>mapM_</code> 也作同样的事，只是他把运算的结果丢掉而已。在我们不关心 I/O action结果的情况下， <code>mapM_</code> 是最常被使用的。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM print <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">3</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7; font-weight: bold;">()</span>,<span style="color: #d75fd7; font-weight: bold;">()</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> mapM_ print <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7;">1</span>
<span style="color: #d75fd7;">2</span>
<span style="color: #d75fd7;">3</span>
</pre>
</div>

<p>
<code>forever</code> 接受一个 I/O action 并回传一个永远作同一件事的 I/O action。你可以在 <code>Control.Monad</code> 中找到他。下面的程序会不断地要用户输入些东西，并把输入的东西转成大写输出到屏幕上。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.Char</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> forever <span style="color: #8787d7;">$</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    putStr <span style="color: #2aa198;">"Give me some input: "</span>
    l <span style="color: #8787d7;">&lt;-</span> getLine
    putStrLn <span style="color: #8787d7;">$</span> map toUpper l
</pre>
</div>

<p>
在 <code>Control.Monad</code> 中的 <code>forM</code> 跟 <code>mapM</code> 的作用一样，只是参数的顺序相反而已。第一个参数是串列，而第二个则是函数。这有什么用？在一些有趣的情况下还是有用的：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    colors <span style="color: #8787d7;">&lt;-</span> forM <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">2</span>,<span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">4</span><span style="color: #268bd2;">]</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>a <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"Which color do you associate with the number "</span> <span style="color: #8787d7;">++</span> show a <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">"?"</span>
        color <span style="color: #8787d7;">&lt;-</span> getLine
        return color<span style="color: #268bd2;">)</span>
    putStrLn <span style="color: #2aa198;">"The colors that you associate with 1, 2, 3 and 4 are: "</span>
    mapM putStrLn colors
</pre>
</div>

<p>
 <code>(\a -&gt; do ...)</code> 是接受一个数字并回传一个 I/O action的函数。我们必须用括号括住他，不然 lambda 会贪心 match的策略会把最后两个 I/O action 也算进去。注意我们在 do block 里面 <code>return color</code> 。我们那么作是让 do block的结果是我们选的颜色。实际上我们并不需那么作，因为 <code>getLine</code> 已经达到我们的目的。先 <code>color &lt;-
   getLine</code> 再 <code>return color</code> 只不过是把值取出再包起来，其实是跟 <code>getLine</code> 效果相当。 <code>forM</code> 产生一个I/O action，我们把结果绑定到 <code>colors</code> 这名称。 <code>colors</code>
是一个普通包含字串的串列。最后，我们用 <code>mapM putStrLn colors</code> 打印出所有颜色。
</p>

<p>
你可以把 <code>forM</code> 的意思想成将串列中的每个元素作成一个 I/O action。至于每个 I/O
action实际作什么就要看原本的元素是什么。然后，执行这些 I/O action并将结果绑定到某个名称上。或是直接将结果忽略掉。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell from_test<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">Which</span> color <span style="color: #268bd2; font-weight: bold;">do</span> you associate with the number <span style="color: #d75fd7;">1</span><span style="color: #8787d7;">?</span>
white
<span style="color: #df005f; font-weight: bold;">Which</span> color <span style="color: #268bd2; font-weight: bold;">do</span> you associate with the number <span style="color: #d75fd7;">2</span><span style="color: #8787d7;">?</span>
blue
<span style="color: #df005f; font-weight: bold;">Which</span> color <span style="color: #268bd2; font-weight: bold;">do</span> you associate with the number <span style="color: #d75fd7;">3</span><span style="color: #8787d7;">?</span>
red
<span style="color: #df005f; font-weight: bold;">Which</span> color <span style="color: #268bd2; font-weight: bold;">do</span> you associate with the number <span style="color: #d75fd7;">4</span><span style="color: #8787d7;">?</span>
orange
<span style="color: #df005f; font-weight: bold;">The</span> colors that you associate with <span style="color: #d75fd7;">1</span>, <span style="color: #d75fd7;">2</span>, <span style="color: #d75fd7;">3</span> and <span style="color: #d75fd7;">4</span> are<span style="color: #df005f; font-weight: bold;">:</span>
white
blue
red
orange
</pre>
</div>

<p>
其实我们也不是一定要用到 <code>forM</code> ，只是用了 <code>forM</code> 程序会比较容易理解。正常来讲是我们需要在 map 跟 sequence 的时候定义 I/O action 的时候使用 <code>forM</code> ，同样地，我们也可以将最后一行写成 <code>forM colors putStrLn</code> 。
</p>

<p>
在这一节，我们学会了输入与输出的基础。我们也了解了什么是 I/O action，他们是如何帮助我们达成输入与输出的目的。这边重复一遍，I/O action跟其他 Haskell 中的
value没有两样。我们能够把他当参数传给函式，或是函式回传 I/O action。他们特别之处在于当他们是写在 <code>main</code> 里面或 GHCI里面的时候，他们会被执行，也就是实际输出到你屏幕或输出音效的时候。每个I/O action 也能包着一个从真实世界拿回来的值。
</p>

<p>
不要把像是 =putStrLn=的函式想成接受字串并输出到屏幕。要想成一个函式接受字串并回传一个 I/O action。当 I/O action 被执行的时候，会漂亮地打印出你想要的东西。
</p>
</div>
</div>

<div id="outline-container-orga90af47" class="outline-3">
<h3 id="orga90af47"><span class="section-number-3">1.2</span> 文件与字符流</h3>
<div class="outline-text-3" id="text-1-2">

<div class="figure">
<p><img src="streams.png" alt="streams.png">
</p>
</div>

<p>
 <code>getChar</code> 是一个读取单一字符的 I/O action。 <code>getLine</code> 是一个读取一行的I/O
action。这是两个非常直觉的函式，多数编程语言也有类似这两个函式的statement 或
function。但现在我们来看看 /getContents/。 <code>getContents</code> 是一个从标准输入读取直到 end-of-file 字符的 I/O action。他的型态是 <code>getContents :: IO String</code> 。最酷的是 <code>getContents</code> 是惰性 I/O (Lazy I/O)。当我们写了 <code>foo &lt;- getContents</code>
，他并不会马上读取所有输入，将他们存在 memory里面。他只有当你真的需要输入数据的时候才会读取。
</p>

<p>
当我们需要重导一个程序的输出到另一个程序的输入时， <code>getContents</code> 非常有用。假设我们有下面一个文本档：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #df005f; font-weight: bold;">I'm</span> a lil' teapot
<span style="color: #df005f; font-weight: bold;">What's</span> with that airplane food, huh<span style="color: #8787d7;">?</span>
<span style="color: #df005f; font-weight: bold;">It's</span> so small, tasteless
</pre>
</div>

<p>
还记得我们介绍 <code>forever</code> 时写的小程序吗？会把所有输入的东西转成大写的那一个。为了防止你忘记了，这边再重复一遍。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.Char</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> forever <span style="color: #8787d7;">$</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    putStr <span style="color: #2aa198;">"Give me some input: "</span>
    l <span style="color: #8787d7;">&lt;-</span> getLine
    putStrLn <span style="color: #8787d7;">$</span> map toUpper l
</pre>
</div>

<p>
将我们的程序存成 <code>capslocker.hs</code> 然后编译他。然后用 Unix 的 Pipe将文本档喂给我们的程序。我们使用的是 GNU 的cat，会将指定的文件输出到屏幕。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> ghc <span style="color: #008787;">--</span><span style="color: #008787;">make capslocker</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span> <span style="color: #268bd2; font-weight: bold;">of</span> <span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Compiling</span> <span style="color: #df005f; font-weight: bold;">Main</span>             <span style="color: #268bd2;">(</span> capslocker<span style="color: #8787d7;">.</span>hs, capslocker<span style="color: #8787d7;">.</span>o <span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Linking</span> capslocker <span style="color: #8787d7;">...</span>
<span style="color: #8787d7;">$</span> cat haiku<span style="color: #8787d7;">.</span>txt
<span style="color: #df005f; font-weight: bold;">I'm</span> a lil' teapot
<span style="color: #df005f; font-weight: bold;">What's</span> with that airplane food, huh<span style="color: #8787d7;">?</span>
<span style="color: #df005f; font-weight: bold;">It's</span> so small, tasteless
<span style="color: #8787d7;">$</span> cat haiku<span style="color: #8787d7;">.</span>txt <span style="color: #8787d7;">|</span> <span style="color: #8787d7;">./</span>capslocker
<span style="color: #df005f; font-weight: bold;">I'M</span> <span style="color: #df005f; font-weight: bold;">A</span> <span style="color: #df005f; font-weight: bold;">LIL'</span> <span style="color: #df005f; font-weight: bold;">TEAPOT</span>
<span style="color: #df005f; font-weight: bold;">WHAT'S</span> <span style="color: #df005f; font-weight: bold;">WITH</span> <span style="color: #df005f; font-weight: bold;">THAT</span> <span style="color: #df005f; font-weight: bold;">AIRPLANE</span> <span style="color: #df005f; font-weight: bold;">FOOD</span>, <span style="color: #df005f; font-weight: bold;">HUH</span><span style="color: #8787d7;">?</span>
<span style="color: #df005f; font-weight: bold;">IT'S</span> <span style="color: #df005f; font-weight: bold;">SO</span> <span style="color: #df005f; font-weight: bold;">SMALL</span>, <span style="color: #df005f; font-weight: bold;">TASTELESS</span>
capslocker <span style="color: #d75fd7; font-weight: bold;">&lt;</span>stdin<span style="color: #8787d7;">&gt;:</span> hGetLine<span style="color: #df005f; font-weight: bold;">:</span> end <span style="color: #268bd2; font-weight: bold;">of</span> file
</pre>
</div>

<p>
就如你看到的，我们是用 <code>|</code> 这符号来将某个程序的输出 piping到另一个程序的输入。我们做的事相当于 run 我们的 capslocker，然后将 haiku的内容用键盘打到终端上，最后再按 Ctrl-D 来代表 end-of-file。这就像执行cat haiku.txt 后大喊，嘿，不要把内容打印到终端上，把内容塞到capslocker！
</p>

<p>
我们用 <code>forever</code> 在做的事基本上就是将输入经过转换后变成输出。用 <code>getContents</code>
的话可以让我们的程序更加精炼。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.Char</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    contents <span style="color: #8787d7;">&lt;-</span> getContents
    putStr <span style="color: #268bd2;">(</span>map toUpper contents<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们将 <code>getContents</code> 取回的字串绑定到 <code>contents</code> 。然后用 <code>toUpper</code> map到整个字串后打印到终端上。记住字串基本上就是一串惰性的串列 (list)，同时
<code>getContents</code> 也是惰性I/O，他不会一口气读入内容然后将内容存在内存中。实际上，他会一行一行读入并输出大写的版本，这是因为输出才是真的需要输入的数据的时候。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> cat haiku<span style="color: #8787d7;">.</span>txt <span style="color: #8787d7;">|</span> <span style="color: #8787d7;">./</span>capslocker
<span style="color: #df005f; font-weight: bold;">I'M</span> <span style="color: #df005f; font-weight: bold;">A</span> <span style="color: #df005f; font-weight: bold;">LIL'</span> <span style="color: #df005f; font-weight: bold;">TEAPOT</span>
<span style="color: #df005f; font-weight: bold;">WHAT'S</span> <span style="color: #df005f; font-weight: bold;">WITH</span> <span style="color: #df005f; font-weight: bold;">THAT</span> <span style="color: #df005f; font-weight: bold;">AIRPLAN</span> <span style="color: #df005f; font-weight: bold;">FOOD</span>, <span style="color: #df005f; font-weight: bold;">HUH</span><span style="color: #8787d7;">?</span>
<span style="color: #df005f; font-weight: bold;">IT'S</span> <span style="color: #df005f; font-weight: bold;">SO</span> <span style="color: #df005f; font-weight: bold;">SMALL</span>, <span style="color: #df005f; font-weight: bold;">TASTELESS</span>
</pre>
</div>

<p>
很好，程序运作正常。假如我们执行 capslocker 然后自己打几行字呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>capslocker
<span style="color: #d75fd7; font-weight: bold;">hey</span> ho
<span style="color: #df005f; font-weight: bold;">HEY</span> <span style="color: #df005f; font-weight: bold;">HO</span>
<span style="color: #d75fd7; font-weight: bold;">lets</span> go
<span style="color: #df005f; font-weight: bold;">LETS</span> <span style="color: #df005f; font-weight: bold;">GO</span>
</pre>
</div>

<p>
按下 Ctrl-D来离开环境。就像你看到的，程序是一行一行将我们的输入打印出来。当
 <code>getContent</code> 的结果被绑定到 <code>contents</code> 的时候，他不是被表示成在内存中的一个字串，反而比较像是他有一天会是字串的一个承诺。当我们将 <code>toUpper</code> map 到
 <code>contents</code> 的时候，便也是一个函数被承诺将会被 map到内容上。最后 <code>putStr</code> 则要求先前的承诺说，给我一行大写的字串吧。实际上还没有任何一行被取出，所以便跟
 <code>contents</code> 说，不如从终端那边取出些字串吧。这才是 <code>getContents</code> 真正从终端读入一行并把这一行交给程序的时候。程序便将这一行用 <code>toUpper</code> 处理并交给
 <code>putStr</code> ，=putStr= 则打印出他。之后 <code>putStr</code> 再说：我需要下一行。整个步骤便再重复一次，直到读到 end-of-file 为止。
</p>

<p>
接着我们来写个程序，读取输入，并只打印出少于十个字符的行。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    contents <span style="color: #8787d7;">&lt;-</span> getContents
    putStr <span style="color: #268bd2;">(</span>shortLinesOnly contents<span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">shortLinesOnly</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #d75fd7; font-weight: bold;">shortLinesOnly</span> input <span style="color: #8787d7;">=</span>
    <span style="color: #268bd2; font-weight: bold;">let</span> allLines <span style="color: #8787d7;">=</span> lines input
        shortLines <span style="color: #8787d7;">=</span> filter <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>line <span style="color: #8787d7;">-&gt;</span> length line <span style="color: #8787d7;">&lt;</span> <span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span> allLines
        result <span style="color: #8787d7;">=</span> unlines shortLines
    <span style="color: #268bd2; font-weight: bold;">in</span> result
</pre>
</div>

<p>
我们把 I/O部份的代码弄得很短。由于程序的行为是接某些输入，作些处理然后输出。我们可以把他想成读取输入，调用一个函数，然后把函数的结果输出。
</p>

<p>
<code>shortLinesOnly</code> 的行为是这样：拿到一个字串，像是
=​"short\nlooooooooooooooong\nshort again"​= 。这字串有三行，前后两行比较短，中间一行很常。他用 <code>lines</code> 把字串分成 <code>["short", "looooooooooooooong",
    "short again"]</code> ，并把结果绑定成 <code>allLines</code> 。然后过滤这些字串，只有少于十个字符的留下，=["short", "short again"]= ，最后用 <code>unlines</code> 把这些字串用换行接起来，形成 =​"short\nshort again"​=
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">i'm</span> short
<span style="color: #d75fd7; font-weight: bold;">so</span> am i
<span style="color: #d75fd7; font-weight: bold;">i</span> am a loooooooooong line<span style="color: #8787d7;">!!!</span>
<span style="color: #d75fd7; font-weight: bold;">yeah</span> i'm long so what hahahaha<span style="color: #8787d7;">!!!!!!</span>
<span style="color: #d75fd7; font-weight: bold;">short</span> line
loooooooooooooooooooooooooooong
short
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> ghc <span style="color: #008787;">--</span><span style="color: #008787;">make shortlinesonly</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">1</span> <span style="color: #268bd2; font-weight: bold;">of</span> <span style="color: #d75fd7;">1</span><span style="color: #268bd2;">]</span> <span style="color: #df005f; font-weight: bold;">Compiling</span> <span style="color: #df005f; font-weight: bold;">Main</span>             <span style="color: #268bd2;">(</span> shortlinesonly<span style="color: #8787d7;">.</span>hs, shortlinesonly<span style="color: #8787d7;">.</span>o <span style="color: #268bd2;">)</span>
<span style="color: #df005f; font-weight: bold;">Linking</span> shortlinesonly <span style="color: #8787d7;">...</span>
<span style="color: #8787d7;">$</span> cat shortlines<span style="color: #8787d7;">.</span>txt <span style="color: #8787d7;">|</span> <span style="color: #8787d7;">./</span>shortlinesonly
<span style="color: #d75fd7; font-weight: bold;">i'm</span> short
<span style="color: #d75fd7; font-weight: bold;">so</span> am i
short
</pre>
</div>

<p>
我们把 shortlines.txt 的内容经由 pipe 送给shortlinesonly，结果就如你看到，我们只有得到比较短的行。
</p>

<p>
从输入那一些字串，经由一些转换然后输出这样的模式实在太常用了。常用到甚至建立了一个函数叫*interact*。 <code>interact</code> 接受一个 <code>String -&gt; String</code> 的函数，并回传一个I/O action。那个 I/O action会读取一些输入，调用提供的函数，然后把函数的结果打印出来。所以我们的程序可以改写成这样。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> interact shortLinesOnly

<span style="color: #d75fd7; font-weight: bold;">shortLinesOnly</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">String</span>
<span style="color: #d75fd7; font-weight: bold;">shortLinesOnly</span> input <span style="color: #8787d7;">=</span>
    <span style="color: #268bd2; font-weight: bold;">let</span> allLines <span style="color: #8787d7;">=</span> lines input
        shortLines <span style="color: #8787d7;">=</span> filter <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>line <span style="color: #8787d7;">-&gt;</span> length line <span style="color: #8787d7;">&lt;</span> <span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span> allLines
        result <span style="color: #8787d7;">=</span> unlines shortLines
    <span style="color: #268bd2; font-weight: bold;">in</span> result
</pre>
</div>

<p>
我们甚至可以再让代码更短一些，像这样
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> interact <span style="color: #8787d7;">$</span> unlines <span style="color: #8787d7;">.</span> filter <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">(</span><span style="color: #8787d7;">&lt;</span><span style="color: #d75fd7;">10</span><span style="color: #d75fd7;">)</span> <span style="color: #8787d7;">.</span> length<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">.</span> lines
</pre>
</div>

<p>
看吧，我们让程序缩到只剩一行了，很酷吧！
</p>

<p>
能应用 <code>interact</code> 的情况有几种，像是从输入 pipe读进一些内容，然后丢出一些结果的程序；或是从用户获取一行一行的输入，然后丢回根据那一行运算的结果，再拿取另一行。这两者的差别主要是取决于用户使用他们的方式。
</p>

<p>
我们再来写另一个程序，它不断地读取一行行并告诉我们那一行字串是不是一个回文本串(palindrome)。我们当然可以用 <code>getLine</code> 读取一行然后再调用 <code>main</code> 作同样的事。不过同样的事情可以用 <code>interact</code> 更简洁地达成。当使用 <code>interact</code> 的时候，想像你是将输入经有某些转换成输出。在这个情况当中，我们要将每一行输入转换成
=​"palindrome"​= 或 =​"not a palindrome"​= 。所以我们必须写一个函数将
=​"elephant\nABCBA\nwhatever"​= 转换成 <code>not a palindrome\npalindrome\nnot a
   palindrome"​</code> 。来动手吧！
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">respondPalindromes</span> contents <span style="color: #8787d7;">=</span> unlines <span style="color: #268bd2;">(</span>map <span style="color: #d75fd7;">(</span><span style="color: #8787d7;">\</span>xs <span style="color: #8787d7;">-&gt;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> isPalindrome xs <span style="color: #268bd2; font-weight: bold;">then</span> <span style="color: #2aa198;">"palindrome"</span> <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #2aa198;">"not a palindrome"</span><span style="color: #d75fd7;">)</span> <span style="color: #d75fd7;">(</span>lines contents<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #268bd2; font-weight: bold;">where</span> isPalindrome xs <span style="color: #8787d7;">=</span> xs <span style="color: #8787d7;">==</span> reverse xs
</pre>
</div>

<p>
再来将程序改写成 point-free 的形式
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">respondPalindromes</span> <span style="color: #8787d7;">=</span> unlines <span style="color: #8787d7;">.</span> map <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>xs <span style="color: #8787d7;">-&gt;</span>
    <span style="color: #268bd2; font-weight: bold;">if</span> isPalindrome xs <span style="color: #268bd2; font-weight: bold;">then</span> <span style="color: #2aa198;">"palindrome"</span> <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #2aa198;">"not a palindrome"</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">.</span> lines
        <span style="color: #268bd2; font-weight: bold;">where</span> isPalindrome xs <span style="color: #8787d7;">=</span> xs <span style="color: #8787d7;">==</span> reverse xs
</pre>
</div>

<p>
很直觉吧！首先将 =​"elephant\nABCBA\nwhatever"​= 变成 <code>["elephant", "ABCBA",
   "whatever"]</code> 然后将一个 lambda 函数 map它， <code>["not a palindrome",
   "palindrome", "not a palindrome"]</code> 然后用 <code>unlines</code> 变成一行字串。接着
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> interact respondPalindromes
</pre>
</div>

<p>
来测试一下吧。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell palindrome<span style="color: #8787d7;">.</span>hs
hehe
<span style="color: #d75fd7; font-weight: bold;">not</span> a palindrome
<span style="color: #df005f; font-weight: bold;">ABCBA</span>
palindrome
cookie
<span style="color: #d75fd7; font-weight: bold;">not</span> a palindrome
</pre>
</div>

<p>
即使我们的程序是把一大把字串转换成另一个，其实他表现得好像我们是一行一行做的。这是因为Haskell是惰性的，程序想要打印出第一行结果时，他必须要先有第一行输入。所以一旦我们给了第一行输入，他便打印出第一行结果。我们用end-of-line 字符来结束程序。
</p>

<p>
我们也可以用 pipe 的方式将输入喂给程序。假设我们有这样一个文件。
</p>

<div class="org-src-container">
<pre class="src src-haskell">dogaroo
radar
rotor
madam
</pre>
</div>

<p>
将他存为 =words.txt=，将他喂给程序后得到的结果
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> cat words<span style="color: #8787d7;">.</span>txt <span style="color: #8787d7;">|</span> runhaskell palindromes<span style="color: #8787d7;">.</span>hs
<span style="color: #d75fd7; font-weight: bold;">not</span> a palindrome
palindrome
palindrome
palindrome
</pre>
</div>

<p>
再一次地提醒，我们得到的结果跟我们自己一个一个字打进输入的内容是一样的。我们看不到 <code>palindrome.hs</code> 输入的内容是因为内容来自于文件。
</p>

<p>
你应该大致了解 Lazy I/O是如何运作，并能善用他的优点。他可以从输入转换成输出的角度方向思考。由于Lazy I/O，没有输入在被用到之前是真的被读入。
</p>

<p>
到目前为止，我们的示范都是从终端读取某些东西或是打印出某些东西到终端。但如果我们想要读写文件呢？其实从某个角度来说我们已经作过这件事了。我们可以把读写终端想成读写文件。只是把文件命名成 <code>stdout</code> 跟 <code>stdin</code> 而已。他们分别代表标准输出跟标准输入。我们即将看到的读写文件跟读写终端并没什么不同。
</p>

<p>
首先来写一个程序，他会开启一个叫 girlfriend.txt 的文件，文件里面有 Avril
Lavigne 的畅销名曲 Girlfriend，并将内容打印到终端上。接下来是girlfriend.txt
的内容。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #df005f; font-weight: bold;">Hey</span><span style="color: #d75fd7; font-weight: bold;">!</span> <span style="color: #df005f; font-weight: bold;">Hey</span><span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">You</span><span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">You</span><span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">I</span> don't like your girlfriend<span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">No</span> way<span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">No</span> way<span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">I</span> think you need a new one<span style="color: #8787d7;">!</span>
</pre>
</div>

<p>
这则是我们的主程序。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    handle <span style="color: #8787d7;">&lt;-</span> openFile <span style="color: #2aa198;">"girlfriend.txt"</span> <span style="color: #df005f; font-weight: bold;">ReadMode</span>
    contents <span style="color: #8787d7;">&lt;-</span> hGetContents handle
    putStr contents
    hClose handle
</pre>
</div>

<p>
执行他后得到的结果。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell girlfriend<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">Hey</span><span style="color: #d75fd7; font-weight: bold;">!</span> <span style="color: #df005f; font-weight: bold;">Hey</span><span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">You</span><span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">You</span><span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">I</span> don't like your girlfriend<span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">No</span> way<span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">No</span> way<span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">I</span> think you need a new one<span style="color: #8787d7;">!</span>
</pre>
</div>

<p>
我们来一行行看一下程序。我们的程序用 do 把好几个 I/O action 绑在一起。在do
block 的第一行，我们注意到有一个新的函数叫 *openFile*。他的 type signature 是
<code>openFile :: FilePath -&gt; IOMode -&gt; IO Handle</code> 。他说了 <code>openFile</code> 接受一个文件路径跟一个 <code>IOMode</code> ，并回传一个 I/O action，他会打开一个文件并把文件关联到一个 handle。
</p>

<p>
<code>FilePath</code> 不过是 <code>String</code> 的 type synonym。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #df005f; font-weight: bold;">FilePath</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">String</span>
</pre>
</div>

<p>
<code>IOMode</code> 则是一个定义如下的型态
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">data</span> <span style="color: #df005f; font-weight: bold;">IOMode</span> <span style="color: #8787d7;">=</span> <span style="color: #df005f; font-weight: bold;">ReadMode</span> <span style="color: #8787d7;">|</span> <span style="color: #df005f; font-weight: bold;">WriteMode</span> <span style="color: #8787d7;">|</span> <span style="color: #df005f; font-weight: bold;">AppendMode</span> <span style="color: #8787d7;">|</span> <span style="color: #df005f; font-weight: bold;">ReadWriteMode</span>
</pre>
</div>


<div class="figure">
<p><img src="file.png" alt="file.png">
</p>
</div>

<p>
就像我们之前定义的型态，分别代表一个星期的七天。这个型态代表了我们想对打开的文件做什么。很简单吧。留意到我们的型态是 <code>IOMode</code> 而不是 <code>IO Mode</code> 。 <code>IO
   Mode</code> 代表的是一个 I/O action包含了一个型态为 <code>Mode</code> 的值，但 <code>IOMode</code> 不过是一个阳春的 enumeration。
</p>

<p>
最后，他回传一个 I/O action 会将指定的文件用指定的模式打开。如果我们将I/O
action 绑定到某个东西，我们会得到一个 <code>Handle</code> 。型态为 <code>Handle</code> 的值代表我们的文件在哪里。有了 handle我们才知道要从哪个文件读取内容。想读取文件但不将文件绑定到 handle上这样做是很蠢的。所以，我们将一个 handle 绑定到 <code>handle</code> 。
</p>

<p>
接着一行，我们看到一个叫 <b>hGetContents</b> 的函数。他接了一个 <code>Handle</code> ，所以他知道要从哪个文件读取内容并回传一个 <code>IO String</code> 。一个包含了文件内容的 I/O
action。这函数跟 <code>getContents</code> 差不多。唯一的差别是 <code>getContents</code> 会自动从标准输入读取内容（也就是终端），而 <code>hGetContents</code> 接了一个 file handle，这 file
handle告诉他读取哪个文件。除此之外，他们都是一样的。就像 <code>getContents</code> ，
<code>hGetContents</code> 不会把文件一次都拉到内存中，而是有必要才会读取。这非常酷，因为我们把=contents= 当作是整个文件般用，但他实际上不在内存中。就算这是个很大的文件，=hGetContents= 也不会塞爆你的内存，而是只有必要的时候才会读取。
</p>

<p>
要留意文件的 handle还有文件的内容两个概念的差异，在我们的程序中他们分别被绑定到 <code>handle</code> 跟 <code>contents</code> 两个名字。handle是我们拿来区分文件的依据。如果你把整个文件系统想成一本厚厚的书，每个文件分别是其中的一个章节，handle就像是书签一般标记了你现在正在阅读（或写入）哪一个章节，而内容则是章节本身。
</p>

<p>
我们使用 <code>putStr contents</code> 打印出内容到标准输出，然后我们用了*hClose*。他接受一个 handle 然后回传一个关掉文件的 I/O action。在用了 <code>openFile</code> 之后，你必须自己把文件关掉。
</p>

<p>
要达到我们目的的另一种方式是使用 *withFile*，他的 type signature 是 <code>withFile
   :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</code> 。他接受一个文件路径，一个
<code>IOMode</code> 以及一个函数，这函数则接受一个 handle 跟一个 I/O action。 <code>withFile</code>
最后回传一个会打开文件，对文件作某件事然后关掉文件的I/O action。处理的结果是包在最后的 I/O action中，这结果跟我们给的函数的回传是相同的。这听起来有些复杂，但其实很简单，特别是我们有lambda，来看看我们用 <code>withFile</code> 改写前面程序的一个范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    withFile <span style="color: #2aa198;">"girlfriend.txt"</span> <span style="color: #df005f; font-weight: bold;">ReadMode</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>handle <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">do</span>
            contents <span style="color: #8787d7;">&lt;-</span> hGetContents handle
            putStr contents<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
正如你看到的，程序跟之前的看起来很像。 <code>(\handle -&gt; ... )</code> 是一个接受handle
并回传 I/O action 的函数，他通常都是用 lambda来表示。我们需要一个回传 I/O
action的函数的理由而不是一个本身作处理并关掉文件的 I/O action，是因为这样一来那个 I/O action 不会知道他是对哪个文件在做处理。用 <code>withFile</code> 的话，
<code>withFile</code> 会打开文件并把 handle传给我们给他的函数，之后他则拿到一个 I/O
action，然后作成一个我们描述的I/O action，最后关上文件。例如我们可以这样自己作一个 <code>withFile</code> ：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">withFile'</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">FilePath</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IOMode</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Handle</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> a
<span style="color: #d75fd7; font-weight: bold;">withFile'</span> path mode f <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    handle <span style="color: #8787d7;">&lt;-</span> openFile path mode
    result <span style="color: #8787d7;">&lt;-</span> f handle
    hClose handle
    return result
</pre>
</div>


<div class="figure">
<p><img src="edd.png" alt="edd.png">
</p>
</div>

<p>
我们知道要回传的是一个 I/O action，所以我们先放一个do。首先我们打开文件，得到一个 handle。然后我们 apply <code>handle</code> 到我们的函数，并得到一个做事的 I/O
action。我们绑定那个 I/O action 到 <code>result</code> 这个名字，关上 handle 并 <code>return
   result</code> 。=return= 的作用把从 <code>f</code> 得到的结果包在 I/O action 中，这样一来 I/O
action 中就包含了 <code>f handle</code> 得到的结果。如果 <code>f handle</code> 回传一个从标准输入读去数行并写到文件然后回传读入的行数的 I/O action，在 <code>withFile'​</code> 的情形中，最后的 I/O action 就会包含读入的行数。
</p>

<p>
就像 <code>hGetContents</code> 对应 <code>getContents</code> 一样，只不过是针对某个文件。我们也有
<b>hGetLine*、*hPutStr*、*hPutStrLn*、*hGetChar</b> 等等。他们分别是少了 h的那些函数的对应。只不过他们要多拿一个 handle当参数，并且是针对特定文件而不是标准输出或标准输入。像是 <code>putStrLn</code> 是一个接受一个字串并回传一个打印出加了换行字符的字串的 I/O action的函数。 <code>hPutStrLn</code> 接受一个 handle跟一个字串，回传一个打印出加了换行字符的字串到文件的 I/O action。以此类推， <code>hGetLine</code> 接受一个
handle然后回传一个从文件读取一行的 I/O action。
</p>

<p>
读取文件并对他们的字串内容作些处理实在太常见了，常见到我们有三个函数来更进一步简化我们的工作。
</p>

<p>
<b>readFile</b> 的 type signature 是 <code>readFile :: FilePath -&gt; IO String</code> 。记住，
 <code>FilePath</code> 不过是 <code>String</code> 的一个别名。 <code>readFile</code> 接受一个文件路径，回传一个惰性读取我们文件的 I/O action。然后将文件的内容绑定到某个字串。他比起先
 <code>openFile</code> ，绑定handle，然后 <code>hGetContents</code> 要好用多了。这边是一个用
 <code>readFile</code> 改写之前例子的范例：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    contents <span style="color: #8787d7;">&lt;-</span> readFile <span style="color: #2aa198;">"girlfriend.txt"</span>
    putStr contents
</pre>
</div>

<p>
由于我们拿不到 handle，所以我们也无法关掉他。这件事 Haskell 的 <code>readFile</code> 在背后帮我们做了。
</p>

<p>
<b>writeFile</b> 的型态是 <code>writefile :: FilePath -&gt; String -&gt; IO ()</code> 。他接受一个文件路径，以及一个要写到文件中的字串，并回传一个写入动作的I/O action。如果这个文件已经存在了，他会先把文件内容都砍了再写入。下面示范了如何把
girlfriend.txt 的内容转成大写然后写入到 girlfriendcaps.txt 中
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.Char</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    contents <span style="color: #8787d7;">&lt;-</span> readFile <span style="color: #2aa198;">"girlfriend.txt"</span>
    writeFile <span style="color: #2aa198;">"girlfriendcaps.txt"</span> <span style="color: #268bd2;">(</span>map toUpper contents<span style="color: #268bd2;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell girlfriendtocaps<span style="color: #8787d7;">.</span>hs
<span style="color: #8787d7;">$</span> cat girlfriendcaps<span style="color: #8787d7;">.</span>txt
<span style="color: #df005f; font-weight: bold;">HEY</span><span style="color: #d75fd7; font-weight: bold;">!</span> <span style="color: #df005f; font-weight: bold;">HEY</span><span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">YOU</span><span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">YOU</span><span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">I</span> <span style="color: #df005f; font-weight: bold;">DON'T</span> <span style="color: #df005f; font-weight: bold;">LIKE</span> <span style="color: #df005f; font-weight: bold;">YOUR</span> <span style="color: #df005f; font-weight: bold;">GIRLFRIEND</span><span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">NO</span> <span style="color: #df005f; font-weight: bold;">WAY</span><span style="color: #8787d7;">!</span> <span style="color: #df005f; font-weight: bold;">NO</span> <span style="color: #df005f; font-weight: bold;">WAY</span><span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">I</span> <span style="color: #df005f; font-weight: bold;">THINK</span> <span style="color: #df005f; font-weight: bold;">YOU</span> <span style="color: #df005f; font-weight: bold;">NEED</span> <span style="color: #df005f; font-weight: bold;">A</span> <span style="color: #df005f; font-weight: bold;">NEW</span> <span style="color: #df005f; font-weight: bold;">ONE</span><span style="color: #8787d7;">!</span>
</pre>
</div>

<p>
<b>appendFile</b> 的型态很像 <code>writeFile</code> ，只是 <code>appendFile</code> 并不会在文件存在时把文件内容砍掉而是接在后面。
</p>

<p>
假设我们有一个文件叫todo.txt``，里面每一行是一件要做的事情。现在我们写一个程序，从标准输入接受一行将他加到我们的to-do list 中。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    todoItem <span style="color: #8787d7;">&lt;-</span> getLine
    appendFile <span style="color: #2aa198;">"todo.txt"</span> <span style="color: #268bd2;">(</span>todoItem <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">"\n"</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell appendtodo<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #8787d7;">$</span> runhaskell appendtodo<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">Dust</span> the dog
<span style="color: #8787d7;">$</span> runhaskell appendtodo<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven
<span style="color: #8787d7;">$</span> cat todo<span style="color: #8787d7;">.</span>txt
<span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #df005f; font-weight: bold;">Dust</span> the dog
<span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven
</pre>
</div>

<p>
由于 <code>getLine</code> 回传的值不会有换行字符，我们需要在每一行最后加上 =​"\n"​= 。
</p>

<p>
还有一件事，我们提到 <code>contents &lt;- hGetContents handle</code> 是惰性I/O，不会将文件一次都读到内存中。 所以像这样写的话：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    withFile <span style="color: #2aa198;">"something.txt"</span> <span style="color: #df005f; font-weight: bold;">ReadMode</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>handle <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        contents <span style="color: #8787d7;">&lt;-</span> hGetContents handle
        putStr contents<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
实际上像是用一个 pipe 把文件弄到标准输出。正如你可以把 list 想成 stream一样，你也可以把文件想成stream。他会每次读一行然后打印到终端上。你也许会问这个 pipe
究竟一次可以塞多少东西，读去硬盘的频率究竟是多少？对于文本档而言，缺省的
buffer 通常是line-buffering。这代表一次被读进来的大小是一行。这也是为什么在这个 case我们是一行一行处理。对于 binary file 而言，缺省的 buffer 是
block-buffering。这代表我们是一个 chunk 一个 chunk 去读得。而一个 chunk的大小是根据操作系统不同而不同。
</p>

<p>
你能用 <code>hSetBuffering</code> 来控制 buffer 的行为。他接受一个 handle 跟一个
 <code>BufferMode</code> ，回传一个会设置 buffer 行为的 I/O action。 <code>BufferMode</code> 是一个
 enumeration 型态，他可能的值有： <code>NoBuffering</code> , <code>LineBuffering</code> 或
 <code>BlockBuffering (Maybe Int)</code> 。其中 <code>Maybe Int</code> 是表示一个 chunck 有几个byte。如果他的值是 <code>Nothing</code> ，则操作系统会帮你决定 chunk的大小。 <code>NoBuffering</code> 代表我们一次读一个 character。一般来说 <code>NoBuffering</code> 的表现很差，因为他访问硬盘的频率很高。
</p>

<p>
接下来是我们把之前的范例改写成用 2048 bytes 的 chunk读取，而不是一行一行读。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    withFile <span style="color: #2aa198;">"something.txt"</span> <span style="color: #df005f; font-weight: bold;">ReadMode</span> <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>handle <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        hSetBuffering handle <span style="color: #8787d7;">$</span> <span style="color: #df005f; font-weight: bold;">BlockBuffering</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> <span style="color: #d75fd7;">2048</span><span style="color: #d75fd7;">)</span>
        contents <span style="color: #8787d7;">&lt;-</span> hGetContents handle
        putStr contents<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
用更大的 chunk来读取对于减少访问硬盘的次数是有帮助的，特别是我们的文件其实是透过网络来访问。
</p>

<p>
我们也可以使用 *hFlush*，他接受一个 handle 并回传一个会 flush buffer到文件的
I/O action。当我们使用 line-buffering 的时候，buffer在每一行都会被 flush 到文件。当我们使用 block-buffering的时候，是在我们读每一个 chunk 作 flush 的动作。
flush 也会发生在关闭handle的时候。这代表当我们碰到换行字符的时候，读或写的动作都会停止并回报手边的数据。但我们能使用 <code>hFlush</code> 来强迫回报所有已经在 buffer
中的数据。经过 flushing之后，数据也就能被其他程序看见。
</p>

<p>
把 block-buffering的读取想成这样：你的马桶会在水箱有一加仑的水的时候自动冲水。所以你不断灌水进去直到一加仑，马桶就会自动冲水，在水里面的数据也就会被看到。但你也可以手动地按下冲水钮来冲水。他会让现有的水被冲走。冲水这个动作就是
<code>hFlush</code> 这个名字的含意。
</p>

<p>
我们已经写了一个将 item 加进 to-do list 里面的程序，现在我们想加进移除item 的功能。我先把代码粘贴然后讲解他。我们会使用一些新面孔像是 <code>System.Directory</code>
以及 <code>System.IO</code> 里面的函数。
</p>

<p>
来看一下我们包含移除功能的程序:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Directory</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    handle <span style="color: #8787d7;">&lt;-</span> openFile <span style="color: #2aa198;">"todo.txt"</span> <span style="color: #df005f; font-weight: bold;">ReadMode</span>
    <span style="color: #268bd2;">(</span>tempName, tempHandle<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> openTempFile <span style="color: #2aa198;">"."</span> <span style="color: #2aa198;">"temp"</span>
    contents <span style="color: #8787d7;">&lt;-</span> hGetContents handle
    <span style="color: #268bd2; font-weight: bold;">let</span> todoTasks <span style="color: #8787d7;">=</span> lines contents
    numberedTasks <span style="color: #8787d7;">=</span> zipWith <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>n line <span style="color: #8787d7;">-&gt;</span> show n <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" - "</span> <span style="color: #8787d7;">++</span> line<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">0</span><span style="color: #8787d7;">..</span><span style="color: #268bd2;">]</span> todoTasks
    putStrLn <span style="color: #2aa198;">"These are your TO-DO items:"</span>
    putStr <span style="color: #8787d7;">$</span> unlines numberedTasks
    putStrLn <span style="color: #2aa198;">"Which one do you want to delete?"</span>
    numberString <span style="color: #8787d7;">&lt;-</span> getLine
    <span style="color: #268bd2; font-weight: bold;">let</span> number <span style="color: #8787d7;">=</span> read numberString
    newTodoItems <span style="color: #8787d7;">=</span> delete <span style="color: #268bd2;">(</span>todoTasks <span style="color: #8787d7;">!!</span> number<span style="color: #268bd2;">)</span> todoTasks
    hPutStr tempHandle <span style="color: #8787d7;">$</span> unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile <span style="color: #2aa198;">"todo.txt"</span>
    renameFile tempName <span style="color: #2aa198;">"todo.txt"</span>
</pre>
</div>

<p>
一开始，我们用 read mode 打开 todo.txt，并把他绑定到 <code>handle</code> 。
</p>

<p>
接着，我们使用了一个之前没用过在 <code>System.IO</code> 中的函数*openTempFile*。他的名字浅显易懂。他接受一个暂存的文件夹跟一个样板文件名，然后打开一个暂存盘。我们使用 =​"."​= 当作我们的暂存文件夹，因为 <code>.</code> 在几乎任何操作系统中都代表了现在所在的文件夹。我们使用 =​"temp"​= 当作我们暂存盘的样板名，他代表暂存盘的名字会是
temp接上某串随机字串。他回传一个创建暂存盘的 I/O action，然后那个 I/O action
的结果是一个 pair：暂存盘的名字跟一个 handle。我们当然可以随便开启一个
todo2.txt 这种名字的文件。但使用 <code>openTempFile</code> 会是比较好的作法，这样你不会不小心覆写任何文件。
</p>

<p>
我们不用 <code>getCurrentDirectory</code> 的来拿到现在所在文件夹而用 =​"."​= 的原因是 <code>.</code>
在 unix-like 系统跟 Windows 中都表示现在的文件夹。
</p>

<p>
然后，我们绑定 todo.txt 的内容成 <code>contents</code> 。把字串断成一串字串，每个字串代表一行。 <code>todoTasks</code> 就变成 <code>["Iron the dishes", "Dust the dog", "Take salad
   out of the oven"]</code> 。我们用一个会把3 跟 =​"hey"​= 变成 =​"3 - hey"​= 的函数，然后从 0 开始把这个串列 zip起来。所以 <code>numberedTasks</code> 就是 <code>["0 - Iron the
   dishes", "1 - Dust the dog" ...</code> 。我们用 <code>unlines</code> 把这个串列变成一行，然后打印到终端上。注意我们也有另一种作法，就是用 <code>mapM putStrLn numberedTasks</code> 。
</p>

<p>
我们问用户他们想要删除哪一个并且等着他们输入一个数字。假设他们想要删除 1号，那代表 <code>Dust the dog</code> ，所以他们输入 <code>1</code> 。于是 <code>numberString</code> 就代表 =​"1"​=
。由于我们想要一个数字，而不是一个字串，所以我们用对 <code>1</code> 使用 <code>read</code> ，并且绑定到 <code>number</code> 。
</p>

<p>
还记得在 <code>Data.List</code> 中的 <code>delete</code> 跟 <code>!!</code> 吗？ <code>!!</code> 回传某个 index的元素，而
 <code>delete</code> 删除在串列中第一个发现的元素，然后回传一个新的没有那个元素的串列。
 <code>(todoTasks !! number)</code> 　（number代表 <code>1</code> ） 回传 =​"Dust the dog"​= 。我们把
 <code>todoTasks</code> 去掉第一个 =​"Dust the dog"​= 后的串列绑定到 <code>newTodoItems</code> ，然后用 <code>unlines</code> 变成一行然后写到我们所打开的暂存盘。旧有的文件并没有变动，而暂存盘包含砍掉那一行后的所有内容。
</p>

<p>
在我们关掉源文件跟暂存盘之后我们用 <b>removeFile*来移除原本的文件。他接受一个文件路径并且删除文件。删除旧得 todo.txt之后，我们用 *renameFile</b> 来将暂存盘重命名成 todo.txt。特别留意 <code>removeFile</code> 跟 <code>renameFile</code> （两个都在
<code>System.Directory</code> 中）接受的是文件路径，而不是 handle。
</p>

<p>
这就是我们要的，实际上我们可以用更少行写出同样的程序，但我们很小心地避免覆写任何文件，并询问操作系统我们可以把暂存盘摆在哪？让我们来执行看看。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell deletetodo<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">These</span> are your <span style="color: #df005f; font-weight: bold;">TO</span><span style="color: #8787d7;">-</span><span style="color: #df005f; font-weight: bold;">DO</span> items<span style="color: #df005f; font-weight: bold;">:</span>
<span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Dust</span> the dog
<span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven
<span style="color: #df005f; font-weight: bold;">Which</span> one <span style="color: #268bd2; font-weight: bold;">do</span> you want to delete<span style="color: #8787d7;">?</span>
<span style="color: #d75fd7;">1</span>

<span style="color: #8787d7;">$</span> cat todo<span style="color: #8787d7;">.</span>txt
<span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven

<span style="color: #8787d7;">$</span> runhaskell deletetodo<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">These</span> are your <span style="color: #df005f; font-weight: bold;">TO</span><span style="color: #8787d7;">-</span><span style="color: #df005f; font-weight: bold;">DO</span> items<span style="color: #df005f; font-weight: bold;">:</span>
<span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven
<span style="color: #df005f; font-weight: bold;">Which</span> one <span style="color: #268bd2; font-weight: bold;">do</span> you want to delete<span style="color: #8787d7;">?</span>
<span style="color: #d75fd7;">0</span>

<span style="color: #8787d7;">$</span> cat todo<span style="color: #8787d7;">.</span>txt
<span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven
</pre>
</div>
</div>
</div>

<div id="outline-container-org2fc2c03" class="outline-3">
<h3 id="org2fc2c03"><span class="section-number-3">1.3</span> 命令行引数</h3>
<div class="outline-text-3" id="text-1-3">

<div class="figure">
<p><img src="arguments.png" alt="arguments.png">
</p>
</div>

<p>
如果你想要写一个在终端里运行的程序，处理命令行引数是不可或缺的。幸运的是，利用Haskell 的 Standard Libary 能让我们有效地处理命令行引数。
</p>

<p>
在之前的章节中，我们写了一个能将 to-do item 加进或移除 to-do list的一个程序。但我们的写法有两个问题。第一个是我们把放 to-do list的文件名称给写死了。我们擅自决定用户不会有很多个 to-do lists，就把文件命名为 todo.txt。
</p>

<p>
一种解决的方法是每次都询问用户他们想将他们的 to-do list放进哪个文件。我们在用户要删除的时候也采用这种方式。这是一种可以运作的方式，但不太能被接受，因为他需要用户运行程序，等待程序询问才能回答。这被称为交互式的程序，但讨厌的地方在当你想要自动化执行程序的时候，好比说写成script，这会让你的 script 写起来比较困难。
</p>

<p>
这也是为什么有时候让用户在执行的时候就告诉程序他们要什么会比较好，而不是让程序去问用户要什么。比较好的方式是让用户透过命令行引数告诉程序他们想要什么。
</p>

<p>
在 <code>System.Environment</code> 模块当中有两个很酷的 I/O actions，一个是*getArgs*，他的 type 是 <code>getArgs :: IO [String]</code> ，他是一个拿取命令行引数的 I/O action，并把结果放在包含的一个串列中。*getProgName* 的型态是 <code>getProgName :: IO String</code>
，他则是一个 I/O action 包含了程序的名称。
</p>

<p>
我们来看一个展现他们功能的程序。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    args <span style="color: #8787d7;">&lt;-</span> getArgs
    progName <span style="color: #8787d7;">&lt;-</span> getProgName
    putStrLn <span style="color: #2aa198;">"The arguments are:"</span>
    mapM putStrLn args
    putStrLn <span style="color: #2aa198;">"The program name is:"</span>
    putStrLn progName
</pre>
</div>

<p>
我们将 <code>getArgs</code> 跟 <code>progName</code> 分别绑定到 <code>args</code> 跟 <code>progName</code> 。我们打印出
 <code>The arguments are:</code> 以及在 <code>args</code> 中的每个引数。最后，我们打印出程序的名字。我们把程序编译成 <code>arg-test</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>arg<span style="color: #8787d7;">-</span>test first second w00t <span style="color: #2aa198;">"multi word arg"</span>
<span style="color: #df005f; font-weight: bold;">The</span> arguments are<span style="color: #df005f; font-weight: bold;">:</span>
first
second
w00t
<span style="color: #d75fd7; font-weight: bold;">multi</span> word arg
<span style="color: #df005f; font-weight: bold;">The</span> program name is<span style="color: #df005f; font-weight: bold;">:</span>
arg<span style="color: #d75fd7; font-weight: bold;">-</span>test
</pre>
</div>

<p>
知道了这些函数现在你能写几个很酷的命令行程序。在之前的章节，我们写了一个程序来加入待作事项，也写了另一个程序删除事项。现在我们要把两个程序合起来，他会根据命令行引数来决定该做的事情。我们也会让程序可以处理不同的文件，而不是只有
todo.txt
</p>

<p>
我们叫这程序 todo，他会作三件事：
</p>

<pre class="example">
# 查看待作事项
# 加入待作事项
# 删除待作事项
</pre>

<p>
我们暂不考虑不合法的输入这件事。
</p>

<p>
我们的程序要像这样运作：假如我们要加入 <code>Find the magic sword of power</code> ，则我们会打 <code>todo add todo.txt "Find the magic sword of power"​</code> 。要查看事项我们则会打=todo view todo.txt= ，如果要移除事项二则会打 <code>todo remove todo.txt 2</code>
</p>

<p>
我们先作一个分发的 association list。他会把命令行引数当作key，而对应的处理函数当作 value。这些函数的型态都是 <code>[String] -&gt; IO ()</code> 。他们会接受命令行引数的串列并回传对应的查看，加入以及删除的I/O action。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Directory</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">dispatch</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">String</span>, <span style="color: #2aa198;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #2aa198;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #2aa198; font-weight: bold;">()</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">dispatch</span> <span style="color: #8787d7;">=</span>  <span style="color: #268bd2;">[</span> <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">"add"</span>, add<span style="color: #d75fd7;">)</span>
            , <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">"view"</span>, view<span style="color: #d75fd7;">)</span>
            , <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">"remove"</span>, remove<span style="color: #d75fd7;">)</span>
            <span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
我们定义了 <code>main</code> ， <code>add</code> ， <code>view</code> 跟 <code>remove</code> ，就从 <code>main</code> 开始讲吧：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2;">(</span>command<span style="color: #df005f; font-weight: bold;">:</span>args<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
    <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> action<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> lookup command dispatch
    action args
</pre>
</div>

<p>
首先，我们取出引数并把他们绑定到 <code>(command:args)</code> 。如果你还记得 pattern
matching，这么做会把第一个引数绑定到 <code>command</code> ，把其他的绑定到 <code>args</code> 。如果我们像这样执行程序 <code>todo add todo.txt "Spank the monkey"​</code> ， <code>command</code> 会变成
=​"add"​= ，而 <code>args</code> 会变成 <code>["todo.txt", "Spank the monkey"]</code> 。
</p>

<p>
在下一行，我们在一个分派的串列中寻到我们的指令是哪个。由于 =​"add"​= 指向 <code>add</code>
，我们的结果便是 <code>Just add</code> 。我们再度使用了 pattern matching来把我们的函数从
<code>Maybe</code> 中取出。但如果我们想要的指令不在分派的串列中呢？那样 lookup 就会回传
<code>Nothing</code> ，但我们这边并不特别处理失败的情况，所以 pattern matching会失败然后我们的程序就会当掉。
</p>

<p>
最后，我们用剩下的引数调用 <code>action</code> 这个函数。他会还传一个加入item，显示所有
items 或者删除 item 的 I/O action。由于这个 I/O action是在 <code>main</code> 的 do block
中，他最后会被执行。如果我们的 <code>action</code> 函数是 <code>add</code> ，他就会被喂 <code>args</code> 然后回传一个加入 <code>Spank the monkey</code> 到 todo.txt中的 I/O action。
</p>

<p>
我们剩下要做的就是实作 <code>add</code> ， <code>view</code> 跟 <code>remove</code> ，我们从 <code>add</code> 开始：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">add</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">add</span> <span style="color: #268bd2;">[</span>fileName, todoItem<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">=</span> appendFile fileName <span style="color: #268bd2;">(</span>todoItem <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">"\n"</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
如果我们这样执行程序 <code>todo add todo.txt "Spank the monkey"​</code> ，则 =​"add"​= 会被绑定到 <code>command</code> ，而 <code>["todo.txt", "Spank the monkey"]</code> 会被带到从dispatch
list 中拿到的函数。
</p>

<p>
由于我们不处理不合法的输入，我们只针对这两项作 pattern matching，然后回传一个附加一行到文件末尾的 I/O action。
</p>

<p>
接着，我们来实作查看串列。如果我们想要查看所有 items，我们会 <code>todo view
   todo.txt</code> 。所以 <code>command</code> 会是 =​"view"​= ，而 <code>args</code> 会是 <code>["todo.txt"]</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">view</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">view</span> <span style="color: #268bd2;">[</span>fileName<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    contents <span style="color: #8787d7;">&lt;-</span> readFile fileName
    <span style="color: #268bd2; font-weight: bold;">let</span> todoTasks <span style="color: #8787d7;">=</span> lines contents
    numberedTasks <span style="color: #8787d7;">=</span> zipWith <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>n line <span style="color: #8787d7;">-&gt;</span> show n <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" - "</span> <span style="color: #8787d7;">++</span> line<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">0</span><span style="color: #8787d7;">..</span><span style="color: #268bd2;">]</span> todoTasks
    putStr <span style="color: #8787d7;">$</span> unlines numberedTasks
</pre>
</div>

<p>
这跟我们之前删除文件的程序差不多，只是我们是在显示内容而已，
</p>

<p>
最后，我们要来实作 <code>remove</code> 。他基本上跟之前写的只有删除功能的程序很像，所以如果你不知道删除是怎么做的，可以去看之前的解释。主要的差别是我们不写死
todo.txt，而是从参数取得。我们也不会提示用户要删除哪一号的item，而是从参数取得。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">remove</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">remove</span> <span style="color: #268bd2;">[</span>fileName, numberString<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    handle <span style="color: #8787d7;">&lt;-</span> openFile fileName <span style="color: #df005f; font-weight: bold;">ReadMode</span>
    <span style="color: #268bd2;">(</span>tempName, tempHandle<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> openTempFile <span style="color: #2aa198;">"."</span> <span style="color: #2aa198;">"temp"</span>
    contents <span style="color: #8787d7;">&lt;-</span> hGetContents handle
    <span style="color: #268bd2; font-weight: bold;">let</span> number <span style="color: #8787d7;">=</span> read numberString
        todoTasks <span style="color: #8787d7;">=</span> lines contents
        newTodoItems <span style="color: #8787d7;">=</span> delete <span style="color: #268bd2;">(</span>todoTasks <span style="color: #8787d7;">!!</span> number<span style="color: #268bd2;">)</span> todoTasks
    hPutStr tempHandle <span style="color: #8787d7;">$</span> unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre>
</div>

<p>
我们打开 <code>fileName</code> 的文件以及一个暂存。删除用户要我们删的那一行后，把文件内容写到暂存盘。砍掉原本的文件然后把暂存盘重命名成 <code>fileName</code> 。
</p>

<p>
来看看完整的程序。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Directory</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">dispatch</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">String</span>, <span style="color: #2aa198;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #2aa198;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #2aa198; font-weight: bold;">()</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">dispatch</span> <span style="color: #8787d7;">=</span>  <span style="color: #268bd2;">[</span> <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">"add"</span>, add<span style="color: #d75fd7;">)</span>
            , <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">"view"</span>, view<span style="color: #d75fd7;">)</span>
            , <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">"remove"</span>, remove<span style="color: #d75fd7;">)</span>
            <span style="color: #268bd2;">]</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2;">(</span>command<span style="color: #df005f; font-weight: bold;">:</span>args<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
    <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Just</span> action<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> lookup command dispatch
    action args

<span style="color: #d75fd7; font-weight: bold;">add</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">add</span> <span style="color: #268bd2;">[</span>fileName, todoItem<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">=</span> appendFile fileName <span style="color: #268bd2;">(</span>todoItem <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">"\n"</span><span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">view</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">view</span> <span style="color: #268bd2;">[</span>fileName<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    contents <span style="color: #8787d7;">&lt;-</span> readFile fileName
    <span style="color: #268bd2; font-weight: bold;">let</span> todoTasks <span style="color: #8787d7;">=</span> lines contents
        numberedTasks <span style="color: #8787d7;">=</span> zipWith <span style="color: #268bd2;">(</span><span style="color: #8787d7;">\</span>n line <span style="color: #8787d7;">-&gt;</span> show n <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" - "</span> <span style="color: #8787d7;">++</span> line<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">0</span><span style="color: #8787d7;">..</span><span style="color: #268bd2;">]</span> todoTasks
    putStr <span style="color: #8787d7;">$</span> unlines numberedTasks

<span style="color: #d75fd7; font-weight: bold;">remove</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">String</span><span style="color: #268bd2;">]</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">remove</span> <span style="color: #268bd2;">[</span>fileName, numberString<span style="color: #268bd2;">]</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    handle <span style="color: #8787d7;">&lt;-</span> openFile fileName <span style="color: #df005f; font-weight: bold;">ReadMode</span>
    <span style="color: #268bd2;">(</span>tempName, tempHandle<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> openTempFile <span style="color: #2aa198;">"."</span> <span style="color: #2aa198;">"temp"</span>
    contents <span style="color: #8787d7;">&lt;-</span> hGetContents handle
    <span style="color: #268bd2; font-weight: bold;">let</span> number <span style="color: #8787d7;">=</span> read numberString
        todoTasks <span style="color: #8787d7;">=</span> lines contents
        newTodoItems <span style="color: #8787d7;">=</span> delete <span style="color: #268bd2;">(</span>todoTasks <span style="color: #8787d7;">!!</span> number<span style="color: #268bd2;">)</span> todoTasks
    hPutStr tempHandle <span style="color: #8787d7;">$</span> unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre>
</div>


<div class="figure">
<p><img src="salad.png" alt="salad.png">
</p>
</div>

<p>
总结我们的程序：我们做了一个 dispatch association，将指令对应到一些会接受命令行引数并回传 I/O action的函数。我们知道用户下了什么命令，并根据那个命令从
dispatch list取出对影的函数。我们用剩下的命令行引数调用哪些函数而得到一些作相对应事情的I/O action。然后便执行那些 I/O action。
</p>

<p>
在其他编程语言，我们可能会用一个大的 switch case来实作，但使用高端函数让我们可以要 dispatch list给我们要的函数，并要那些函数给我们适当的 I/O action。
</p>

<p>
让我们看看执行结果。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>todo view todo<span style="color: #8787d7;">.</span>txt
<span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Dust</span> the dog
<span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven

<span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>todo add todo<span style="color: #8787d7;">.</span>txt <span style="color: #2aa198;">"Pick up children from drycleaners"</span>

<span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>todo view todo<span style="color: #8787d7;">.</span>txt
<span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Dust</span> the dog
<span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Take</span> salad out <span style="color: #268bd2; font-weight: bold;">of</span> the oven
<span style="color: #d75fd7;">3</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Pick</span> up children from drycleaners

<span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>todo remove todo<span style="color: #8787d7;">.</span>txt <span style="color: #d75fd7;">2</span>

<span style="color: #8787d7;">$</span> <span style="color: #8787d7;">./</span>todo view todo<span style="color: #8787d7;">.</span>txt
<span style="color: #d75fd7;">0</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Iron</span> the dishes
<span style="color: #d75fd7;">1</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Dust</span> the dog
<span style="color: #d75fd7;">2</span> <span style="color: #8787d7;">-</span> <span style="color: #df005f; font-weight: bold;">Pick</span> up children from drycleaners
</pre>
</div>

<p>
要再另外加新的选项也是很容易。只要在 dispatch list加入新的会作你要的事情函数。你可以试试实作一个 <code>bump</code> 函数，接受一个文件跟一个 task number，他会回传一个把那个 task 搬到 to-do list 顶端的 I/O action。
</p>

<p>
对于不合法的输入你也可以让程序结束地漂亮一点。(例如用户输入了 <code>todo UP YOURS
   HAHAHAHA</code> )可以作一个回报错误的 I/O action (例如 <code>errorExist :: IO ()</code>)检查有没有不合法的输入，如果有便执行这个回报错误的I/O action。我们之后会谈另一个可能，就是用 exception。
</p>
</div>
</div>

<div id="outline-container-orgad4348b" class="outline-3">
<h3 id="orgad4348b"><span class="section-number-3">1.4</span> 乱数</h3>
<div class="outline-text-3" id="text-1-4">

<div class="figure">
<p><img src="random.png" alt="random.png">
</p>
</div>

<p>
在许多情况下，你写程序会需要些随机的数据。或许你在制作一个游戏，在游戏中你需要掷骰子。或是你需要测试程序的测试数据。精准一点地说，我们需要pseudo-random的数据，我们知道真正的随机数据好比是一只猴子拿着起司跟奶油骑在单轮车上，任何事情都会发生。在这个章节，我们要看看如何让Haskell 产生些 pseudo-random 的数据。
</p>

<p>
在大多数其他的编程语言中，会给你一些函数能让你拿到些随机乱数。每调用一次他就会拿到一个不同的数字。那在Haskell 中是如何？要记住 Haskell是一个纯粹函数式语言。代表任何东西都具有 referential transparency。那代表你喂给一个函数相同的参数，不管怎么调用都是回传相同的结果。这很新奇的原因是因为他让我们理解程序的方式不同，而且可以让我们延迟计算，直到我们真正需要他。如果我调用一个函数，我可以确定他不会乱来。我真正在乎的是他的结果。然而，这会造成在乱数的情况有点复杂。如果我有一个函数像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">randomNumber</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Num</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> a
<span style="color: #d75fd7; font-weight: bold;">randomNumber</span> <span style="color: #8787d7;">=</span> <span style="color: #d75fd7;">4</span>
</pre>
</div>

<p>
由于他永远回传 <code>4</code> ，所以对于乱数的情形而言是没什么意义。就算 4这个结果是掷骰子来的也没有意义。
</p>

<p>
其他的编程语言是怎么产生乱数的呢？他们可能随便拿取一些电脑的信息，像是现在的时间，你怎么移动你的鼠标，以及周围的声音。根据这些算出一个数值让他看起来好像随机的。那些要素算出来的结果可能在每个时间都不同，所以你会拿到不同的随机数字。
</p>

<p>
所以说在 Haskell中，假如我们能作一个函数，他会接受一个具随机性的参数，然后根据那些信息还传一个数值。
</p>

<p>
在 =System.Random=模块中。他包含所有满足我们需求的函数。让我们先来看其中一个，就是*random*。他的型态是~random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)~ 。哇，出现了新的 typeclass。*RandomGen* typeclass 是指那些可以当作乱源的型态。而*Random* typeclass 则是可以装乱数的型态。一个布林值可以是随机值，不是
<code>True</code> 就是=False= 。一个整数可以是随机的好多不同值。那你会问，函数可以是一个随机值吗？我不这么认为。如果我们试着翻译 <code>random</code> 的型态宣告，大概会是这样：他接受一个 random generator (乱源所在)，然后回传一个随机值以及一个新的 random
generator。为什么他要回传一个新的 random generator呢？就是下面我们要讲的。
</p>

<p>
要使用 <code>random</code> 函数， 我们必须要了解 random generator。 在 <code>System.Random</code>
中有一个很酷的型态，叫做 *StdGen*， 他是 <code>RandomGen</code> 的一个 instance。 我们可以自己手动作一个 <code>StdGen</code> 也可以告诉系统给我们一个现成的。
</p>

<p>
要自己做一个 random generator，要使用 <b>mkStdGen</b> 这个函数。他的型态是
 <code>mkStdGen :: Int -&gt; StdGen</code> 。他接受一个整数，然后根据这个整数会给一个random
 generator。让我们来试一下 <code>random</code> 以及 <code>mkStdGen</code> ，用他们产生一个乱数吧。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> random <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">100</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">&lt;</span>interactive<span style="color: #8787d7;">&gt;:</span><span style="color: #d75fd7;">1</span><span style="color: #df005f; font-weight: bold;">:</span><span style="color: #d75fd7;">0</span><span style="color: #df005f; font-weight: bold;">:</span>
    <span style="color: #df005f; font-weight: bold;">Ambiguous</span> <span style="color: #268bd2; font-weight: bold;">type</span> variable `a' <span style="color: #268bd2; font-weight: bold;">in</span> the constraint<span style="color: #df005f; font-weight: bold;">:</span>
        `<span style="color: #df005f; font-weight: bold;">Random</span> a' arising from a use <span style="color: #268bd2; font-weight: bold;">of</span> `random' at <span style="color: #8787d7;">&lt;</span>interactive<span style="color: #8787d7;">&gt;:</span><span style="color: #d75fd7;">1</span><span style="color: #df005f; font-weight: bold;">:</span><span style="color: #d75fd7;">0</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">20</span>
    <span style="color: #df005f; font-weight: bold;">Probable</span> fix<span style="color: #df005f; font-weight: bold;">:</span> add a <span style="color: #268bd2; font-weight: bold;">type</span> <span style="color: #268bd2; font-weight: bold;">signature</span> that fixes these <span style="color: #268bd2; font-weight: bold;">type</span> variable<span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span>  `
</pre>
</div>

<p>
这是什么？由于 <code>random</code> 函数会回传 <code>Random</code> typeclass中任何一种型态，所以我们必须告诉 Haskell我们是要哪一种型态。不要忘了我们是回传 random value 跟 random
generator的一个 pair
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> random <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">100</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1352021624</span>,<span style="color: #d75fd7;">651872571</span> <span style="color: #d75fd7;">1655838864</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
我们终于有了一个看起来像乱数的数字。tuple的第一个部份是我们的乱数，而第二个部份是一个新的 random generator的文本表示。如果我们用相同的 random generator 再调用 <code>random</code> 一遍呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> random <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">100</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1352021624</span>,<span style="color: #d75fd7;">651872571</span> <span style="color: #d75fd7;">1655838864</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
不易外地我们得到相同的结果。所以我们试试用不同的 random generator作为我们的参数。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> random <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">949494</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">539963926</span>,<span style="color: #d75fd7;">466647808</span> <span style="color: #d75fd7;">1655838864</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
很好，我们拿到了不同的数字。我们可以用不同的型态标志来拿到不同型态的乱数
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> random <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">949488</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Float</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">0.8938442</span>,<span style="color: #d75fd7;">1597344447</span> <span style="color: #d75fd7;">1655838864</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> random <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">949488</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Bool</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #d75fd7;">1485632275</span> <span style="color: #d75fd7;">40692</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> random <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">949488</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Integer</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1691547873</span>,<span style="color: #d75fd7;">1597344447</span> <span style="color: #d75fd7;">1655838864</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
让我们写一个仿真丢三次铜板的函数。假如 <code>random</code> 不同时回传一个乱数以及一个新的 random generator，我们就必须让这函数接受三个 random generators让他们每个回传一个掷铜板的结果。但那样听起来怪怪的，加入一个 generator可以产生一个型态是
<code>Int</code> 的乱数，他应该可以产生掷三次铜板的结果（总共才八个组合）。这就是
<code>random</code> 为什么要回传一个新的 generator 的关键了。
</p>

<p>
我们将一个铜板表示成 <code>Bool</code> 。 <code>True</code> 代表反面， <code>False</code> 代表正面。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">threeCoins</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">StdGen</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Bool</span>, <span style="color: #df005f; font-weight: bold;">Bool</span>, <span style="color: #df005f; font-weight: bold;">Bool</span><span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">threeCoins</span> gen <span style="color: #8787d7;">=</span>
    <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>firstCoin, newGen<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random gen
    <span style="color: #268bd2;">(</span>secondCoin, newGen'<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random newGen
    <span style="color: #268bd2;">(</span>thirdCoin, newGen'<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random newGen'
    <span style="color: #268bd2; font-weight: bold;">in</span>  <span style="color: #268bd2;">(</span>firstCoin, secondCoin, thirdCoin<span style="color: #268bd2;">)</span>  <span style="color: #e0211d; text-decoration: overline;">)</span>
</pre>
</div>

<p>
我们用我们拿来当参数的 generator 调用 <code>random</code> 并得到一个掷铜板的结果跟一个新的 generator。然后我们再用新的 generator调用他一遍，来得到第二个掷铜板的结果。对于第三个掷铜板的结果也是如法炮制。如果我们一直都用同样的generator，那所有的结果都会是相同的值。也就是不是 <code>(False, False, False)</code> 就是 <code>(True, True,
   True)</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> threeCoins <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">21</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">True</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> threeCoins <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">22</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #df005f; font-weight: bold;">True</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> threeCoins <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">943</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">False</span>,<span style="color: #df005f; font-weight: bold;">True</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> threeCoins <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">944</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">True</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
留意我们不需要写 <code>random gen :: (Bool, StdGen)</code> 。那是因为我们已经在函数的型态宣告那边就表明我们要的是布林。而Haskell 可以推敲出我们要的是布林值。
</p>

<p>
假如我们要的是掷四次？甚至五次呢？有一个函数叫 *randoms*，他接受一个generator
并回传一个无穷串行。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> take <span style="color: #d75fd7;">5</span> <span style="color: #8787d7;">$</span> randoms <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">11</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Int</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1807975507</span>,<span style="color: #d75fd7;">545074951</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1015194702</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1622477312</span>,<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">502893664</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> take <span style="color: #d75fd7;">5</span> <span style="color: #8787d7;">$</span> randoms <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">11</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Bool</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">True</span>,<span style="color: #df005f; font-weight: bold;">False</span><span style="color: #268bd2;">]</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> take <span style="color: #d75fd7;">5</span> <span style="color: #8787d7;">$</span> randoms <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">11</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Float</span><span style="color: #268bd2;">]</span>
<span style="color: #268bd2;">[</span><span style="color: #d75fd7;">7.904789e-2</span>,<span style="color: #d75fd7;">0.62691015</span>,<span style="color: #d75fd7;">0.26363158</span>,<span style="color: #d75fd7;">0.12223756</span>,<span style="color: #d75fd7;">0.38291094</span><span style="color: #268bd2;">]</span>
</pre>
</div>

<p>
为什么 <code>randoms</code> 不另外多回传一个新的 generator 呢？我们可以这样地实作
<code>randoms</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">randoms'</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">RandomGen</span> g, <span style="color: #df005f; font-weight: bold;">Random</span> a<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> g <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">[</span>a<span style="color: #268bd2;">]</span>
<span style="color: #d75fd7; font-weight: bold;">randoms'</span> gen <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>value, newGen<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random gen <span style="color: #268bd2; font-weight: bold;">in</span> value<span style="color: #df005f; font-weight: bold;">:</span>randoms' newGen
</pre>
</div>

<p>
一个递归的定义。我们由现在的 generator 拿到一个乱数跟一个新的generator，然后制作一个 list，list 的第一个值是那个乱数，而 list的其余部份是根据新的
generator产生出的其余乱数们。由于我们可能产生出无限的乱数，所以不可能回传一个新的generator。
</p>

<p>
我们可以写一个函数，他会回传有限个乱数跟一个新的 generator
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">finiteRandoms</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">RandomGen</span> g, <span style="color: #df005f; font-weight: bold;">Random</span> a, <span style="color: #df005f; font-weight: bold;">Num</span> n, <span style="color: #df005f; font-weight: bold;">Eq</span> n<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=&gt;</span> n <span style="color: #8787d7;">-&gt;</span> g <span style="color: #8787d7;">-&gt;</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">[</span>a<span style="color: #d75fd7;">]</span>, g<span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">finiteRandoms</span> <span style="color: #d75fd7;">0</span> gen <span style="color: #8787d7;">=</span> <span style="color: #268bd2;">(</span><span style="color: #d75fd7; font-weight: bold;">[]</span>, gen<span style="color: #268bd2;">)</span>
<span style="color: #d75fd7; font-weight: bold;">finiteRandoms</span> n gen <span style="color: #8787d7;">=</span>
    <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>value, newGen<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> random gen
        <span style="color: #268bd2;">(</span>restOfList, finalGen<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> finiteRandoms <span style="color: #268bd2;">(</span>n<span style="color: #8787d7;">-</span><span style="color: #d75fd7;">1</span><span style="color: #268bd2;">)</span> newGen
    <span style="color: #268bd2; font-weight: bold;">in</span>  <span style="color: #268bd2;">(</span>value<span style="color: #df005f; font-weight: bold;">:</span>restOfList, finalGen<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
又是一个递归的定义。我们说如果我们要 0 个乱数，我们便回传一个空的 list跟原本给我们的 generator。对于其他数量的乱数，我们先拿一个乱数跟一个新的generator。这一个乱数便是 list 的第一个数字。然后 list 中剩下的便是 n-1个由新的
generator 产生出的乱数。然后我们回传整个 list 跟最后一个产生完n-1 个乱数后
generator。
</p>

<p>
如果我们要的是在某个范围内的乱数呢？现在拿到的乱数要不是太大就是太小。如果我们想要的是骰子上的数字呢？*randomR*能满足我们的需求。他的型态是 <code>randomR ::
   (RandomGen g, Random a) :: (a, a) -&gt; g -&gt; (a, g)</code> ，代表他有点类似 <code>random</code>
。只不过他的第一个参数是一对数目，定义了最后产生乱数的上界以及下界。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> randomR <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">6</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">359353</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">6</span>,<span style="color: #d75fd7;">1494289578</span> <span style="color: #d75fd7;">40692</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> randomR <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">6</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">35935335</span><span style="color: #268bd2;">)</span>
<span style="color: #268bd2;">(</span><span style="color: #d75fd7;">3</span>,<span style="color: #d75fd7;">1250031057</span> <span style="color: #d75fd7;">40692</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
另外也有一个 <b>randomRs</b> 的函数，他会产生一连串在给定范围内的乱数：
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> take <span style="color: #d75fd7;">10</span> <span style="color: #8787d7;">$</span> randomRs <span style="color: #268bd2;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'z'</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>mkStdGen <span style="color: #d75fd7;">3</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">[</span><span style="color: #df005f; font-weight: bold;">Char</span><span style="color: #268bd2;">]</span>
<span style="color: #2aa198;">"ndkxbvmomg"</span>
</pre>
</div>

<p>
这结果看起来像是一个安全性很好的密码。
</p>

<p>
你会问你自己，这一单元跟 I/O 有关系吗？到现在为止还没出现任何跟 I/O有关的东西。到现在为止我们都是手动地做我们的 random generator。但那样的问题是，程序永远都会回传同样的乱数。这在真实世界中的程序是不能接受的。这也是为什么
<code>System.Random</code> 要提供 <b>getStdGen</b> 这个 I/O action，他的型态是 <code>IO StdGen</code> 。当你的程序执行时，他会跟系统要一个 random generator，并存成一个 global
generator。 <code>getStdGen</code> 会替你拿那个 global random generator 并把他绑定到某个名称上。
</p>

<p>
这里有一个简单的产生随机字串的程序。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    gen <span style="color: #8787d7;">&lt;-</span> getStdGen
    putStr <span style="color: #8787d7;">$</span> take <span style="color: #d75fd7;">20</span> <span style="color: #268bd2;">(</span>randomRs <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'z'</span><span style="color: #d75fd7;">)</span> gen<span style="color: #268bd2;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell random_string<span style="color: #8787d7;">.</span>hs
pybphhzzhuepknbykxhe
<span style="color: #8787d7;">$</span> runhaskell random_string<span style="color: #8787d7;">.</span>hs
eiqgcxykivpudlsvvjpg
<span style="color: #8787d7;">$</span> runhaskell random_string<span style="color: #8787d7;">.</span>hs
nzdceoconysdgcyqjruo
<span style="color: #8787d7;">$</span> runhaskell random_string<span style="color: #8787d7;">.</span>hs
bakzhnnuzrkgvesqplrx
</pre>
</div>

<p>
要当心当我们连续两次调用 <code>getStdGent</code> 的时候，实际上都会回传同样的global
generator。像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    gen <span style="color: #8787d7;">&lt;-</span> getStdGen
    putStrLn <span style="color: #8787d7;">$</span> take <span style="color: #d75fd7;">20</span> <span style="color: #268bd2;">(</span>randomRs <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'z'</span><span style="color: #d75fd7;">)</span> gen<span style="color: #268bd2;">)</span>
    gen2 <span style="color: #8787d7;">&lt;-</span> getStdGen
    putStr <span style="color: #8787d7;">$</span> take <span style="color: #d75fd7;">20</span> <span style="color: #268bd2;">(</span>randomRs <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'z'</span><span style="color: #d75fd7;">)</span> gen2<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
你会打印出两次同样的字串。要能得到两个不同的字串是建立一个无限的stream，然后拿前 20 个字当作第一个字串，拿下 20个字当作第二个字串。要这么做，我们需要在
<code>Data.List</code> 中的 =splitAt=函数。他会把一个 list 根据给定的 index 切成一个
tuple，tuple的第一部份就是切断的前半，第二个部份就是切断的后半。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Data.List</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    gen <span style="color: #8787d7;">&lt;-</span> getStdGen
    <span style="color: #268bd2; font-weight: bold;">let</span> randomChars <span style="color: #8787d7;">=</span> randomRs <span style="color: #268bd2;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'z'</span><span style="color: #268bd2;">)</span> gen
        <span style="color: #268bd2;">(</span>first20, rest<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> splitAt <span style="color: #d75fd7;">20</span> randomChars
        <span style="color: #268bd2;">(</span>second20, <span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> splitAt <span style="color: #d75fd7;">20</span> rest
    putStrLn first20
    putStr second20
</pre>
</div>

<p>
另一种方法是用 <b>newStdGen</b> 这个 I/O action，他会把现有的 random generator 分成两个新的 generators。然后会把其中一个指定成 global generator，并回传另一个。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    gen <span style="color: #8787d7;">&lt;-</span> getStdGen
    putStrLn <span style="color: #8787d7;">$</span> take <span style="color: #d75fd7;">20</span> <span style="color: #268bd2;">(</span>randomRs <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'z'</span><span style="color: #d75fd7;">)</span> gen<span style="color: #268bd2;">)</span>
    gen' <span style="color: #8787d7;">&lt;-</span> newStdGen
    putStr <span style="color: #8787d7;">$</span> take <span style="color: #d75fd7;">20</span> <span style="color: #268bd2;">(</span>randomRs <span style="color: #d75fd7;">(</span><span style="color: #2aa198;">'a'</span>,<span style="color: #2aa198;">'z'</span><span style="color: #d75fd7;">)</span> gen'<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
当我们绑定 <code>newStdGen</code> 的时候我们不只是会拿到一个新的 generator，global
generator 也会被重新指定。所以再调用一次 <code>getStdGen</code> 并绑定到某个名称的话，我们就会拿到跟 <code>gen</code> 不一样的 generator。
</p>

<p>
这边有一个小程序会让用户猜数字：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad</span><span style="color: #268bd2;">(</span>when<span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    gen <span style="color: #8787d7;">&lt;-</span> getStdGen
    askForNumber gen

<span style="color: #d75fd7; font-weight: bold;">askForNumber</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">StdGen</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">askForNumber</span> gen <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>randNumber, newGen<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> randomR <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span> gen <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
    putStr <span style="color: #2aa198;">"Which number in the range from 1 to 10 am I thinking of? "</span>
    numberString <span style="color: #8787d7;">&lt;-</span> getLine
    when <span style="color: #268bd2;">(</span>not <span style="color: #8787d7;">$</span> null numberString<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">$</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        <span style="color: #268bd2; font-weight: bold;">let</span> number <span style="color: #8787d7;">=</span> read numberString
        <span style="color: #268bd2; font-weight: bold;">if</span> randNumber <span style="color: #8787d7;">==</span> number
            <span style="color: #268bd2; font-weight: bold;">then</span> putStrLn <span style="color: #2aa198;">"You are correct!"</span>
            <span style="color: #268bd2; font-weight: bold;">else</span> putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"Sorry, it was "</span> <span style="color: #8787d7;">++</span> show randNumber
            askForNumber newGen
</pre>
</div>


<div class="figure">
<p><img src="jackofdiamonds.png" alt="jackofdiamonds.png">
</p>
</div>

<p>
我们写了一个 <code>askForNumber</code> 的函数，他接受一个 random generator并回传一个问用户要数字并回答是否正确的 I/O action。在那个函数里面，我们先根据从参数拿到的
generator产生一个乱数以及一个新的 generator，分别叫他们为 <code>randomNumber</code> 跟
<code>newGen</code> 。假设那个产生的数字是 <code>7</code> 。则我们要求用户猜我们握有的数字是什么。我们用 <code>getLine</code> 来将结果绑定到 <code>numberString</code> 上。当用户输入 <code>7</code> ，
<code>numberString</code> 就会是 =​"7"​= 。接下来，我们用 <code>when</code> 来检查用户输入的是否是空字串。如果是，那一个空的 I/O action <code>return ()</code> 就会被回传。基本上就等于是结束程序的意思。如果不是，那 I/O action就会被执行。我们用 <code>read</code> 来把
<code>numberString</code> 转成一个数字，所以 <code>number</code> 便会是 <code>7</code> 。
</p>

<pre class="example">
如果用户给我们一些 ``read`` 没办法读取的输入（像是 ``"haha"``），我们的程序便会
当掉并打印出错误消息。 如果你不希望你的程序当掉，就用 **reads**，当读取失败的时
候他会回传一个空的 list。当成功的时候他就回传一个 tuple，第一个部份是我们想要的
数字，第二个部份是读取失败的字串。
</pre>

<p>
我们检查如果输入的数字跟我们随机产生的数字一样，便提示用户恰当的消息。然后再递归地调用 <code>askForNumber</code> ，只是会拿到一个新的 generator。就像之前的
generator一样，他会给我们一个新的 I/O action。
</p>

<p>
 <code>main</code> 的组成很简单，就是由拿取一个 random generator 跟调用 <code>askForNumber</code>
组成罢了。
</p>

<p>
来看看我们的程序：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell guess_the_number<span style="color: #8787d7;">.</span>hs
<span style="color: #df005f; font-weight: bold;">Which</span> number <span style="color: #268bd2; font-weight: bold;">in</span> the range from <span style="color: #d75fd7;">1</span> to <span style="color: #d75fd7;">10</span> am <span style="color: #df005f; font-weight: bold;">I</span> thinking <span style="color: #268bd2; font-weight: bold;">of</span><span style="color: #8787d7;">?</span> <span style="color: #d75fd7;">4</span>
<span style="color: #df005f; font-weight: bold;">Sorry</span>, it was <span style="color: #d75fd7;">3</span>
<span style="color: #df005f; font-weight: bold;">Which</span> number <span style="color: #268bd2; font-weight: bold;">in</span> the range from <span style="color: #d75fd7;">1</span> to <span style="color: #d75fd7;">10</span> am <span style="color: #df005f; font-weight: bold;">I</span> thinking <span style="color: #268bd2; font-weight: bold;">of</span><span style="color: #8787d7;">?</span> <span style="color: #d75fd7;">10</span>
<span style="color: #df005f; font-weight: bold;">You</span> are correct<span style="color: #8787d7;">!</span>
<span style="color: #df005f; font-weight: bold;">Which</span> number <span style="color: #268bd2; font-weight: bold;">in</span> the range from <span style="color: #d75fd7;">1</span> to <span style="color: #d75fd7;">10</span> am <span style="color: #df005f; font-weight: bold;">I</span> thinking <span style="color: #268bd2; font-weight: bold;">of</span><span style="color: #8787d7;">?</span> <span style="color: #d75fd7;">2</span>
<span style="color: #df005f; font-weight: bold;">Sorry</span>, it was <span style="color: #d75fd7;">4</span>
<span style="color: #df005f; font-weight: bold;">Which</span> number <span style="color: #268bd2; font-weight: bold;">in</span> the range from <span style="color: #d75fd7;">1</span> to <span style="color: #d75fd7;">10</span> am <span style="color: #df005f; font-weight: bold;">I</span> thinking <span style="color: #268bd2; font-weight: bold;">of</span><span style="color: #8787d7;">?</span> <span style="color: #d75fd7;">5</span>
<span style="color: #df005f; font-weight: bold;">Sorry</span>, it was <span style="color: #d75fd7;">10</span>
<span style="color: #df005f; font-weight: bold;">Which</span> number <span style="color: #268bd2; font-weight: bold;">in</span> the range from <span style="color: #d75fd7;">1</span> to <span style="color: #d75fd7;">10</span> am <span style="color: #df005f; font-weight: bold;">I</span> thinking <span style="color: #268bd2; font-weight: bold;">of</span><span style="color: #8787d7;">?</span>
</pre>
</div>

<p>
用另一种方式写的话像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Random</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">Control.Monad</span><span style="color: #268bd2;">(</span>when<span style="color: #268bd2;">)</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    gen <span style="color: #8787d7;">&lt;-</span> getStdGen
    <span style="color: #268bd2; font-weight: bold;">let</span> <span style="color: #268bd2;">(</span>randNumber, <span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">=</span> randomR <span style="color: #268bd2;">(</span><span style="color: #d75fd7;">1</span>,<span style="color: #d75fd7;">10</span><span style="color: #268bd2;">)</span> gen <span style="color: #8787d7;">::</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Int</span>, <span style="color: #df005f; font-weight: bold;">StdGen</span><span style="color: #268bd2;">)</span>
    putStr <span style="color: #2aa198;">"Which number in the range from 1 to 10 am I thinking of? "</span>
    numberString <span style="color: #8787d7;">&lt;-</span> getLine
    when <span style="color: #268bd2;">(</span>not <span style="color: #8787d7;">$</span> null numberString<span style="color: #268bd2;">)</span> <span style="color: #8787d7;">$</span> <span style="color: #268bd2; font-weight: bold;">do</span>
        <span style="color: #268bd2; font-weight: bold;">let</span> number <span style="color: #8787d7;">=</span> read numberString
        <span style="color: #268bd2; font-weight: bold;">if</span> randNumber <span style="color: #8787d7;">==</span> number
            <span style="color: #268bd2; font-weight: bold;">then</span> putStrLn <span style="color: #2aa198;">"You are correct!"</span>
            <span style="color: #268bd2; font-weight: bold;">else</span> putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"Sorry, it was "</span> <span style="color: #8787d7;">++</span> show randNumber
        newStdGen
        main
</pre>
</div>

<p>
他非常类似我们之前的版本，只是不是递归地调用，而是把所有的工作都在 <code>main</code> 里面做掉。在告诉用户他们猜得是否正确之后，便更新 global generator然后再一次调用
<code>main</code> 。两种策略都是有效但我比较喜欢第一种方式。因为他在 <code>main</code> 里面做的事比较少，并提供我们一个可以重复使用的函数。
</p>
</div>
</div>

<div id="outline-container-org095f38a" class="outline-3">
<h3 id="org095f38a"><span class="section-number-3">1.5</span> Bytestrings</h3>
<div class="outline-text-3" id="text-1-5">

<div class="figure">
<p><img src="chainchomp.png" alt="chainchomp.png">
</p>
</div>

<p>
List是一种有用又酷的数据结构。到目前为止，我们几乎无处不使用他。有好几个函数是专门处理List 的，而 Haskell 惰性的性质又让我们可以用 filter 跟 map来替换其他语言中的 for loop 跟 while loop。也由于 evaluation只会发生在需要的时候，像
infinite list 也对于 Haskell 不成问题（甚至是infinite list of infinite list）。这也是为什么 list 能被用来表达stream，像是读取标准输入或是读取文件。我们可以打开文件然后读取内容成字串，即便实际上我们是需要的时候才会真正取读取。
</p>

<p>
然而，用字串来处理文件有一个缺点：就是他很慢。就像你所知道的， <code>String</code> 是一个 <code>[Char]</code> 的 type synonym。 <code>Char</code> 没有一个固定的大小，因为他可能由好几个
 byte 组成，好比说 Unicode。再加上list 是惰性的。如果你有一个 list 像
 <code>[1,2,3,4]</code> ，他只会在需要的时候被evaluate。所以整个 list 其实比较像是一个"
 保证"你会有一个 list。要记住 <code>[1,2,3,4]</code> 不过是 <code>1:2:3:4:[]</code> 的一个
 syntactic sugar。当 list的第一个元素被 evaluated 的时候，剩余的部份
 <code>2:3:4:[]</code> 一样也只是一个"保证"你会有一个list，以此类推。以此类推。以此类推。所以你可以想像成 list是保证在你需要的时候会给你第一个元素，以及保证你会有剩下的部份当你还需要更多的时候。其实不难说服你这样做并不是一个最有效率的作法。
</p>

<p>
这样额外的负担在大多数时候不会造成困扰，但当我们要读取一个很大的文件的时候就是个问题了。这也是为什么Haskell 要有 <code>bytestrings</code> 。Bytestrings 有点像list，但他每一个元素都是一个 byte (8 bits)，而且他们惰性的程度也是不同。
</p>

<p>
Bytestrings 有两种：strict 跟 lazy。Strict bytestrings 放在 <code>Data.ByteString</code>
，他们把惰性的性质完全拿掉。不会有所谓任何的「保证」，一个strict bytestring
就代表一连串的 bytes。因此你不会有一个无限长的 strict bytestrings。如果你
evaluate 第一个 byte，你就必须 evalute 整个bytestring。这么做的优点是他会比较少overhaed，因为他没有　"Thunk"（也就是用 Haskell术语来说的「保证」）。缺点就是他可能会快速消耗你的内存，因为你把他们一次都读进了内存。
</p>

<p>
另一种 bytestring 是放在 <code>Data.ByteString.Lazy</code> 中。他们具有惰性，但又不像
list 那么极端。就像我们之前说的，List 的thunk 个数是跟 list中有几个元素一模一样。这也是为什么他们速度没办法满足一些特殊需求。Lazy bytestrings 则用另一种作法，他们被存在 chunks 中（不要跟 Thunk搞混），每一个 chunk 的大小是 64K。所以如果你 evaluate lazy bytestring中的 byte，则前 64K 会被 evaluated。在那个
chunck之后，就是一些「保证」会有剩余的 chunk。lazy bytestrings有点像装了一堆大小为 64K 的 strict bytestrings 的 list。当你用 lazy bytestring 处理一个文件的时候，他是一个 chunk 一个 chunk去读。这很棒是因为他不会让我们一下使用大量的内存，而且 64K有很高的可能性能够装进你 CPU 的 L2 Cache。
</p>

<p>
如果你大概看过 <code>Data.ByteString.Lazy</code> 的文档，你会看到到他有一堆函数的名称跟
 <code>Data.List</code> 中的函数名称相同，只是出现的 type signature 是 <code>ByteString</code> 而不是=[a]= ，是 <code>Word8</code> 而不是 <code>a</code> 。同样名称的函数基本上表现的行为跟 list中的差不多。因为名称是一样的，所以必须用 qualified import 才不会在装载进GHCI 的时候造成冲突。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #268bd2; font-weight: bold;">qualified</span> <span style="color: #df005f; font-weight: bold;">Data.ByteString.Lazy</span> <span style="color: #268bd2; font-weight: bold;">as</span> <span style="color: #df005f; font-weight: bold;">B</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #268bd2; font-weight: bold;">qualified</span> <span style="color: #df005f; font-weight: bold;">Data.ByteString</span> <span style="color: #268bd2; font-weight: bold;">as</span> <span style="color: #df005f; font-weight: bold;">S</span>
</pre>
</div>

<p>
 <code>B</code> 中有 lazy bytestrings 跟对应的函数，而 <code>S</code> 中则有 strict的版本。大多数时候我们是用 lazy 的版本。
</p>

<p>
<b>pack</b> 函数的 type signature 是 <code>pack :: [Word8] -&gt; ByteString</code> 。代表他接受一串型态为 <code>Word8</code> 的bytes，并回传一个 <code>ByteString</code> 。你能想像一个 lazy 的
list，要让他稍微不lazy 一些，所以让他对于 64K lazy。
</p>

<p>
那 <code>Word8</code> 型态又是怎么一回事？。他就像 <code>Int</code> ，只是他的范围比较小，介于0-255
之间。他代表一个 8-bit 的数字。就像 <code>Int</code> 一样，他是属于 <code>Num</code> 这个 typeclass。例如我们知道 <code>5</code> 是 polymorphic的，他能够表现成任何数值型态。其实 <code>Word8</code> 他也能表示。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> B.pack <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">99</span>,<span style="color: #d75fd7;">97</span>,<span style="color: #d75fd7;">110</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"can"</span> <span style="color: #df005f; font-weight: bold;">Empty</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> B.pack <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">98</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">120</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"bcdefghijklmnopqrstuvwx"</span> <span style="color: #df005f; font-weight: bold;">Empty</span>
</pre>
</div>

<p>
正如你看到的，你其实不必特别在意 <code>Word8</code> ，因为型态系统会选择正确的型态。如果你试着用比较大的数字，像是 <code>336</code> 。那对于 <code>Word8</code> 他就会变成 <code>80</code> 。
</p>

<p>
我们把一些数值打包成 <code>ByteString</code> ，使他们可以塞进一个 chunk里面。 <code>Empty</code> 之于 <code>ByteString</code> 就像 <code>[]</code> 之于 list 一样。
</p>

<p>
<b>unpack</b> 是 <code>pack</code> 的相反，他把一个 bytestring 变成一个 byte list。
</p>

<p>
<b>fromChunks</b> 接受一串 strict 的 bytestrings 并把他变成一串 lazy bytestring。
<b>toChunks</b> 接受一个 lazy bytestrings 并将他变成一串 strict bytestrings。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> B.fromChunks <span style="color: #268bd2;">[</span>S.pack <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">40</span>,<span style="color: #d75fd7;">41</span>,<span style="color: #d75fd7;">42</span><span style="color: #d75fd7;">]</span>, S.pack <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">43</span>,<span style="color: #d75fd7;">44</span>,<span style="color: #d75fd7;">45</span><span style="color: #d75fd7;">]</span>, S.pack <span style="color: #d75fd7;">[</span><span style="color: #d75fd7;">46</span>,<span style="color: #d75fd7;">47</span>,<span style="color: #d75fd7;">48</span><span style="color: #d75fd7;">]</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"()*"</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"+,-"</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"./0"</span> <span style="color: #df005f; font-weight: bold;">Empty</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
如果你有很多小的 strict bytestrings 而且不想先将他们 join 起来（会耗损memory）这样的作法是不错的。
</p>

<p>
bytestring 版本的 <code>:</code> 叫做 *cons*。他接受一个 byte 跟一个bytestring，并把这个
byte 放到 bytestring 的前端。他是 lazy 的操作，即使bytestring 的第一个 chunk
不是满的，他也会添加一个chunk。这也是为什么当你要插入很多 bytes 的时候最好用
strict 版本的 <code>cons</code> ，也就是 *cons'*。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> B.cons <span style="color: #d75fd7;">85</span> <span style="color: #8787d7;">$</span> B.pack <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">80</span>,<span style="color: #d75fd7;">81</span>,<span style="color: #d75fd7;">82</span>,<span style="color: #d75fd7;">84</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"U"</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"PQRT"</span> <span style="color: #df005f; font-weight: bold;">Empty</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> B.cons' <span style="color: #d75fd7;">85</span> <span style="color: #8787d7;">$</span> B.pack <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">80</span>,<span style="color: #d75fd7;">81</span>,<span style="color: #d75fd7;">82</span>,<span style="color: #d75fd7;">84</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"UPQRT"</span> <span style="color: #df005f; font-weight: bold;">Empty</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldr B.cons B.empty <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">50</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">60</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"2"</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"3"</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"4"</span> <span style="color: #2aa198;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"5"</span> <span style="color: #67b11d;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"6"</span> <span style="color: #875f00;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"7"</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"8"</span> <span style="color: #d75fd7;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"9"</span> <span style="color: #2aa198;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">":"</span> <span style="color: #9cb6ad;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">";"</span> <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"&lt;"</span>
<span style="color: #df005f; font-weight: bold;">Empty</span><span style="color: #268bd2;">)</span><span style="color: #9cb6ad;">)</span><span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span><span style="color: #875f00;">)</span><span style="color: #67b11d;">)</span><span style="color: #2aa198;">)</span><span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span>
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> foldr B.cons' B.empty <span style="color: #268bd2;">[</span><span style="color: #d75fd7;">50</span><span style="color: #8787d7;">..</span><span style="color: #d75fd7;">60</span><span style="color: #268bd2;">]</span>
<span style="color: #df005f; font-weight: bold;">Chunk</span> <span style="color: #2aa198;">"23456789:;&lt;"</span> <span style="color: #df005f; font-weight: bold;">Empty</span>
</pre>
</div>

<p>
你可以看到 <b>empty</b> 制造了一个空的 bytestring。也注意到 <code>cons</code> 跟 <code>cons'​</code> 的差异了吗？有了 <code>foldr</code> ，我们逐步地把一串数字从右边开始，一个个放到bytestring
的前头。当我们用 <code>cons</code> ，我们则得到一个 byte 一个 chunk的结果，并不是我们要的。
</p>

<p>
bytestring 模块有一大票很像 <code>Data.List</code> 中的函数。包括了 <code>head</code> ， <code>tail</code> ，
 <code>init</code> ， <code>null</code> ， <code>length</code> ， <code>map</code> ， <code>reverse</code> ， <code>foldl</code> ， <code>foldr</code> ，
 <code>concat</code> ，=takeWhile= ， <code>filter</code> ，等等。
</p>

<p>
他也有表现得跟 <code>System.IO</code> 中一样的函数，只有 <code>Strings</code> 被换成了 <code>ByteString</code>
而已。像是 <code>System.IO</code> 中的 <code>readFile</code> ，他的型态是 <code>readFile :: FilePath -&gt;
   IO String</code> ，而 bytestring 模块中的 *readFile*则是 <code>readFile :: FilePath -&gt;
   IO ByteString</code> 。小心，如果你用了 strict bytestring 来读取一个文件，他会把文件内容都读进内存中。而使用 lazy bytestring，他则会读取 chunks。
</p>

<p>
让我们来写一个简单的程序，他从命令行接受两个文件名，然后拷贝第一个文件内容成第二个文件。虽然 <code>System.Directory</code> 中已经有一个函数叫 <code>copyFile</code> ，但我们想要实作自己的版本。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #268bd2; font-weight: bold;">qualified</span> <span style="color: #df005f; font-weight: bold;">Data.ByteString.Lazy</span> <span style="color: #268bd2; font-weight: bold;">as</span> <span style="color: #df005f; font-weight: bold;">B</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    <span style="color: #268bd2;">(</span>fileName1<span style="color: #df005f; font-weight: bold;">:</span>fileName2<span style="color: #df005f; font-weight: bold;">:</span><span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
    copyFile fileName1 fileName2

<span style="color: #d75fd7; font-weight: bold;">copyFile</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">FilePath</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">FilePath</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">copyFile</span> source dest <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span>
    contents <span style="color: #8787d7;">&lt;-</span> B.readFile source
    B.writeFile dest contents
</pre>
</div>

<p>
我们写了自己的函数，他接受两个 <code>FilePath</code> （记住 <code>FilePath</code> 不过是 <code>String</code>
的同义词。）并回传一个 I/O action，他会用 bytestring拷贝第一个文件至另一个。在 <code>main</code> 函数中，我们做的只是拿到命令行引数然后调用那个函数来拿到一个 I/O
action。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell bytestringcopy<span style="color: #8787d7;">.</span>hs something<span style="color: #8787d7;">.</span>txt <span style="color: #8787d7;">../../</span>something<span style="color: #8787d7;">.</span>txt
</pre>
</div>

<p>
就算我们不用 bytestring 来写，程序最后也会长得像这样。差别在于我们会用
 <code>B.readFile</code> 跟 <code>B.writeFile</code> 而不是 <code>readFile</code> 跟 <code>writeFile</code> 。有很大的可能性，就是你只要 import 文件并在函数前加上qualified 模块名，就可以把一个用正常 String 的程序改成用ByteString。也有可能你是要反过来做，但那也不难。
</p>

<p>
当你需要更好的性能来读取许多数据，尝试用bytestring，有很大的机会你会用很小的力气改进很多性能。我通常用正常String 来写程序，然后在性能不好的时候把他们改成
ByteString。
</p>
</div>
</div>

<div id="outline-container-org4c779d3" class="outline-3">
<h3 id="org4c779d3"><span class="section-number-3">1.6</span> Exceptions (例外)</h3>
<div class="outline-text-3" id="text-1-6">

<div class="figure">
<p><img src="timber.png" alt="timber.png">
</p>
</div>

<p>
所有的编程语言都有要处理失败的情形。这就是人生。不同的语言有不同的处理方式。在C 里面，我们通常用非正常范围的回传值（像是 <code>-1</code> 或null）来回传错误。Java 跟
C#则倾向于使用 exception来处理失败的情况。当一个 exception被丢出的时候，控制流程就会跳到我们做一些清理动作的地方，做完清理后exception 被重新丢出，这样一些处理错误的代码可以完成他们的工作。
</p>

<p>
Haskell 有一个很棒的型态系统。Algebraic data types 允许像是 <code>Maybe</code> 或
 <code>Either</code> 这种型态，我们能用这些型态来代表一些可能有或没有的结果。在 C里面，在失败的时候回传 <code>-1</code> 是很常见的事。但他只对写程序的人有意义。如果我们不小心，我们有可能把这些错误码当作正常值来处理，便造成一些混乱。Haskell的型态系统赋予我们更安全的环境。一个 <code>a -&gt; Maybe b</code> 的函数指出了他会产生一个包含 <code>b</code> 的
 <code>Just</code> ，或是回传 <code>Nothing</code> 。这型态跟 <code>a -&gt; b</code> 是不同的，如果我们试着将两个函数混用，compiler 便会警告我们。
</p>

<p>
尽管有表达力够强的型态来辅助失败的情形，Haskell 仍然支持 exception，因为
exception 在 I/O 的 contexts 下是比较合理的。在处理 I/O的时候会有一堆奇奇怪怪的事情发生，环境是很不能被信赖的。像是打开文件。文件有可能被lock起来，也有可能文件被移除了，或是整个硬盘都被拔掉。所以直接跳到处理错误的代码是很合理的。
</p>

<p>
我们了解到 I/O code 会丢出 exception 是件合理的事。至于 pure code呢？其实他也能丢出 Exception。想想看 <code>div</code> 跟 <code>head=两个案例。他们的型态是 ~(Integral a)
   =&gt; a -&gt; a -&gt; a~ 以及 =[a] -&gt; a</code> 。 <code>Maybe</code> 跟 <code>Either</code> 都没有在他们的回传型态中，但他们都有可能失败。=div= 有可能除以零，而 <code>head</code> 有可能你传给他一个空的
list。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> <span style="color: #d75fd7;">4</span> <span style="color: #8787d7;">`div`</span> <span style="color: #d75fd7;">0</span>
<span style="color: #8787d7;">***</span> <span style="color: #df005f; font-weight: bold;">Exception:</span> divide by zero
ghci<span style="color: #d75fd7; font-weight: bold;">&gt;</span> head <span style="color: #268bd2; font-weight: bold;">[]</span>
<span style="color: #8787d7;">***</span> <span style="color: #df005f; font-weight: bold;">Exception:</span> Prelude.head<span style="color: #df005f; font-weight: bold;">:</span> empty list
</pre>
</div>


<div class="figure">
<p><img src="police.png" alt="police.png">
</p>
</div>

<p>
pure code 能丢出 Exception，但 Exception 只能在 I/O section中被接到（也就是在
<code>main</code> 的 do block 中）这是因为在 pure code中你不知道什么东西什么时候会被
evaluate。因为 lazy特性的缘故，程序没有一个特定的执行顺序，但 I/O code 有。
</p>

<p>
先前我们谈过为什么在 I/O 部份的程序要越少越好。程序的逻辑部份尽量都放在pure
的部份，因为 pure的特性就是他们的结果只会根据函数的参数不同而改变。当思考
pure function的时候，你只需要考虑他回传什么，因为除此之外他不会有任何副作用。这会让事情简单许多。尽管I/O 的部份是难以避免的（像是打开文件之类），但最好是把 I/O部份降到最低。Pure functions 缺省是 lazy，那代表我们不知道他什么时候会被evaluate，不过我们也不该知道。然而，一旦 pure functions 需要丢出Exception，他们何时被 evaluate 就很重要了。那是因为我们只有在 I/O的部份才能接到
Exception。这很糟糕，因为我们说过希望 I/O的部份越少越好。但如果我们不接
Exception，我们的程序就会当掉。这问题有解决办法吗？答案是不要在 pure code 里面使用 Exception。利用 Haskell 的型态系统，尽量使用 <code>Either</code> 或 <code>Maybe</code> 之类的型态来表示可能失败的计算。
</p>

<p>
这也是为什么我们要来看看怎么使用 I/O Excetion。I/O Exception 是当我们在
<code>main</code> 里面跟外界沟通失败而丢出的Exception。例如我们尝试打开一个文件，结果发现他已经被删掉或是其他状况。来看看一个尝试打开命令行引数所指定文件名称，并计算里面有多少行的程序。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> <span style="color: #268bd2;">(</span>fileName<span style="color: #df005f; font-weight: bold;">:</span><span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
            contents <span style="color: #8787d7;">&lt;-</span> readFile fileName
            putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"The file has "</span> <span style="color: #8787d7;">++</span> show <span style="color: #268bd2;">(</span>length <span style="color: #d75fd7;">(</span>lines contents<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" lines!"</span>
</pre>
</div>

<p>
一个很简单的程序。我们使用 <code>getArgs</code> I/O action，并绑定第一个 string 到
 <code>fileName</code> 。然后我们绑定文件内容到 <code>contents</code> 。最后，我们用 <code>lines</code> 来取得
 line 的 list，并计算 list 的长度，并用 <code>show</code> 来转换数字成string。他如我们想像的工作，但当我们给的文件名称不存在的时候呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell linecount<span style="color: #8787d7;">.</span>hs i_dont_exist<span style="color: #8787d7;">.</span>txt
linecount<span style="color: #d75fd7; font-weight: bold;">.</span>hs<span style="color: #df005f; font-weight: bold;">:</span> i_dont_exist<span style="color: #8787d7;">.</span>txt<span style="color: #df005f; font-weight: bold;">:</span> openFile<span style="color: #df005f; font-weight: bold;">:</span> does not exist <span style="color: #268bd2;">(</span><span style="color: #df005f; font-weight: bold;">No</span> such file or directory<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
GHC丢了错误消息给我们，告诉我们文件不存在。然后程序就挂掉了。假如我们希望打印出比较好一些的错误消息呢？一种方式就是在打开文件前检查他存不存在。用
<code>System.Directory</code> 中的 *doesFileExist*。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Directory</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> <span style="color: #268bd2;">(</span>fileName<span style="color: #df005f; font-weight: bold;">:</span><span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
            fileExists <span style="color: #8787d7;">&lt;-</span> doesFileExist fileName
            <span style="color: #268bd2; font-weight: bold;">if</span> fileExists
                <span style="color: #268bd2; font-weight: bold;">then</span> <span style="color: #268bd2; font-weight: bold;">do</span> contents <span style="color: #8787d7;">&lt;-</span> readFile fileName
                    putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"The file has "</span> <span style="color: #8787d7;">++</span> show <span style="color: #268bd2;">(</span>length <span style="color: #d75fd7;">(</span>lines contents<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" lines!"</span>
                <span style="color: #268bd2; font-weight: bold;">else</span> <span style="color: #268bd2; font-weight: bold;">do</span> putStrLn <span style="color: #2aa198;">"The file doesn't exist!"</span>
</pre>
</div>

<p>
由于 <code>doesFileExist</code> 的型态是 <code>doesFileExist :: FilePath -&gt; IO Bool</code> ，所以我们要写成 <code>fileExists &lt;- doesFileExist fileName</code> 。那代表他回传含有一个布林值告诉我们文件存不存在的I/O action。 <code>doesFileExist</code> 是不能直接在 if expression
中使用的。
</p>

<p>
另一个解法是使用 Exception。在这个情境下使用 Exception是没问题的。文件不存在这个 Exception 是在 I/O 中被丢出，所以在 I/O中接起来也没什么不对。
</p>

<p>
要这样使用 Exception，我们必须使用 <code>System.IO.Error</code> 中的 *catch*函数。他的型态是 <code>catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a</code> 。他接受两个参数，第一个是一个I/O action。像是他可以接受一个打开文件的 I/O action。第二个是handler。如果第一个参数的 I/O action 丢出了 Exception，则他会被传给handler，他会决定要作些什么。所以整个 I/O action的结果不是如预期中做完第一个参数的 I/O action，就是 handler 处理的结果。
</p>


<div class="figure">
<p><img src="puppy.png" alt="puppy.png">
</p>
</div>

<p>
如果你对其他语言像是 Java, Python 中 try-catch 的形式很熟，那 <code>catch</code> 其实跟他们很像。第一个参数就是其他语言中的 try block。第二个参数就是其他语言中的
catch block。其中 handler 只有在exception 被丢出时才会被执行。
</p>

<p>
handler 接受一个 <code>IOError</code> 型态的值，他代表的是一个 I/O exception已经发生了。他也带有一些 exception本身的信息。至于这型态在语言中使如何被实作则是要看编译器。这代表我们没办法用pattern matching 的方式来查看 <code>IOError</code> 。就像我们不能用 pattern matching来查看 <code>IO something</code> 的内容。但我们能用一些 predicate 来查看他们。
</p>

<p>
我们来看看一个展示 <code>catch</code> 的程序
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO.Error</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> toTry <span style="color: #8787d7;">`catch`</span> handler

<span style="color: #d75fd7; font-weight: bold;">toTry</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">toTry</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> <span style="color: #268bd2;">(</span>fileName<span style="color: #df005f; font-weight: bold;">:</span><span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
            contents <span style="color: #8787d7;">&lt;-</span> readFile fileName
            putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"The file has "</span> <span style="color: #8787d7;">++</span> show <span style="color: #268bd2;">(</span>length <span style="color: #d75fd7;">(</span>lines contents<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" lines!"</span>

<span style="color: #d75fd7; font-weight: bold;">handler</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IOError</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">handler</span> e <span style="color: #8787d7;">=</span> putStrLn <span style="color: #2aa198;">"Whoops, had some trouble!"</span>
</pre>
</div>

<p>
首先你看到我们可以在关键字周围加上 backticks 来把 <code>catch</code> 当作 infix function
用，因为他刚好接受两个参数。这样使用让可读性变好。 <code>toTry `catch` handler</code> 跟
<code>catch toTry handler</code> 是一模一样的。 <code>toTry</code> 是一个 I/O action，而 <code>handler</code>
接受一个 <code>IOError</code> ，并回传一个当 exception 发生时被执行的 I/O action。
</p>

<p>
来看看执行的结果。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #8787d7;">$</span> runhaskell count_lines<span style="color: #8787d7;">.</span>hs i_exist<span style="color: #8787d7;">.</span>txt
<span style="color: #df005f; font-weight: bold;">The</span> file has <span style="color: #d75fd7;">3</span> lines<span style="color: #8787d7;">!</span>

<span style="color: #8787d7;">$</span> runhaskell count_lines<span style="color: #8787d7;">.</span>hs i_dont_exist<span style="color: #8787d7;">.</span>txt
<span style="color: #df005f; font-weight: bold;">Whoops</span>, had some trouble<span style="color: #8787d7;">!</span>
</pre>
</div>

<p>
在 handler 里面我们并没有检查我们拿到的是什么样的 <code>IOError</code> ，我们只是打印出
 =​"Whoops, had some trouble!"​= 。接住任何种类的Exception 就跟其他语言一样，在
 Haskell中也不是一个好的习惯。假如其他种类的 Exception发生了，好比说我们送一个中断指令，而我们没有接到的话会发生什么事？这就是为什么我们要做跟其他语言一样的事：就是检查我们拿到的是什么样的Exception。如果说是我们要的Exception，那就做对应的处理。如果不是，我们再重新丢出Exception。我们把我们的程序这样修改，只接住文件不存在的 Exception。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO.Error</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> toTry <span style="color: #8787d7;">`catch`</span> handler

<span style="color: #d75fd7; font-weight: bold;">toTry</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">toTry</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> <span style="color: #268bd2;">(</span>fileName<span style="color: #df005f; font-weight: bold;">:</span><span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
            contents <span style="color: #8787d7;">&lt;-</span> readFile fileName
            putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"The file has "</span> <span style="color: #8787d7;">++</span> show <span style="color: #268bd2;">(</span>length <span style="color: #d75fd7;">(</span>lines contents<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" lines!"</span>

<span style="color: #d75fd7; font-weight: bold;">handler</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IOError</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">handler</span> e
    <span style="color: #8787d7;">|</span> isDoesNotExistError e <span style="color: #8787d7;">=</span> putStrLn <span style="color: #2aa198;">"The file doesn't exist!"</span>
    <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> ioError e
</pre>
</div>

<p>
除了 handler 以外其他东西都没变，我们只接住我们想要的 I/O exception。这边使用了 <code>System.IO.Error</code> 中的函数 *isDoesNotExistError*跟 *ioError*。
<code>isDoesNotExistError</code> 是一个运作在 <code>IOError</code> 上的predicate ，他代表他接受一个
<code>IOError</code> 然后回传 <code>True</code> 或 <code>False</code> ，他的型态是 <code>isDoesNotExistError ::
   IOError -&gt; Bool</code> 。我们用他来判断是否这个错误是文件不存在所造成的。我们这边使用guard，但其实也可以用 if else。如果 exception不是由于文件不存在所造成的，我们就用 <code>ioEroror</code> 重新丢出接到的exception。他的型态是 <code>ioError :: IOException
   -&gt; IO a</code> ，所以他接受一个 <code>IOError</code> 然后产生一个会丢出 exception 的 I/O
action。那个 I/O action的型态是 <code>IO a</code> ，但他其实不会产生任何结果，所以他可以被当作是=IO anything= 。
</p>

<p>
所以有可能在 <code>toTry</code> 里面丢出的 exception 并不是文件不存在造成的，而 <code>toTry
   `catch` handler</code> 会接住再丢出来，很酷吧。
</p>

<p>
程序里面有好几个运作在 <code>IOError</code> 上的 I/O action，当其中一个没有被evaluate 成
 <code>True</code> 时，就会掉到下一个 guard。这些 predicate 分别为：
</p>

<pre class="example">
* **isAlreadyExistsError**
* **isDoesNotExistError**
* **isFullError**
* **isEOFError**
* **isIllegalOperation**
* **isPermissionError**
* **isUserError**
</pre>

<p>
大部分的意思都是显而易见的。当我们用了 <b>userError</b> 来丢出 exception的时候，
 <code>isUserError</code> 被 evaluate 成 <code>True</code> 。例如说，你可以写 <code>ioError $ userError
    "remote computer unplugged!"​</code> ，尽管用 <code>Either</code> 或 <code>Maybe</code> 来表示可能的错误会比自己丢出 exception 更好。
</p>

<p>
所以你可能写一个像这样的 handler
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">handler</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IOError</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">handler</span> e
    <span style="color: #8787d7;">|</span> isDoesNotExistError e <span style="color: #8787d7;">=</span> putStrLn <span style="color: #2aa198;">"The file doesn't exist!"</span>
    <span style="color: #8787d7;">|</span> isFullError e <span style="color: #8787d7;">=</span> freeSomeSpace
    <span style="color: #8787d7;">|</span> isIllegalOperation e <span style="color: #8787d7;">=</span> notifyCops
    <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> ioError e
</pre>
</div>

<p>
其中 <code>notifyCops</code> 跟 <code>freeSomeSpace</code> 是一些你定义的 I/O action。如果exception
不是你要的，记得要把他们重新丢出，不然你的程序可能只会安静地当掉。
</p>

<p>
 <code>System.IO.Error</code> 也提供了一些能询问 exception 性质的函数，像是哪些handle 造成错误，或哪些文件名造成错误。这些函数都是 <code>ioe</code> 当开头。而且你可以在文档中看到一整串详细数据。假设我们想要打印出造成错误的文件名。我们不能直接打印出从
<code>getArgs</code> 那边拿到的 <code>fileName</code> ，因为只有 <code>IOError</code> 被传进 handler中，而
handler并不知道其他事情。一个函数只依赖于他所被调用时的参数。这也是为什么我们会用*ioeGetFileName* 这函数，他的型态是 <code>ioeGetFileName :: IOError -&gt; Maybe
   FilePath</code> 。他接受一个 <code>IOError</code> 并回传一个 <code>FilePath</code> （他是 <code>String</code> 的同义词。）基本上他做的事就是从 <code>IOError</code> 中抽出文件路径。我们来修改一下我们的程序。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.Environment</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO</span>
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #df005f; font-weight: bold;">System.IO.Error</span>

<span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> toTry <span style="color: #8787d7;">`catch`</span> handler

<span style="color: #d75fd7; font-weight: bold;">toTry</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">toTry</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> <span style="color: #268bd2;">(</span>fileName<span style="color: #df005f; font-weight: bold;">:</span><span style="color: #268bd2; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">&lt;-</span> getArgs
    contents <span style="color: #8787d7;">&lt;-</span> readFile fileName
    putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"The file has "</span> <span style="color: #8787d7;">++</span> show <span style="color: #268bd2;">(</span>length <span style="color: #d75fd7;">(</span>lines contents<span style="color: #d75fd7;">)</span><span style="color: #268bd2;">)</span> <span style="color: #8787d7;">++</span> <span style="color: #2aa198;">" lines!"</span>

<span style="color: #d75fd7; font-weight: bold;">handler</span> <span style="color: #8787d7;">::</span> <span style="color: #df005f; font-weight: bold;">IOError</span> <span style="color: #8787d7;">-&gt;</span> <span style="color: #df005f; font-weight: bold;">IO</span> <span style="color: #268bd2; font-weight: bold;">()</span>
<span style="color: #d75fd7; font-weight: bold;">handler</span> e
    <span style="color: #8787d7;">|</span> isDoesNotExistError e <span style="color: #8787d7;">=</span>
        <span style="color: #268bd2; font-weight: bold;">case</span> ioeGetFileName e <span style="color: #268bd2; font-weight: bold;">of</span> <span style="color: #df005f; font-weight: bold;">Just</span> path <span style="color: #8787d7;">-&gt;</span> putStrLn <span style="color: #8787d7;">$</span> <span style="color: #2aa198;">"Whoops! File does not exist at: "</span> <span style="color: #8787d7;">++</span> path
                                 <span style="color: #df005f; font-weight: bold;">Nothing</span> <span style="color: #8787d7;">-&gt;</span> putStrLn <span style="color: #2aa198;">"Whoops! File does not exist at unknown location!"</span>
    <span style="color: #8787d7;">|</span> otherwise <span style="color: #8787d7;">=</span> ioError e
</pre>
</div>

<p>
在 <code>isDoesNotExistError</code> 是 <code>True</code> 的 guard 里面，我们在 case expression中用
 <code>e</code> 来调用 <code>ioeGetFileName</code> ，然后用 pattern matching 拆出 <code>Maybe</code> 中的值。当你想要用 pattern matching 却又不想要写一个新的函数的时候，case expression
 是你的好朋友。
</p>

<p>
你不想只用一个 <code>catch</code> 来接你 I/O part 中的所有exception。你可以只在特定地方用 <code>catch</code> 接 exception，或你可以用不同的handler。像这样：
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #d75fd7; font-weight: bold;">main</span> <span style="color: #8787d7;">=</span> <span style="color: #268bd2; font-weight: bold;">do</span> toTry <span style="color: #8787d7;">`catch`</span> handler1
          thenTryThis <span style="color: #8787d7;">`catch`</span> handler2
          launchRockets
</pre>
</div>

<p>
这边 <code>toTry</code> 使用 <code>handler1</code> 当作 handler，而 <code>thenTryThis</code> 用了 <code>handler2</code>
 。=launchRockets= 并不是 <code>catch</code> 的参数，所以如果有任何一个exception 被丢出都会让我们的程序当掉，除非 <code>launchRockets</code> 使用 <code>catch</code> 来处理 exception。当然 <code>toTry</code> ， <code>thenTryThis</code> 跟 <code>launchRockets</code> 都是I/O actions，而且被 do
 syntax 绑在一起。这很像其他语言中的 try-catch blocks，你可以把一小段程序用
 try-catch包住，你可以自己调整该包多少进去。
</p>

<p>
现在你知道如何处理 I/O exception 了。我们并没有提到如何从 pure code中丢出
exception，这是因为正如我们先前提到的，Haskell提供了更好的办法来处理错误。就算是在可能会失败的 I/O action中，我也倾向用 <code>IO (Either a b)</code> ，代表他们是
I/O action，但当他们被执行，他们结果的型态是 <code>Either a b</code> ，意思是不是 <code>Left
   a</code> 就是 <code>Right b</code> 。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: 刘向</p>
<p class="date">Created: 2019-12-13 五 22:03</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
